<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fpdf API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>fpdf</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
import sys

from .fpdf import (
    FPDF,
    XPos,
    YPos,
    FPDFException,
    TitleStyle,
    FPDF_FONT_DIR as _FPDF_FONT_DIR,
    FPDF_VERSION as _FPDF_VERSION,
)
from .html import HTMLMixin, HTML2FPDF
from .template import Template, FlexTemplate
from . import svg
from .deprecation import WarnOnDeprecatedModuleAttributes

FPDF_VERSION = _FPDF_VERSION
&#34;&#34;&#34;Current FPDF Version, also available via `__version__` (which is read by `setup.py`):

&lt;pre&gt;
&gt;&gt;&gt; import fpdf
&gt;&gt;&gt; fpdf.__version__
&#39;2.2.0&#39;
&lt;/pre&gt;
&#34;&#34;&#34;

FPDF_FONT_DIR = _FPDF_FONT_DIR
&#34;&#34;&#34;This is the location of where to look for fonts.&#34;&#34;&#34;

sys.modules[__name__].__class__ = WarnOnDeprecatedModuleAttributes

__license__ = &#34;LGPL 3.0&#34;

__version__ = FPDF_VERSION


__all__ = [
    # metadata
    &#34;__version__&#34;,
    &#34;__license__&#34;,
    # Classes
    &#34;FPDF&#34;,
    &#34;XPos&#34;,
    &#34;YPos&#34;,
    &#34;Template&#34;,
    &#34;FlexTemplate&#34;,
    &#34;TitleStyle&#34;,
    &#34;HTMLMixin&#34;,
    &#34;HTML2FPDF&#34;,
    # FPDF Constants
    &#34;FPDF_VERSION&#34;,
    &#34;FPDF_FONT_DIR&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="fpdf.actions" href="actions.html">fpdf.actions</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.deprecation" href="deprecation.html">fpdf.deprecation</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.drawing" href="drawing.html">fpdf.drawing</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.errors" href="errors.html">fpdf.errors</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.fonts" href="fonts.html">fpdf.fonts</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.fpdf" href="fpdf.html">fpdf.fpdf</a></code></dt>
<dd>
<div class="desc"><p>fpdf module (in fpdf package housing FPDF class) …</p></div>
</dd>
<dt><code class="name"><a title="fpdf.graphics_state" href="graphics_state.html">fpdf.graphics_state</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.html" href="html.html">fpdf.html</a></code></dt>
<dd>
<div class="desc"><p>HTML Renderer for FPDF.py</p></div>
</dd>
<dt><code class="name"><a title="fpdf.image_parsing" href="image_parsing.html">fpdf.image_parsing</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.line_break" href="line_break.html">fpdf.line_break</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.outline" href="outline.html">fpdf.outline</a></code></dt>
<dd>
<div class="desc"><p>Quoting section 8.2.2 "Document Outline" of the 2006 PDF spec 1.7:</p>
<blockquote>
<p>The document outline consists of a tree-structured hierarchy of outline items …</p>
</blockquote></div>
</dd>
<dt><code class="name"><a title="fpdf.recorder" href="recorder.html">fpdf.recorder</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.structure_tree" href="structure_tree.html">fpdf.structure_tree</a></code></dt>
<dd>
<div class="desc"><p>Quoting the PDF spec:</p>
<blockquote>
<p>PDF’s logical <em>structure facilities</em> provide a mechanism for incorporating
structural information about a document’s content …</p>
</blockquote></div>
</dd>
<dt><code class="name"><a title="fpdf.svg" href="svg.html">fpdf.svg</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.syntax" href="syntax.html">fpdf.syntax</a></code></dt>
<dd>
<div class="desc"><p>PDF Syntax Helpers …</p></div>
</dd>
<dt><code class="name"><a title="fpdf.template" href="template.html">fpdf.template</a></code></dt>
<dd>
<div class="desc"><p>PDF Template Helpers for fpdf.py</p></div>
</dd>
<dt><code class="name"><a title="fpdf.transitions" href="transitions.html">fpdf.transitions</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.ttfonts" href="ttfonts.html">fpdf.ttfonts</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="fpdf.util" href="util.html">fpdf.util</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="fpdf.FPDF_FONT_DIR"><code class="name">var <span class="ident">FPDF_FONT_DIR</span></code></dt>
<dd>
<div class="desc"><p>This is the location of where to look for fonts.</p></div>
</dd>
<dt id="fpdf.FPDF_VERSION"><code class="name">var <span class="ident">FPDF_VERSION</span></code></dt>
<dd>
<div class="desc"><p>Current FPDF Version, also available via <code>__version__</code> (which is read by <code>setup.py</code>):</p>
<pre>

<pre><code class="language-python-repl">&gt;&gt;&gt; import fpdf
&gt;&gt;&gt; fpdf.__version__
'2.2.0'
&lt;/pre&gt;
</code></pre></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.FPDF"><code class="flex name class">
<span>class <span class="ident">FPDF</span></span>
<span>(</span><span>orientation='portrait', unit='mm', format='A4', font_cache_dir='DEPRECATED')</span>
</code></dt>
<dd>
<div class="desc"><p>PDF Generation class</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>orientation</code></strong> :&ensp;<code>str</code></dt>
<dd>possible values are "portrait" (can be abbreviated "P")
or "landscape" (can be abbreviated "L"). Default to "portrait".</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>str, int, float</code></dt>
<dd>possible values are "pt", "mm", "cm", "in", or a number.
A point equals 1/72 of an inch, that is to say about 0.35 mm (an inch being 2.54 cm).
This is a very common unit in typography; font sizes are expressed in this unit.
If given a number, then it will be treated as the number of points per unit.
(eg. 72 = 1 in)
Default to "mm".</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>possible values are "a3", "a4", "a5", "letter", "legal" or a tuple
(width, height) expressed in the given unit. Default to "a4".</dd>
<dt><strong><code>font_cache_dir</code></strong> :&ensp;<code>Path</code> or <code>str</code></dt>
<dd>[<strong>DEPRECATED</strong>] unused</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FPDF(GraphicsStateMixin):
    &#34;PDF Generation class&#34;
    MARKDOWN_BOLD_MARKER = &#34;**&#34;
    MARKDOWN_ITALICS_MARKER = &#34;__&#34;
    MARKDOWN_UNDERLINE_MARKER = &#34;--&#34;

    def __init__(
        self,
        orientation=&#34;portrait&#34;,
        unit=&#34;mm&#34;,
        format=&#34;A4&#34;,
        font_cache_dir=&#34;DEPRECATED&#34;,
    ):
        &#34;&#34;&#34;
        Args:
            orientation (str): possible values are &#34;portrait&#34; (can be abbreviated &#34;P&#34;)
                or &#34;landscape&#34; (can be abbreviated &#34;L&#34;). Default to &#34;portrait&#34;.
            unit (str, int, float): possible values are &#34;pt&#34;, &#34;mm&#34;, &#34;cm&#34;, &#34;in&#34;, or a number.
                A point equals 1/72 of an inch, that is to say about 0.35 mm (an inch being 2.54 cm).
                This is a very common unit in typography; font sizes are expressed in this unit.
                If given a number, then it will be treated as the number of points per unit.  (eg. 72 = 1 in)
                Default to &#34;mm&#34;.
            format (str): possible values are &#34;a3&#34;, &#34;a4&#34;, &#34;a5&#34;, &#34;letter&#34;, &#34;legal&#34; or a tuple
                (width, height) expressed in the given unit. Default to &#34;a4&#34;.
            font_cache_dir (Path or str): [**DEPRECATED**] unused
        &#34;&#34;&#34;
        if font_cache_dir != &#34;DEPRECATED&#34;:
            warnings.warn(
                &#39;&#34;font_cache_dir&#34; parameter is deprecated, unused and will soon be removed&#39;,
                DeprecationWarning,
            )
        super().__init__()
        # Initialization of instance attributes
        self.offsets = {}  # array of object offsets
        self.page = 0  # current page number
        self.n = 2  # current object number
        self.buffer = bytearray()  # buffer holding in-memory PDF
        # Associative array from page number to dicts containing pages and metadata:
        self.pages = {}
        self.state = DocumentState.UNINITIALIZED  # current document state
        self.fonts = {}  # array of used fonts
        self.font_files = {}  # array of font files
        self.diffs = {}  # array of encoding differences
        self.images = {}  # array of used images
        self.annots = defaultdict(list)  # map page numbers to arrays of Annotations
        self.links = {}  # array of Destination
        self.in_footer = 0  # flag set when processing footer
        self.lasth = 0  # height of last cell printed
        self.current_font = {}  # current font
        self.str_alias_nb_pages = &#34;{nb}&#34;

        self.ws = 0  # word spacing
        self.angle = 0  # used by deprecated method: rotate()
        self.xmp_metadata = None
        self.image_filter = &#34;AUTO&#34;
        self.page_duration = 0  # optional pages display duration, cf. add_page()
        self.page_transition = None  # optional pages transition, cf. add_page()
        self.allow_images_transparency = True
        # Do nothing by default. Allowed values: &#39;WARN&#39;, &#39;DOWNSCALE&#39;:
        self.oversized_images = None
        self.oversized_images_ratio = 2  # number of pixels per UserSpace point
        self._markdown_leak_end_style = False
        # Only set if XMP metadata is added to the document:
        self._xmp_metadata_obj_id = None
        self.struct_builder = StructureTreeBuilder()
        self._struct_parents_id_per_page = {}  # {page_object_id -&gt; StructParent(s) ID}
        # Only set if a Structure Tree is added to the document:
        self._struct_tree_root_obj_id = None
        self._outlines_obj_id = None
        self._toc_placeholder = None  # ToCPlaceholder
        self._outline = []  # list of OutlineSection
        self.section_title_styles = {}  # level -&gt; TitleStyle

        # Standard fonts
        self.core_fonts = {
            &#34;courier&#34;: &#34;Courier&#34;,
            &#34;courierB&#34;: &#34;Courier-Bold&#34;,
            &#34;courierI&#34;: &#34;Courier-Oblique&#34;,
            &#34;courierBI&#34;: &#34;Courier-BoldOblique&#34;,
            &#34;helvetica&#34;: &#34;Helvetica&#34;,
            &#34;helveticaB&#34;: &#34;Helvetica-Bold&#34;,
            &#34;helveticaI&#34;: &#34;Helvetica-Oblique&#34;,
            &#34;helveticaBI&#34;: &#34;Helvetica-BoldOblique&#34;,
            &#34;times&#34;: &#34;Times-Roman&#34;,
            &#34;timesB&#34;: &#34;Times-Bold&#34;,
            &#34;timesI&#34;: &#34;Times-Italic&#34;,
            &#34;timesBI&#34;: &#34;Times-BoldItalic&#34;,
            &#34;symbol&#34;: &#34;Symbol&#34;,
            &#34;zapfdingbats&#34;: &#34;ZapfDingbats&#34;,
        }
        self.core_fonts_encoding = &#34;latin-1&#34;
        # Replace these fonts with these core fonts
        self.font_aliases = {
            &#34;arial&#34;: &#34;helvetica&#34;,
            &#34;couriernew&#34;: &#34;courier&#34;,
            &#34;timesnewroman&#34;: &#34;times&#34;,
        }
        # Scale factor
        self.k = get_scale_factor(unit)

        # Graphics state variables defined as properties by GraphicsStateMixin.
        # We set their default values here.
        self.font_family = &#34;&#34;  # current font family
        self.font_style = &#34;&#34;  # current font style
        self.font_size_pt = 12  # current font size in points
        self.font_size = self.font_size_pt / self.k
        self.font_stretching = 100  # current font stretching
        self.underline = 0  # underlining flag
        self.draw_color = &#34;0 G&#34;
        self.fill_color = &#34;0 g&#34;
        self.text_color = &#34;0 g&#34;
        self.dash_pattern = dict(dash=0, gap=0, phase=0)
        self.line_width = 0.567 / self.k  # line width (0.2 mm)
        # end of grapics state variables

        self.dw_pt, self.dh_pt = get_page_format(format, self.k)
        self._set_orientation(orientation, self.dw_pt, self.dh_pt)
        self.def_orientation = self.cur_orientation
        # Page spacing
        # Page margins (1 cm)
        margin = (7200 / 254) / self.k
        self.x, self.y, self.l_margin, self.t_margin = 0, 0, 0, 0
        self.set_margins(margin, margin)
        self.x, self.y = self.l_margin, self.t_margin
        self.c_margin = margin / 10.0  # Interior cell margin (1 mm)
        # sets self.auto_page_break, self.b_margin &amp; self.page_break_trigger:
        self.set_auto_page_break(True, 2 * margin)
        self.set_display_mode(&#34;fullwidth&#34;)  # Full width display mode
        self.compress = True  # Enable compression by default
        self.pdf_version = &#34;1.3&#34;  # Set default PDF version No.
        self._current_draw_context = None

        self._drawing_graphics_state_registry = drawing.GraphicsStateDictRegistry()
        self._graphics_state_obj_refs = OrderedDict()

    @property
    def unifontsubset(self):
        return self.current_font.get(&#34;type&#34;) == &#34;TTF&#34;

    @property
    def epw(self):
        &#34;&#34;&#34;
        Effective page width: the page width minus its horizontal margins.
        &#34;&#34;&#34;
        return self.w - self.l_margin - self.r_margin

    @property
    def eph(self):
        &#34;&#34;&#34;
        Effective page height: the page height minus its vertical margins.
        &#34;&#34;&#34;
        return self.h - self.t_margin - self.b_margin

    @property
    def pages_count(self):
        &#34;&#34;&#34;
        Returns the total pages of the document.
        &#34;&#34;&#34;
        return len(self.pages)

    def set_margin(self, margin):
        &#34;&#34;&#34;
        Sets the document right, left, top &amp; bottom margins to the same value.

        Args:
            margin (float): margin in the unit specified to FPDF constructor
        &#34;&#34;&#34;
        self.set_margins(margin, margin)
        self.set_auto_page_break(self.auto_page_break, margin)

    def set_margins(self, left, top, right=-1):
        &#34;&#34;&#34;
        Sets the document left, top &amp; optionaly right margins to the same value.
        By default, they equal 1 cm.
        Also sets the current FPDF.y on the page to this minimum vertical position.

        Args:
            left (float): left margin in the unit specified to FPDF constructor
            top (float): top margin in the unit specified to FPDF constructor
            right (float): optional right margin in the unit specified to FPDF constructor
        &#34;&#34;&#34;
        self.set_left_margin(left)
        if self.y &lt; top or self.y == self.t_margin:
            self.y = top
        self.t_margin = top
        if right == -1:
            right = left
        self.r_margin = right

    def set_left_margin(self, margin):
        &#34;&#34;&#34;
        Sets the document left margin.
        Also sets the current FPDF.x on the page to this minimum horizontal position.

        Args:
            margin (float): margin in the unit specified to FPDF constructor
        &#34;&#34;&#34;
        if self.x &lt; margin or self.x == self.l_margin:
            self.x = margin
        self.l_margin = margin

    def set_top_margin(self, margin):
        &#34;&#34;&#34;
        Sets the document top margin.

        Args:
            margin (float): margin in the unit specified to FPDF constructor
        &#34;&#34;&#34;
        self.t_margin = margin

    def set_right_margin(self, margin):
        &#34;&#34;&#34;
        Sets the document right margin.

        Args:
            margin (float): margin in the unit specified to FPDF constructor
        &#34;&#34;&#34;
        self.r_margin = margin

    def set_auto_page_break(self, auto, margin=0):
        &#34;&#34;&#34;
        Set auto page break mode and triggering bottom margin.
        By default, the mode is on and the bottom margin is 2 cm.

        Args:
            auto (bool): enable or disable this mode
            margin (float): optional bottom margin (distance from the bottom of the page)
                in the unit specified to FPDF constructor
        &#34;&#34;&#34;
        self.auto_page_break = auto
        self.b_margin = margin
        self.page_break_trigger = self.h - self.b_margin

    def _set_orientation(self, orientation, page_width_pt, page_height_pt):
        orientation = orientation.lower()
        if orientation in (&#34;p&#34;, &#34;portrait&#34;):
            self.cur_orientation = &#34;P&#34;
            self.w_pt = page_width_pt
            self.h_pt = page_height_pt
        elif orientation in (&#34;l&#34;, &#34;landscape&#34;):
            self.cur_orientation = &#34;L&#34;
            self.w_pt = page_height_pt
            self.h_pt = page_width_pt
        else:
            raise FPDFException(f&#34;Incorrect orientation: {orientation}&#34;)
        self.w = self.w_pt / self.k
        self.h = self.h_pt / self.k

    def set_display_mode(self, zoom, layout=&#34;continuous&#34;):
        &#34;&#34;&#34;
        Defines the way the document is to be displayed by the viewer.

        It allows to set tje zoom level: pages can be displayed entirely on screen,
        occupy the full width of the window, use the real size,
        be scaled by a specific zooming factor or use the viewer default (configured in its Preferences menu).

        The page layout can also be specified: single page at a time, continuous display, two columns or viewer default.

        Args:
            zoom: either &#34;fullpage&#34;, &#34;fullwidth&#34;, &#34;real&#34;, &#34;default&#34;,
                or a number indicating the zooming factor to use, interpreted as a percentage.
                The zoom level set by default is &#34;default&#34;.
            layout (str): either &#34;single&#34;, &#34;continuous&#34;, &#34;two&#34; or &#34;default&#34;,
                meaning to use the viewer default mode.
                The layout set by default is &#34;default&#34;,
                and this method default value is &#34;continuous&#34;.
        &#34;&#34;&#34;
        if zoom in ZOOM_CONFIGS or not isinstance(zoom, str):
            self.zoom_mode = zoom
        elif zoom != &#34;default&#34;:
            raise FPDFException(f&#34;Incorrect zoom display mode: {zoom}&#34;)

        if layout in LAYOUT_NAMES:
            self.layout_mode = layout
        elif layout != &#34;default&#34;:
            raise FPDFException(f&#34;Incorrect layout display mode: {layout}&#34;)

    def set_compression(self, compress):
        &#34;&#34;&#34;
        Activates or deactivates page compression.

        When activated, the internal representation of each page is compressed
        using the zlib/deflate method (FlateDecode), which leads to a compression ratio
        of about 2 for the resulting document.

        Page compression is enabled by default.

        Args:
            compress (bool): indicates if compression should be enabled
        &#34;&#34;&#34;
        self.compress = compress

    def set_title(self, title):
        &#34;&#34;&#34;
        Defines the title of the document.

        Args:
            title (str): the title
        &#34;&#34;&#34;
        self.title = title

    def set_lang(self, lang):
        &#34;&#34;&#34;
        A language identifier specifying the natural language for all text in the document
        except where overridden by language specifications for structure elements or marked content.
        A language identifier can either be the empty text string, to indicate that the language is unknown,
        or a Language-Tag as defined in RFC 3066, &#34;Tags for the Identification of Languages&#34;.

        Args:
            lang (str): the document main language
        &#34;&#34;&#34;
        self.lang = lang

    def set_subject(self, subject):
        &#34;&#34;&#34;
        Defines the subject of the document.

        Args:
            subject (str): the document main subject
        &#34;&#34;&#34;
        self.subject = subject

    def set_author(self, author):
        &#34;&#34;&#34;
        Defines the author of the document.

        Args:
            author(str): the name of the author
        &#34;&#34;&#34;
        self.author = author

    def set_keywords(self, keywords):
        &#34;&#34;&#34;
        Associate keywords with the document

        Args:
            keywords (str): a space-separated list of words
        &#34;&#34;&#34;
        self.keywords = keywords

    def set_creator(self, creator):
        &#34;&#34;&#34;
        Defines the creator of the document.
        This is typically the name of the application that generates the PDF.

        Args:
            creator (str): name of the PDF creator
        &#34;&#34;&#34;
        self.creator = creator

    def set_producer(self, producer):
        &#34;&#34;&#34;Producer of document&#34;&#34;&#34;
        self.producer = producer

    def set_creation_date(self, date=None):
        &#34;&#34;&#34;Sets Creation of Date time, or current time if None given.&#34;&#34;&#34;
        self.creation_date = datetime.now() if date is None else date

    def set_xmp_metadata(self, xmp_metadata):
        if &#34;&lt;?xpacket&#34; in xmp_metadata[:50]:
            raise ValueError(
                &#34;fpdf2 already performs XMP metadata wrapping in a &lt;?xpacket&gt; tag&#34;
            )
        self.xmp_metadata = xmp_metadata

    def set_doc_option(self, opt, value):
        &#34;&#34;&#34;
        Defines a document option.

        Args:
            opt (str): name of the option to set
            value (str) option value

        .. deprecated:: 2.4.0
            Simply set the `core_fonts_encoding` property as a replacement.
        &#34;&#34;&#34;
        warnings.warn(
            &#34;set_doc_option() is deprecated. &#34;
            &#34;Simply set the `core_fonts_encoding` property as a replacement.&#34;,
            DeprecationWarning,
        )
        if opt != &#34;core_fonts_encoding&#34;:
            raise FPDFException(f&#39;Unknown document option &#34;{opt}&#34;&#39;)
        self.core_fonts_encoding = value

    def set_image_filter(self, image_filter):
        &#34;&#34;&#34;
        Args:
            image_filter (str): name of a support image filter or &#34;AUTO&#34;,
                meaning to use the best image filter given the images provided.
        &#34;&#34;&#34;
        if image_filter not in SUPPORTED_IMAGE_FILTERS:
            raise ValueError(
                f&#34;&#39;{image_filter}&#39; is not a supported image filter: {&#39;&#39;.join(SUPPORTED_IMAGE_FILTERS)}&#34;
            )
        self.image_filter = image_filter

    def alias_nb_pages(self, alias=&#34;{nb}&#34;):
        &#34;&#34;&#34;
        Defines an alias for the total number of pages.
        It will be substituted as the document is closed.

        This is useful to insert the number of pages of the document
        at a time when this number is not known by the program.

        This substitution can be disabled for performances reasons, by caling `alias_nb_pages(None)`.

        Args:
            alias (str): the alias. Defaults to &#34;{nb}&#34;.

        Notes
        -----

        When using this feature with the `cell` / `multicell` methods,
        or the `underline` attribute of `FPDF` class,
        the width of the text rendered will take into account the alias length,
        not the length of the &#34;actual number of pages&#34; string,
        which can causes slight positioning differences.
        &#34;&#34;&#34;
        self.str_alias_nb_pages = alias

    def open(self):
        &#34;&#34;&#34;
        Starts the generation of the PDF document.
        It is not necessary to call it explicitly because `add_page()` does it automatically.

        Notes
        -----

        This method does not add any page.
        &#34;&#34;&#34;
        self.state = DocumentState.READY

    def close(self):
        &#34;&#34;&#34;
        Terminates the PDF document.

        It is not necessary to call this method explicitly because `output()` does it automatically.
        If the document contains no page, `add_page()` is called to prevent from generating an invalid document.
        &#34;&#34;&#34;
        if self.state == DocumentState.CLOSED:
            return
        if self.page == 0:
            self.add_page()

        # Page footer
        self.in_footer = 1
        self.footer()
        self.in_footer = 0

        self._endpage()  # close page
        self._enddoc()  # close document

    def add_page(
        self, orientation=&#34;&#34;, format=&#34;&#34;, same=False, duration=0, transition=None
    ):
        &#34;&#34;&#34;
        Adds a new page to the document.
        If a page is already present, the `footer()` method is called first.
        Then the page  is added, the current position is set to the top-left corner,
        with respect to the left and top margins, and the `header()` method is called.

        Args:
            orientation (str): &#34;portrait&#34; (can be abbreviated &#34;P&#34;)
                or &#34;landscape&#34; (can be abbreviated &#34;L&#34;). Default to &#34;portrait&#34;.
            format (str): &#34;a3&#34;, &#34;a4&#34;, &#34;a5&#34;, &#34;letter&#34;, &#34;legal&#34; or a tuple
                (width, height). Default to &#34;a4&#34;.
            same (bool): indicates to use the same page format as the previous page.
                Default to False.
            duration (float): optional page’s display duration, i.e. the maximum length of time,
                in seconds, that the page is displayed in presentation mode,
                before the viewer application automatically advances to the next page.
                Can be configured globally through the `page_duration` FPDF property.
                As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.
            transition (Transition child class): optional visual transition to use when moving
                from another page to the given page during a presentation.
                Can be configured globally through the `page_transition` FPDF property.
                As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.
        &#34;&#34;&#34;
        if self.state == DocumentState.CLOSED:
            raise FPDFException(
                &#34;A page cannot be added on a closed document, after calling output()&#34;
            )
        if self.state == DocumentState.UNINITIALIZED:
            self.open()

        family = self.font_family
        style = f&#34;{self.font_style}U&#34; if self.underline else self.font_style
        size = self.font_size_pt
        lw = self.line_width
        dc = self.draw_color
        fc = self.fill_color
        tc = self.text_color
        stretching = self.font_stretching

        if self.page &gt; 0:
            # Page footer
            self.in_footer = 1
            self.footer()
            self.in_footer = 0
            # close page
            self._endpage()

        # Start new page
        self._beginpage(
            orientation,
            format,
            same,
            duration or self.page_duration,
            transition or self.page_transition,
            new_page=not self._has_next_page(),
        )

        self._out(&#34;2 J&#34;)  # Set line cap style to square
        self.line_width = lw  # Set line width
        self._out(f&#34;{lw * self.k:.2f} w&#34;)

        # Set font
        if family:
            self.set_font(family, style, size)

        # Set colors
        self.draw_color = dc
        if dc != &#34;0 G&#34;:
            self._out(dc)
        self.fill_color = fc
        if fc != &#34;0 g&#34;:
            self._out(fc)
        self.text_color = tc

        # BEGIN Page header
        self.header()

        if self.line_width != lw:  # Restore line width
            self.line_width = lw
            self._out(f&#34;{lw * self.k:.2f} w&#34;)

        if family:
            self.set_font(family, style, size)  # Restore font

        if self.draw_color != dc:  # Restore colors
            self.draw_color = dc
            self._out(dc)
        if self.fill_color != fc:
            self.fill_color = fc
            self._out(fc)
        self.text_color = tc

        if stretching != 100:  # Restore stretching
            self.set_stretching(stretching)
        # END Page header

    def header(self):
        &#34;&#34;&#34;
        Header to be implemented in your own inherited class

        This is automatically called by `add_page()`
        and should not be called directly by the user application.
        The default implementation performs nothing: you have to override this method
        in a subclass to implement your own rendering logic.
        &#34;&#34;&#34;

    def footer(self):
        &#34;&#34;&#34;
        Footer to be implemented in your own inherited class.

        This is automatically called by `add_page()` and `close()`
        and should not be called directly by the user application.
        The default implementation performs nothing: you have to override this method
        in a subclass to implement your own rendering logic.
        &#34;&#34;&#34;

    def page_no(self):
        &#34;&#34;&#34;Get the current page number&#34;&#34;&#34;
        return self.page

    def set_draw_color(self, r, g=-1, b=-1):
        &#34;&#34;&#34;
        Defines the color used for all stroking operations (lines, rectangles and cell borders).
        It can be expressed in RGB components or grey scale.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            r (int): if `g` and `b` are given, this indicates the red component.
                Else, this indicates the grey level. The value must be between 0 and 255.
            g (int): green component (between 0 and 255)
            b (int): blue component (between 0 and 255)
        &#34;&#34;&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.draw_color = f&#34;{r / 255:.3f} G&#34;
        else:
            self.draw_color = f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} RG&#34;
        if self.page &gt; 0:
            self._out(self.draw_color)

    def set_fill_color(self, r, g=-1, b=-1):
        &#34;&#34;&#34;
        Defines the color used for all filling operations (filled rectangles and cell backgrounds).
        It can be expressed in RGB components or grey scale.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            r (int): if `g` and `b` are given, this indicates the red component.
                Else, this indicates the grey level. The value must be between 0 and 255.
            g (int): green component (between 0 and 255)
            b (int): blue component (between 0 and 255)
        &#34;&#34;&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.fill_color = f&#34;{r / 255:.3f} g&#34;
        else:
            self.fill_color = f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} rg&#34;
        if self.page &gt; 0:
            self._out(self.fill_color)

    def set_text_color(self, r, g=-1, b=-1):
        &#34;&#34;&#34;
        Defines the color used for text.
        It can be expressed in RGB components or grey scale.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            r (int): if `g` and `b` are given, this indicates the red component.
                Else, this indicates the grey level. The value must be between 0 and 255.
            g (int): green component (between 0 and 255)
            b (int): blue component (between 0 and 255)
        &#34;&#34;&#34;
        if (r == 0 and g == 0 and b == 0) or g == -1:
            self.text_color = f&#34;{r / 255:.3f} g&#34;
        else:
            self.text_color = f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} rg&#34;

    def get_string_width(self, s, normalized=False, markdown=False):
        &#34;&#34;&#34;
        Returns the length of a string in user unit. A font must be selected.
        The value is calculated with stretching and spacing.

        Args:
            s (str): the string whose length is to be computed.
            normalized (bool): whether normalization needs to be performed on the input string.
            markdown (bool): indicates if basic markdown support is enabled
        &#34;&#34;&#34;
        # normalized is parameter for internal use
        s = s if normalized else self.normalize_text(s)
        w = 0
        for frag in (
            self._markdown_parse(s)
            if markdown
            else (Fragment.from_string(s, self.font_style, bool(self.underline)),)
        ):
            w += self.get_normalized_string_width_with_style(frag.string, frag.style)
        if self.font_stretching != 100:
            w *= self.font_stretching / 100
        return w * self.font_size / 1000

    def get_normalized_string_width_with_style(self, string, style):
        &#34;&#34;&#34;
        Returns the length of a string with given style

        Args:
            string (str): the string whose length is to be computed.
            style (str) : the string representing the style
        &#34;&#34;&#34;
        w = 0
        font = self.fonts[self.font_family + style]
        if self.unifontsubset:
            for char in string:
                w += _char_width(font, ord(char))
        else:
            w += sum(_char_width(font, char) for char in string)
        return w

    def set_line_width(self, width):
        &#34;&#34;&#34;
        Defines the line width of all stroking operations (lines, rectangles and cell borders).
        By default, the value equals 0.2 mm.
        The method can be called before the first page is created and the value is retained from page to page.

        Args:
            width (float): the width in user unit
        &#34;&#34;&#34;
        self.line_width = width
        if self.page &gt; 0:
            self._out(f&#34;{width * self.k:.2f} w&#34;)

    @contextmanager
    @check_page
    def drawing_context(self, debug_stream=None):
        &#34;&#34;&#34;
        Create a context for drawing paths on the current page.

        If this context manager is called again inside of an active context, it will
        raise an exception, as base drawing contexts cannot be nested.

        Args:
            debug_stream (TextIO): print a pretty tree of all items to be rendered
                to the provided stream. To store the output in a string, use
                `io.StringIO`.
        &#34;&#34;&#34;

        if self._current_draw_context is not None:
            raise FPDFException(
                &#34;cannot create a drawing context while one is already open&#34;
            )

        context = drawing.DrawingContext()
        self._current_draw_context = context
        try:
            yield context
        finally:
            self._current_draw_context = None

        starting_style = drawing.GraphicsStyle()
        starting_style.allow_transparency = self.allow_images_transparency
        starting_style.stroke_width = self.line_width

        dash_info = self.dash_pattern
        dash_pattern = (dash_info[&#34;dash&#34;], dash_info[&#34;gap&#34;])
        if (dash_pattern[0] == 0) or (dash_pattern[1] == 0):
            dash_pattern = None

        starting_style.stroke_dash_pattern = dash_pattern
        starting_style.stroke_dash_phase = dash_info[&#34;phase&#34;]

        render_args = (
            self._drawing_graphics_state_registry,
            drawing.Point(self.x, self.y),
            self.k,
            self.h,
            starting_style,
        )

        if debug_stream:
            rendered = context.render_debug(*render_args, debug_stream)
        else:
            rendered = context.render(*render_args)

        self._out(rendered)

        self.pdf_version = max(self.pdf_version, &#34;1.4&#34;)

    @contextmanager
    def new_path(
        self, x=0, y=0, paint_rule=drawing.PathPaintRule.AUTO, debug_stream=None
    ):
        &#34;&#34;&#34;
        Create a path for appending lines and curves to.

        Args:
            x (float): Abscissa of the path starting point
            y (float): Ordinate of the path starting point
            paint_rule (drawing.PathPaintRule): Optional choice of how the path should
                be painted. The default (AUTO) automatically selects stroke/fill based
                on the path style settings.
            debug_stream (TextIO): print a pretty tree of all items to be rendered
                to the provided stream. To store the output in a string, use
                `io.StringIO`.

        &#34;&#34;&#34;
        with self.drawing_context(debug_stream=debug_stream) as ctxt:
            path = drawing.PaintedPath(x=x, y=y)
            path.style.paint_rule = paint_rule
            yield path
            ctxt.add_item(path)

    def draw_path(self, path, debug_stream=None):
        &#34;&#34;&#34;
        Add a pre-constructed path to the document.

        Args:
            path (drawing.PaintedPath): the path to be drawn.
            debug_stream (TextIO): print a pretty tree of all items to be rendered
                to the provided stream. To store the output in a string, use
                `io.StringIO`.
        &#34;&#34;&#34;
        with self.drawing_context(debug_stream=debug_stream) as ctxt:
            ctxt.add_item(path)

    def set_dash_pattern(self, dash=0, gap=0, phase=0):
        &#34;&#34;&#34;
        Set the current dash pattern for lines and curves.

        Args:
            dash (float &gt;= 0):
                The length of the dashes in current units.

            gap (float &gt;= 0):
                The length of the gaps between dashes in current units.
                If omitted, the dash length will be used.

            phase (float &gt;= 0):
                Where in the sequence to start drawing.

        Omitting &#39;dash&#39; (= 0) resets the pattern to a solid line.
        &#34;&#34;&#34;
        if not (isinstance(dash, (int, float)) and dash &gt;= 0):
            raise ValueError(&#34;Dash length must be zero or a positive number.&#34;)
        if not (isinstance(gap, (int, float)) and gap &gt;= 0):
            raise ValueError(&#34;gap length must be zero or a positive number.&#34;)
        if not (isinstance(phase, (int, float)) and phase &gt;= 0):
            raise ValueError(&#34;Phase must be zero or a positive number.&#34;)

        pattern = dict(dash=dash, gap=gap, phase=phase)

        if pattern != self.dash_pattern:
            self.dash_pattern = pattern

            if dash:
                if gap:
                    dstr = f&#34;[{dash * self.k:.3f} {gap * self.k:.3f}] {phase *self.k:.3f} d&#34;
                else:
                    dstr = f&#34;[{dash * self.k:.3f}] {phase *self.k:.3f} d&#34;
            else:
                dstr = &#34;[] 0 d&#34;

            self._out(dstr)

    @check_page
    def line(self, x1, y1, x2, y2):
        &#34;&#34;&#34;
        Draw a line between two points.

        Args:
            x1 (float): Abscissa of first point
            y1 (float): Ordinate of first point
            x2 (float): Abscissa of second point
            y2 (float): Ordinate of second point
        &#34;&#34;&#34;
        self._out(
            f&#34;{x1 * self.k:.2f} {(self.h - y1) * self.k:.2f} m {x2 * self.k:.2f} &#34;
            f&#34;{(self.h - y2) * self.k:.2f} l S&#34;
        )

    @check_page
    def polyline(self, point_list, fill=False, polygon=False):
        &#34;&#34;&#34;
        Draws lines between two or more points.

        Args:
            point_list (list of tuples): List of Abscissa and Ordinate of
                                        segments that should be drawn
            fill (bool): If true then polyline should be filled
            polygon (bool): If true, close path before stroking
        &#34;&#34;&#34;
        operator = &#34;m&#34;
        for point in point_list:
            self._out(
                f&#34;{point[0] * self.k:.2f} {(self.h - point[1]) * self.k:.2f} {operator}&#34;
            )
            operator = &#34;l&#34;
        if polygon:
            self._out(&#34; h &#34;)
        if fill:
            self._out(&#34; B &#34;)
        else:
            self._out(&#34; S &#34;)

    @check_page
    def polygon(self, point_list, fill=False):
        &#34;&#34;&#34;
        Outputs a polygon defined by three or more points.

        Args:
            point_list (list of tuples): List of Abscissa and Ordinate of
                                        polygon that should be drawn
            fill (bool): If true polygon will be filled
        &#34;&#34;&#34;
        self.polyline(point_list, fill=fill, polygon=True)

    @check_page
    def dashed_line(self, x1, y1, x2, y2, dash_length=1, space_length=1):
        &#34;&#34;&#34;
        Draw a dashed line between two points.
        **DEPRECATED** 2.4.6
        - use set_dash_pattern() and the normal drawing operations instead

        Args:
            x1 (float): Abscissa of first point
            y1 (float): Ordinate of first point
            x2 (float): Abscissa of second point
            y2 (float): Ordinate of second point
            dash_length (float): Length of the dash
            space_length (float): Length of the space between 2 dashes
        &#34;&#34;&#34;
        warnings.warn(
            &#34;dashed_line() is deprecated, and will be removed in a future release. &#34;
            &#34;Use set_dash_pattern() and the normal drawing operations instead.&#34;,
            DeprecationWarning,
        )
        self.set_dash_pattern(dash_length, space_length)
        self.line(x1, y1, x2, y2)
        self.set_dash_pattern()

    @check_page
    def rect(self, x, y, w, h, style=None):
        &#34;&#34;&#34;
        Outputs a rectangle.
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of upper-left bounging box.
            y (float): Ordinate of upper-left bounging box.
            w (float): Width.
            h (float): Height.
            style (str): Style of rendering. Possible values are:
                * `D` or empty string: draw border. This is the default value.
                * `F`: fill
                * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        op = _style_to_operator(style)
        self._out(
            f&#34;{x * self.k:.2f} {(self.h - y) * self.k:.2f} {w * self.k:.2f} &#34;
            f&#34;{-h * self.k:.2f} re {op}&#34;
        )

    @check_page
    def ellipse(self, x, y, w, h, style=None):
        &#34;&#34;&#34;
        Outputs an ellipse.
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of upper-left bounging box.
            y (float): Ordinate of upper-left bounging box.
            w (float): Width.
            h (float): Height.
            style (str): Style of rendering. Possible values are:
                * `D` or empty string: draw border. This is the default value.
                * `F`: fill
                * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        op = _style_to_operator(style)

        cx = x + w / 2
        cy = y + h / 2
        rx = w / 2
        ry = h / 2

        lx = 4 / 3 * (math.sqrt(2) - 1) * rx
        ly = 4 / 3 * (math.sqrt(2) - 1) * ry

        self._out(
            (
                f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} m &#34;
                f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} &#34;
                f&#34;{(cx + lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} &#34;
                f&#34;{cx * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} c&#34;
            )
        )
        self._out(
            (
                f&#34;{(cx - lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} &#34;
                f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} &#34;
                f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c&#34;
            )
        )
        self._out(
            (
                f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} &#34;
                f&#34;{(cx - lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} &#34;
                f&#34;{cx * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} c&#34;
            )
        )
        self._out(
            (
                f&#34;{(cx + lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} &#34;
                f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} &#34;
                f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c {op}&#34;
            )
        )

    @check_page
    def circle(self, x, y, r, style=None):
        &#34;&#34;&#34;
        Outputs a circle.
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of upper-left bounging box.
            y (float): Ordinate of upper-left bounging box.
            r (float): Radius of the circle.
            style (str): Style of rendering. Possible values are:
                * `D` or None: draw border. This is the default value.
                * `F`: fill
                * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        self.ellipse(x, y, r, r, style)

    @check_page
    def regular_polygon(self, x, y, numSides, polyWidth, rotateDegrees=0, style=None):
        &#34;&#34;&#34;
        Outputs a regular polygon with n sides
        It can be rotated
        Style can also be applied (fill, border...)

        Args:
            x (float): Abscissa of upper-left bounding box.
            y (float): Ordinate of upper-left bounding box.
            numSides (int): Number of sides for polygon.
            polyWidth (float): width of the polygon.
            rotateDegrees (float): degree amount to rotate polygon. (can be left blank)
            style (str): Style of rendering. Possible values are: (can be left blank)
                * `D` or None: draw border. This is the default value.
                * `F`: fill
                * `DF` or `FD`: draw and fill

        &#34;&#34;&#34;
        radius = polyWidth / 2
        centerX = x + radius
        centerY = y - radius
        # center point is (centerX, centerY)
        points = []
        i = 1
        for i in range(1, numSides + 1):
            point = centerX + radius * math.cos(
                math.radians((360 / numSides) * i) + math.radians(rotateDegrees)
            ), centerY + radius * math.sin(
                math.radians((360 / numSides) * i) + math.radians(rotateDegrees)
            )
            points.append(point)
            i += 1
        # creates list of touples containing cordinate points of vertices

        self.polygon(points, style)
        # passes points through polygon function

    def arc(
        self,
        x,
        y,
        a,
        start_angle,
        end_angle,
        b=None,
        inclination=0,
        clockwise=False,
        start_from_center=False,
        end_at_center=False,
        style=None,
    ):
        &#34;&#34;&#34;
        Outputs an arc.
        It can be drawn (border only), filled (with no border) or both.
            a (float): Semi-major axis diameter.
            b (float): Semi-minor axis diameter, if None, equals to a (default: None).
            start_angle (float): Start angle of the arc (in degrees).
            end_angle (float): End angle of the arc (in degrees).
            inclination (float): Inclination of the arc in respect of the x-axis (default: 0).
            clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).
            start_from_center (bool): Start drawing from the center of the circle (default: False).
            end_at_center (bool): End drawing at the center of the circle (default: False).
            style (str): Style of rendering. Possible values are:
                * `D` or None: draw border. This is the default value.
                * `F`: fill
                * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        op = _style_to_operator(style)

        if b is None:
            b = a

        a /= 2
        b /= 2

        cx = x + a
        cy = y + b

        # Functions used only to construct other points of the bezier curve
        def deg_to_rad(deg):
            return deg * math.pi / 180

        def angle_to_param(angle):
            angle = deg_to_rad(angle % 360)
            eta = math.atan2(math.sin(angle) / b, math.cos(angle) / a)

            if eta &lt; 0:
                eta += 2 * math.pi
            return eta

        theta = deg_to_rad(inclination)
        cos_theta = math.cos(theta)
        sin_theta = math.sin(theta)

        def evaluate(eta):
            a_cos_eta = a * math.cos(eta)
            b_sin_eta = b * math.sin(eta)

            return [
                cx + a_cos_eta * cos_theta - b_sin_eta * sin_theta,
                cy + a_cos_eta * sin_theta + b_sin_eta * cos_theta,
            ]

        def derivative_evaluate(eta):
            a_sin_eta = a * math.sin(eta)
            b_cos_eta = b * math.cos(eta)

            return [
                -a_sin_eta * cos_theta - b_cos_eta * sin_theta,
                -a_sin_eta * sin_theta + b_cos_eta * cos_theta,
            ]

        # Calculating start_eta and end_eta so that
        #   start_eta &lt; end_eta   &lt;= start_eta + 2*PI if counterclockwise
        #   end_eta   &lt; start_eta &lt;= end_eta + 2*PI   if clockwise
        start_eta = angle_to_param(start_angle)
        end_eta = angle_to_param(end_angle)

        if not clockwise and end_eta &lt;= start_eta:
            end_eta += 2 * math.pi
        elif clockwise and end_eta &gt;= start_eta:
            start_eta += 2 * math.pi

        start_point = evaluate(start_eta)

        # Move to the start point
        if start_from_center:
            self._out(f&#34;{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} m&#34;)
            self._out(
                f&#34;{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} l&#34;
            )
        else:
            self._out(
                f&#34;{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} m&#34;
            )

        # Number of curves to use, maximal segment angle is 2*PI/max_curves
        max_curves = 4
        n = min(
            max_curves, math.ceil(abs(end_eta - start_eta) / (2 * math.pi / max_curves))
        )
        d_eta = (end_eta - start_eta) / n

        alpha = math.sin(d_eta) * (math.sqrt(4 + 3 * math.tan(d_eta / 2) ** 2) - 1) / 3

        eta2 = start_eta
        p2 = evaluate(eta2)
        p2_prime = derivative_evaluate(eta2)

        for i in range(n):
            p1 = p2
            p1_prime = p2_prime

            eta2 += d_eta
            p2 = evaluate(eta2)
            p2_prime = derivative_evaluate(eta2)

            control_point_1 = [p1[0] + alpha * p1_prime[0], p1[1] + alpha * p1_prime[1]]
            control_point_2 = [p2[0] - alpha * p2_prime[0], p2[1] - alpha * p2_prime[1]]

            end = &#34;&#34;
            if i == n - 1 and not end_at_center:
                end = f&#34; {op}&#34;

            self._out(
                (
                    f&#34;{control_point_1[0] * self.k:.2f} {(self.h - control_point_1[1]) * self.k:.2f} &#34;
                    f&#34;{control_point_2[0] * self.k:.2f} {(self.h - control_point_2[1]) * self.k:.2f} &#34;
                    f&#34;{p2[0] * self.k:.2f} {(self.h - p2[1]) * self.k:.2f} c&#34; + end
                )
            )

        if end_at_center:
            self._out(f&#34;{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} l {op}&#34;)

    @check_page
    def solid_arc(
        self,
        x,
        y,
        a,
        start_angle,
        end_angle,
        b=None,
        inclination=0,
        clockwise=False,
        style=None,
    ):
        &#34;&#34;&#34;
        Outputs a solid arc. A solid arc combines an arc and a triangle to form a pie slice
        It can be drawn (border only), filled (with no border) or both.

        Args:
            x (float): Abscissa of upper-left bounging box.
            y (float): Ordinate of upper-left bounging box.
            a (float): Semi-major axis.
            b (float): Semi-minor axis, if None, equals to a (default: None).
            start_angle (float): Start angle of the arc (in degrees).
            end_angle (float): End angle of the arc (in degrees).
            inclination (float): Inclination of the arc in respect of the x-axis (default: 0).
            clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).
            style (str): Style of rendering. Possible values are:
                * `D` or None: draw border. This is the default value.
                * `F`: fill
                * `DF` or `FD`: draw and fill
        &#34;&#34;&#34;
        self.arc(
            x,
            y,
            a,
            start_angle,
            end_angle,
            b,
            inclination,
            clockwise,
            True,
            True,
            style,
        )

    def add_font(self, family, style=&#34;&#34;, fname=None, uni=&#34;DEPRECATED&#34;):
        &#34;&#34;&#34;
        Imports a TrueType or OpenType font and makes it available
        for later calls to the `set_font()` method.

        **Warning:** there is partial support for Type1 and legacy fonts in .pkl font definition files,
        generated by the `MakeFont` utility, but this feature is getting deprecated in favour of TrueType Unicode font support
        (whose fonts are automatically processed with the included `ttfonts.py` module).

        You will find more information on the &#34;Unicode&#34; documentation page.

        Args:
            family (str): font family. Used as a reference for `set_font()`
            style (str): font style. &#34;B&#34; for bold, &#34;I&#34; for italic.
            fname (str): font file name. You can specify a relative or full path.
                If the file is not found, it will be searched in `FPDF_FONT_DIR`.
            uni (bool): [**DEPRECATED**] unused
        &#34;&#34;&#34;
        if uni != &#34;DEPRECATED&#34;:
            warnings.warn(
                &#39;&#34;uni&#34; parameter is deprecated, unused and will soon be removed&#39;,
                DeprecationWarning,
            )
        else:
            uni = str(fname).endswith(&#34;.ttf&#34;)
        if not fname:
            raise ValueError(&#39;&#34;fname&#34; parameter is required&#39;)
        style = &#34;&#34;.join(sorted(style.upper()))
        if any(letter not in &#34;BI&#34; for letter in style):
            raise ValueError(
                f&#34;Unknown style provided (only B &amp; I letters are allowed): {style}&#34;
            )
        fontkey = f&#34;{family.lower()}{style}&#34;

        # Check if font already added or one of the core fonts
        if fontkey in self.fonts or fontkey in self.core_fonts:
            warnings.warn(f&#34;Core font or font already added &#39;{fontkey}&#39;: doing nothing&#34;)
            return
        if uni:
            for parent in (&#34;.&#34;, FPDF_FONT_DIR):
                if not parent:
                    continue
                if (Path(parent) / fname).exists():
                    ttffilename = Path(parent) / fname
                    break
            else:
                raise FileNotFoundError(f&#34;TTF Font file not found: {fname}&#34;)

            # include numbers in the subset! (if alias present)
            # ensure that alias is mapped 1-by-1 additionally (must be replaceable)
            sbarr = &#34;\x00 &#34;
            if self.str_alias_nb_pages:
                sbarr += &#34;0123456789&#34;
                sbarr += self.str_alias_nb_pages

            ttf = TTFontFile()
            ttf.getMetrics(ttffilename)
            desc = {
                &#34;Ascent&#34;: round(ttf.ascent),
                &#34;Descent&#34;: round(ttf.descent),
                &#34;CapHeight&#34;: round(ttf.capHeight),
                &#34;Flags&#34;: ttf.flags,
                &#34;FontBBox&#34;: (
                    f&#34;[{ttf.bbox[0]:.0f} {ttf.bbox[1]:.0f}&#34;
                    f&#34; {ttf.bbox[2]:.0f} {ttf.bbox[3]:.0f}]&#34;
                ),
                &#34;ItalicAngle&#34;: int(ttf.italicAngle),
                &#34;StemV&#34;: round(ttf.stemV),
                &#34;MissingWidth&#34;: round(ttf.defaultWidth),
            }

            # Generate metrics .pkl file
            font_dict = {
                &#34;type&#34;: &#34;TTF&#34;,
                &#34;name&#34;: re.sub(&#34;[ ()]&#34;, &#34;&#34;, ttf.fullName),
                &#34;desc&#34;: desc,
                &#34;up&#34;: round(ttf.underlinePosition),
                &#34;ut&#34;: round(ttf.underlineThickness),
                &#34;ttffile&#34;: ttffilename,
                &#34;fontkey&#34;: fontkey,
                &#34;originalsize&#34;: os.stat(ttffilename).st_size,
                &#34;cw&#34;: ttf.charWidths,
            }

            self.fonts[fontkey] = {
                &#34;i&#34;: len(self.fonts) + 1,
                &#34;type&#34;: font_dict[&#34;type&#34;],
                &#34;name&#34;: font_dict[&#34;name&#34;],
                &#34;desc&#34;: font_dict[&#34;desc&#34;],
                &#34;up&#34;: font_dict[&#34;up&#34;],
                &#34;ut&#34;: font_dict[&#34;ut&#34;],
                &#34;cw&#34;: font_dict[&#34;cw&#34;],
                &#34;ttffile&#34;: font_dict[&#34;ttffile&#34;],
                &#34;fontkey&#34;: fontkey,
                &#34;subset&#34;: SubsetMap(map(ord, sbarr)),
            }
            self.font_files[fontkey] = {
                &#34;length1&#34;: font_dict[&#34;originalsize&#34;],
                &#34;type&#34;: &#34;TTF&#34;,
                &#34;ttffile&#34;: ttffilename,
            }
        else:
            warnings.warn(
                &#34;Support for .pkl font files definition is deprecated, and will be removed from fpdf2 soon.&#34;
                &#34; If you require this feature, please report your need on fpdf2 GitHub project.&#34;,
                DeprecationWarning,
            )
            font_dict = pickle.loads(Path(fname).read_bytes())
            font_dict[&#34;i&#34;] = len(self.fonts) + 1
            self.fonts[fontkey] = font_dict
            diff = font_dict.get(&#34;diff&#34;)
            if diff:
                # Search existing encodings
                nb = len(self.diffs)
                for i in range(1, nb + 1):
                    if self.diffs[i] == diff:
                        d = i
                        break
                else:
                    d = nb + 1
                    self.diffs[d] = diff
                self.fonts[fontkey][&#34;diff&#34;] = d
            filename = font_dict.get(&#34;filename&#34;)
            if filename:
                if font_dict[&#34;type&#34;] == &#34;TrueType&#34;:
                    originalsize = font_dict[&#34;originalsize&#34;]
                    self.font_files[filename] = {&#34;length1&#34;: originalsize}
                else:
                    self.font_files[filename] = {
                        &#34;length1&#34;: font_dict[&#34;size1&#34;],
                        &#34;length2&#34;: font_dict[&#34;size2&#34;],
                    }

    def set_font(self, family=None, style=&#34;&#34;, size=0):
        &#34;&#34;&#34;
        Sets the font used to print character strings.
        It is mandatory to call this method at least once before printing text.

        Default encoding is not specified, but all text writing methods accept only
        unicode for external fonts and one byte encoding for standard.

        Standard fonts use `Latin-1` encoding by default, but Windows
        encoding `cp1252` (Western Europe) can be used with
        `self.core_fonts_encoding = encoding`.

        The font specified is retained from page to page.
        The method can be called before the first page is created.

        Args:
            family (str): name of a font added with `FPDF.add_font`,
                or name of one of the 14 standard &#34;PostScript&#34; fonts:
                Courier (fixed-width), Helvetica (sans serif), Times (serif),
                Symbol (symbolic) or ZapfDingbats (symbolic)
                If an empty string is provided, the current family is retained.
            style (str): empty string (by default) or a combination
                of one or several letters among B (bold), I (italic) and U (underline).
                Bold and italic styles do not apply to Symbol and ZapfDingbats fonts.
            size (float): in points. The default value is the current size.
        &#34;&#34;&#34;
        if not family:
            family = self.font_family

        family = family.lower()
        style = &#34;&#34;.join(sorted(style.upper()))
        if any(letter not in &#34;BIU&#34; for letter in style):
            raise ValueError(
                f&#34;Unknown style provided (only B/I/U letters are allowed): {style}&#34;
            )
        if &#34;U&#34; in style:
            self.underline = True
            style = style.replace(&#34;U&#34;, &#34;&#34;)
        else:
            self.underline = False

        if family in self.font_aliases and family + style not in self.fonts:
            warnings.warn(
                f&#34;Substituting font {family} by core font &#34;
                f&#34;{self.font_aliases[family]}&#34;
            )
            family = self.font_aliases[family]
        elif family in (&#34;symbol&#34;, &#34;zapfdingbats&#34;) and style:
            warnings.warn(
                f&#34;Built-in font {family} only has a single &#39;style&#39; and can&#39;t be bold &#34;
                f&#34;or italic&#34;
            )
            style = &#34;&#34;

        if size == 0:
            size = self.font_size_pt

        # Test if font is already selected
        if (
            self.font_family == family
            and self.font_style == style
            and self.font_size_pt == size
        ):
            return

        # Test if used for the first time
        fontkey = family + style
        if fontkey not in self.fonts:
            if fontkey not in self.core_fonts:
                raise FPDFException(
                    f&#34;Undefined font: {fontkey} - &#34;
                    f&#34;Use built-in fonts or FPDF.add_font() beforehand&#34;
                )
            # If it&#39;s one of the core fonts, add it to self.fonts
            self.fonts[fontkey] = {
                &#34;i&#34;: len(self.fonts) + 1,
                &#34;type&#34;: &#34;core&#34;,
                &#34;name&#34;: self.core_fonts[fontkey],
                &#34;up&#34;: -100,
                &#34;ut&#34;: 50,
                &#34;cw&#34;: fpdf_charwidths[fontkey],
                &#34;fontkey&#34;: fontkey,
            }

        # Select it
        self.font_family = family
        self.font_style = style
        self.font_size_pt = size
        self.font_size = size / self.k
        self.current_font = self.fonts[fontkey]
        if self.page &gt; 0:
            self._out(f&#34;BT /F{self.current_font[&#39;i&#39;]} {self.font_size_pt:.2f} Tf ET&#34;)

    def set_font_size(self, size):
        &#34;&#34;&#34;
        Configure the font size in points

        Args:
            size (float): font size in points
        &#34;&#34;&#34;
        if self.font_size_pt == size:
            return
        self.font_size_pt = size
        self.font_size = size / self.k
        if self.page &gt; 0:
            if not self.current_font:
                raise FPDFException(
                    &#34;Cannot set font size: a font must be selected first&#34;
                )
            self._out(f&#34;BT /F{self.current_font[&#39;i&#39;]} {self.font_size_pt:.2f} Tf ET&#34;)

    def set_stretching(self, stretching):
        &#34;&#34;&#34;
        Sets horizontal font stretching.
        By default, no stretching is set (which is equivalent to a value of 100).

        Args:
            stretching (float): horizontal stretching (scaling) in percents.
        &#34;&#34;&#34;
        if self.font_stretching == stretching:
            return
        self.font_stretching = stretching
        if self.page &gt; 0:
            self._out(f&#34;BT {self.font_stretching:.2f} Tz ET&#34;)

    def add_link(self):
        &#34;&#34;&#34;
        Creates a new internal link and returns its identifier.
        An internal link is a clickable area which directs to another place within the document.

        The identifier can then be passed to the `cell()`, `write()`, `image()` or `link()` methods.
        The destination must be defined using `set_link()`.
        &#34;&#34;&#34;
        n = len(self.links) + 1
        self.links[n] = DestinationXYZ(page=1)
        return n

    def set_link(self, link, y=0, x=0, page=-1, zoom=&#34;null&#34;):
        &#34;&#34;&#34;
        Defines the page and position a link points to.

        Args:
            link (int): a link identifier returned by `add_link`.
            y (float): optional ordinate of target position.
                The default value is 0 (top of page).
            x (float): optional abscissa of target position.
                The default value is 0 (top of page).
            page (int): optional number of target page.
                -1 indicates the current page, which is the default value.
            zoom (float): optional new zoom level after following the link.
                Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.
        &#34;&#34;&#34;
        self.links[link] = DestinationXYZ(
            self.page if page == -1 else page, x=x, y=y, zoom=zoom
        )

    @check_page
    def link(self, x, y, w, h, link, alt_text=None):
        &#34;&#34;&#34;
        Puts a link annotation on a rectangular area of the page.
        Text or image links are generally put via [cell](#fpdf.FPDF.cell),
        [write](#fpdf.FPDF.write) or [image](#fpdf.FPDF.image),
        but this method can be useful for instance to define a clickable area inside an image.

        Args:
            x (float): horizontal position (from the left) to the left side of the link rectangle
            y (float): vertical position (from the top) to the bottom side of the link rectangle
            w (float): width of the link rectangle
            h (float): width of the link rectangle
            link: either an URL or a integer returned by `add_link`, defining an internal link to a page
            alt_text (str): optional textual description of the link, for accessibility purposes
        &#34;&#34;&#34;
        self.annots[self.page].append(
            Annotation(
                &#34;Link&#34;,
                x * self.k,
                self.h_pt - y * self.k,
                w * self.k,
                h * self.k,
                link=link,
                alt_text=alt_text,
            )
        )

    @check_page
    def text_annotation(self, x, y, text):
        &#34;&#34;&#34;
        Puts a text annotation on a rectangular area of the page.

        Args:
            x (float): horizontal position (from the left) to the left side of the link rectangle
            y (float): vertical position (from the top) to the bottom side of the link rectangle
            w (float): width of the link rectangle
            h (float): width of the link rectangle
            text (str): text to display
        &#34;&#34;&#34;
        self.annots[self.page].append(
            Annotation(
                &#34;Text&#34;,
                x * self.k,
                self.h_pt - y * self.k,
                self.k,
                self.k,
                contents=text,
            )
        )

    @check_page
    def add_action(self, action, x, y, w, h):
        &#34;&#34;&#34;
        Puts an Action annotation on a rectangular area of the page.

        Args:
            action (fpdf.actions.Action): the action to add
            x (float): horizontal position (from the left) to the left side of the link rectangle
            y (float): vertical position (from the top) to the bottom side of the link rectangle
            w (float): width of the link rectangle
            h (float): width of the link rectangle
        &#34;&#34;&#34;
        self.annots[self.page].append(
            Annotation(
                &#34;Action&#34;,
                x * self.k,
                self.h_pt - y * self.k,
                w * self.k,
                h * self.k,
                action=action,
            )
        )

    @check_page
    def text(self, x, y, txt=&#34;&#34;):
        &#34;&#34;&#34;
        Prints a character string. The origin is on the left of the first character,
        on the baseline. This method allows placing a string precisely on the page,
        but it is usually easier to use the `cell()`, `multi_cell() or `write()` methods.

        Args:
            x (float): abscissa of the origin
            y (float): ordinate of the origin
            txt (str): string to print
        &#34;&#34;&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        txt = self.normalize_text(txt)
        if self.unifontsubset:
            txt_mapped = &#34;&#34;
            for char in txt:
                uni = ord(char)
                # Instead of adding the actual character to the stream its code is
                # mapped to a position in the font&#39;s subset
                txt_mapped += chr(self.current_font[&#34;subset&#34;].pick(uni))
            txt2 = escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))
        else:
            txt2 = escape_parens(txt)
        s = f&#34;BT {x * self.k:.2f} {(self.h - y) * self.k:.2f} Td ({txt2}) Tj ET&#34;
        if self.underline and txt != &#34;&#34;:
            s += &#34; &#34; + self._do_underline(x, y, txt)
        if self.fill_color != self.text_color:
            s = f&#34;q {self.text_color} {s} Q&#34;
        self._out(s)

    @check_page
    def rotate(self, angle, x=None, y=None):
        &#34;&#34;&#34;
        .. deprecated:: 2.1.0
          Use `rotation` instead.
        &#34;&#34;&#34;
        warnings.warn(
            &#34;rotate() can produces malformed PDFs and is deprecated. &#34;
            &#34;Use the rotation() context manager instead.&#34;,
            DeprecationWarning,
        )
        if x is None:
            x = self.x
        if y is None:
            y = self.y

        if self.angle != 0:
            self._out(&#34;Q&#34;)
        self.angle = angle
        if angle != 0:
            angle *= math.pi / 180
            c = math.cos(angle)
            s = math.sin(angle)
            cx = x * self.k
            cy = (self.h - y) * self.k
            s = (
                f&#34;q {c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm &#34;
                f&#34;1 0 0 1 {-cx:.2F} {-cy:.2F} cm&#34;
            )
            self._out(s)

    @check_page
    @contextmanager
    def rotation(self, angle, x=None, y=None):
        &#34;&#34;&#34;
        This method allows to perform a rotation around a given center.
        It must be used as a context-manager using `with`:

            with rotation(angle=90, x=x, y=y):
                pdf.something()

        The rotation affects all elements which are printed inside the indented
        context (with the exception of clickable areas).

        Args:
            angle (float): angle in degrees
            x (float): abscissa of the center of the rotation
            y (float): ordinate of the center of the rotation

        Notes
        -----

        Only the rendering is altered. The `get_x()` and `get_y()` methods are
        not affected, nor the automatic page break mechanism.
        The rotation also establishes a local graphics state, so that any
        graphics state settings changed within will not affect the operations
        invoked after it has finished.
        &#34;&#34;&#34;
        if x is None:
            x = self.x
        if y is None:
            y = self.y
        angle *= math.pi / 180
        c, s = math.cos(angle), math.sin(angle)
        cx, cy = x * self.k, (self.h - y) * self.k
        with self.local_context():
            self._out(
                f&#34;{c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm &#34;
                f&#34;1 0 0 1 {-cx:.2F} {-cy:.2F} cm\n&#34;
            )
            yield

    @check_page
    @contextmanager
    def local_context(self):
        &#34;&#34;&#34;
        Create a local grapics state, which won&#39;t affect the surrounding code.
        This method must be used as a context manager using `with`:

            with pdf.local_context():
                set_some_state()
                draw_some_stuff()

        The affected settings are:
            draw_color
            fill_color
            text_color
            underline
            font_style
            font_stretching
            font_family
            font_size_pt
            font_size
            dash_pattern
            line_width
        &#34;&#34;&#34;
        self._push_local_stack()
        self._out(&#34;\nq &#34;)
        yield
        self._out(&#34; Q\n&#34;)
        self._pop_local_stack()

    @property
    def accept_page_break(self):
        &#34;&#34;&#34;
        Whenever a page break condition is met, this method is called,
        and the break is issued or not depending on the returned value.

        The default implementation returns a value according to the mode selected by `set_auto_page_break()`.
        This method is called automatically and should not be called directly by the application.
        &#34;&#34;&#34;
        return self.auto_page_break

    @check_page
    def cell(
        self,
        w=None,
        h=None,
        txt=&#34;&#34;,
        border=0,
        ln=0,
        align=&#34;&#34;,
        fill=False,
        link=&#34;&#34;,
        center=False,
        markdown=False,
    ):
        &#34;&#34;&#34;
        Prints a cell (rectangular area) with optional borders, background color and
        character string. The upper-left corner of the cell corresponds to the current
        position. The text can be aligned or centered. After the call, the current
        position moves to the right or to the next line. It is possible to put a link
        on the text.

        If automatic page breaking is enabled and the cell goes beyond the limit, a
        page break is performed before outputting.

        Args:
            w (float): Cell width. Default value: None, meaning to fit text width.
                If 0, the cell extends up to the right margin.
            h (float): Cell height. Default value: None, meaning an height equal
                to the current font size.
            txt (str): String to print. Default value: empty string.
            border: Indicates if borders must be drawn around the cell.
                The value can be either a number (`0`: no border ; `1`: frame)
                or a string containing some or all of the following characters
                (in any order):
                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
            ln (int): Indicates where the current position should go after the call.
                Possible values are: `0`: to the right ; `1`: to the beginning of the
                next line ; `2`: below. Putting 1 is equivalent to putting 0 and calling
                `ln` just after. Default value: 0.
            align (str): Allows to center or align the text inside the cell.
                Possible values are: `L` or empty string: left align (default value) ;
                `C`: center ; `R`: right align
            fill (bool): Indicates if the cell background must be painted (`True`)
                or transparent (`False`). Default value: False.
            link (str): optional link to add on the cell, internal
                (identifier returned by `add_link`) or external URL.
            center (bool): center the cell horizontally in the page
            markdown (bool): enable minimal markdown-like markup to render part
                of text as bold / italics / underlined. Default to False.

        Returns: a boolean indicating if page break was triggered
        &#34;&#34;&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        if isinstance(w, str) or isinstance(h, str):
            raise ValueError(
                &#34;Parameter &#39;w&#39; and &#39;h&#39; must be numbers, not strings.&#34;
                &#34; You can omit them by passing string content with txt=&#34;
            )
        if isinstance(border, int) and border not in (0, 1):
            warnings.warn(
                &#39;Integer values for &#34;border&#34; parameter other than 1 are currently &#39;
                &#34;ignored&#34;
            )
            border = 1
        new_x = XPos.RIGHT
        new_y = YPos.TOP
        if ln == 1:
            new_x = XPos.LMARGIN
            new_y = YPos.NEXT
        elif ln == 2:
            new_x = XPos.LEFT
            new_y = YPos.NEXT
        # Font styles preloading must be performed before any call to FPDF.get_string_width:
        txt = self.normalize_text(txt)
        styled_txt_frags = self._preload_font_styles(txt, markdown)
        return self._render_styled_cell_text(
            TextLine(
                styled_txt_frags,
                text_width=0.0,
                number_of_spaces_between_words=0,
                justify=False,
            ),
            w,
            h,
            border,
            new_x=new_x,
            new_y=new_y,
            align=align,
            fill=fill,
            link=link,
            center=center,
        )

    def _render_styled_cell_text(
        self,
        text_line: TextLine,
        w: float = None,
        h: float = None,
        border: Union[str, int] = 0,
        new_x: XPos = XPos.RIGHT,
        new_y: YPos = YPos.TOP,
        align: str = &#34;&#34;,
        fill: bool = False,
        link: str = &#34;&#34;,
        center: bool = False,
    ):
        &#34;&#34;&#34;
        Prints a cell (rectangular area) with optional borders, background color and
        character string. The upper-left corner of the cell corresponds to the current
        position. The text can be aligned, centered or justified. After the call, the
        current position moves to the requested new position. It is possible to put a
        link on the text.

        If automatic page breaking is enabled and the cell goes beyond the limit, a
        page break is performed before outputting.

        Args:
            text_line (TextLine instance): Contains the (possibly empty) tuple of
                fragments to render.
            w (float): Cell width. Default value: None, meaning to fit text width.
                If 0, the cell extends up to the right margin.
            h (float): Cell height. Default value: None, meaning an height equal
                to the current font size.
            border: Indicates if borders must be drawn around the cell.
                The value can be either a number (`0`: no border ; `1`: frame)
                or a string containing some or all of the following characters
                (in any order):
                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
            new_x (Enum XPos): New current position in x after the call.
            new_y (Enum YPos): New current position in y after the call.
            align (str): Allows to align the text inside the cell.
                Possible values are: `L` or empty string: left align (default value);
                `C`: center; `R`: right align; `J`: justify (if more than one word)
            fill (bool): Indicates if the cell background must be painted (`True`)
                or transparent (`False`). Default value: False.
            link (str): optional link to add on the cell, internal
                (identifier returned by `add_link`) or external URL.
            center (bool): center the cell horizontally in the page
            markdown (bool): enable minimal markdown-like markup to render part
                of text as bold / italics / underlined. Default to False.

        Returns: a boolean indicating if page break was triggered
        &#34;&#34;&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        if isinstance(border, int) and border not in (0, 1):
            warnings.warn(
                &#39;Integer values for &#34;border&#34; parameter other than 1 are currently &#39;
                &#34;ignored&#34;
            )
            border = 1
        styled_txt_width = text_line.text_width / 1000 * self.font_size
        if not styled_txt_width:
            for styled_txt_frag in text_line.fragments:
                styled_txt_width += self.get_string_width(styled_txt_frag.string)
        if w == 0:
            w = self.w - self.r_margin - self.x
        elif w is None:
            if not text_line.fragments:
                raise ValueError(
                    &#34;A &#39;text_line&#39; parameter with fragments must be provided if &#39;w&#39; is None&#34;
                )
            w = styled_txt_width + self.c_margin + self.c_margin
        if h is None:
            h = self.font_size
        # pylint: disable=invalid-unary-operand-type
        if center:
            self.x = self.l_margin + (self.epw - w) / 2
        page_break_triggered = self._perform_page_break_if_need_be(h)
        s = &#34;&#34;
        k = self.k
        if fill:
            op = &#34;B&#34; if border == 1 else &#34;f&#34;
            s = (
                f&#34;{self.x * k:.2f} {(self.h - self.y) * k:.2f} &#34;
                f&#34;{w * k:.2f} {-h * k:.2f} re {op} &#34;
            )
        elif border == 1:
            s = (
                f&#34;{self.x * k:.2f} {(self.h - self.y) * k:.2f} &#34;
                f&#34;{w * k:.2f} {-h * k:.2f} re S &#34;
            )

        if isinstance(border, str):
            x = self.x
            y = self.y
            if &#34;L&#34; in border:
                s += (
                    f&#34;{x * k:.2f} {(self.h - y) * k:.2f} m &#34;
                    f&#34;{x * k:.2f} {(self.h - (y + h)) * k:.2f} l S &#34;
                )
            if &#34;T&#34; in border:
                s += (
                    f&#34;{x * k:.2f} {(self.h - y) * k:.2f} m &#34;
                    f&#34;{(x + w) * k:.2f} {(self.h - y) * k:.2f} l S &#34;
                )
            if &#34;R&#34; in border:
                s += (
                    f&#34;{(x + w) * k:.2f} {(self.h - y) * k:.2f} m &#34;
                    f&#34;{(x + w) * k:.2f} {(self.h - (y + h)) * k:.2f} l S &#34;
                )
            if &#34;B&#34; in border:
                s += (
                    f&#34;{x * k:.2f} {(self.h - (y + h)) * k:.2f} m &#34;
                    f&#34;{(x + w) * k:.2f} {(self.h - (y + h)) * k:.2f} l S &#34;
                )

        s_start = self.x
        s_width, underlines = 0, []
        if text_line.fragments:
            if align == &#34;R&#34;:
                dx = w - self.c_margin - styled_txt_width
            elif align == &#34;C&#34;:
                dx = (w - styled_txt_width) / 2
            else:
                dx = self.c_margin
            s_start += dx

            if self.fill_color != self.text_color:
                s += f&#34;q {self.text_color} &#34;

            prev_font_style, prev_underline = self.font_style, self.underline
            s += (
                f&#34;BT {(self.x + dx) * k:.2f} &#34;
                f&#34;{(self.h - self.y - 0.5 * h - 0.3 * self.font_size) * k:.2f} Td&#34;
            )

            word_spacing = (
                0  # precursor to self.ws, or manual spacing of unicode fonts.
            )
            if align == &#34;J&#34; and text_line.number_of_spaces_between_words:
                word_spacing = (
                    w - self.c_margin - self.c_margin - styled_txt_width
                ) / text_line.number_of_spaces_between_words
            if word_spacing and self.unifontsubset:
                # If multibyte, Tw has no effect - do word spacing using an
                # adjustment before each space
                space = escape_parens(&#34; &#34;.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))
                if self.ws &gt; 0:
                    s += &#34; 0 Tw&#34;
                    self.ws = 0
                for frag in text_line.fragments:
                    txt_frag = frag.string
                    style = frag.style
                    underline = frag.underline
                    if self.font_style != style:
                        self.font_style = style
                        self.current_font = self.fonts[
                            self.font_family + self.font_style
                        ]
                        s += f&#34; /F{self.current_font[&#39;i&#39;]} {self.font_size_pt:.2f} Tf&#34;
                    txt_frag_mapped = &#34;&#34;
                    for char in txt_frag:
                        uni = ord(char)
                        txt_frag_mapped += chr(self.current_font[&#34;subset&#34;].pick(uni))

                    # Determine the position of space (&#34; &#34;) in the current subset and
                    # split words whenever this mapping code is found
                    words = txt_frag_mapped.split(
                        chr(self.current_font[&#34;subset&#34;].pick(ord(&#34; &#34;)))
                    )

                    s += &#34; [&#34;
                    for i, word in enumerate(words):
                        word = escape_parens(word.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))
                        s += f&#34;({word}) &#34;
                        is_last_word = (i + 1) == len(words)
                        if not is_last_word:
                            adj = -(word_spacing * self.k) * 1000 / self.font_size_pt
                            s += f&#34;{adj:.3f}({space}) &#34;
                    if underline:
                        underlines.append((self.x + dx + s_width, txt_frag))
                    self.underline = underline
                    s_width += self.get_string_width(
                        txt_frag, True
                    ) + word_spacing * txt_frag.count(&#34; &#34;)
                    s += &#34;] TJ&#34;
            else:
                if word_spacing and word_spacing != self.ws:
                    self._out(f&#34;{word_spacing * self.k:.3f} Tw&#34;)
                elif self.ws &gt; 0:
                    self._out(&#34;0 Tw&#34;)
                self.ws = word_spacing

                for frag in text_line.fragments:
                    txt_frag = frag.string
                    style = frag.style
                    underline = frag.underline
                    if self.font_style != style:
                        self.font_style = style
                        self.current_font = self.fonts[
                            self.font_family + self.font_style
                        ]
                        s += f&#34; /F{self.current_font[&#39;i&#39;]} {self.font_size_pt:.2f} Tf&#34;
                    if self.unifontsubset:
                        txt_frag_mapped = &#34;&#34;
                        for char in txt_frag:
                            uni = ord(char)
                            txt_frag_mapped += chr(
                                self.current_font[&#34;subset&#34;].pick(uni)
                            )

                        txt_frag_escaped = escape_parens(
                            txt_frag_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;)
                        )
                    else:
                        txt_frag_escaped = escape_parens(txt_frag)
                    s += f&#34; ({txt_frag_escaped}) Tj&#34;
                    if underline:
                        underlines.append((self.x + dx + s_width, txt_frag))
                    self.underline = underline
                    s_width += self.get_string_width(
                        txt_frag, True
                    ) + self.ws * txt_frag.count(&#34; &#34;)
            s += &#34; ET&#34;
            # Restoring font style &amp; underline mode after handling changes
            # by Markdown annotations:
            if not self._markdown_leak_end_style:
                if self.font_style != prev_font_style:
                    self.font_style = prev_font_style
                    self.current_font = self.fonts[self.font_family + self.font_style]
                    s += f&#34; /F{self.current_font[&#39;i&#39;]} {self.font_size_pt:.2f} Tf&#34;
                self.underline = prev_underline

            for start_x, txt_frag in underlines:
                s += &#34; &#34; + self._do_underline(
                    start_x, self.y + (0.5 * h) + (0.3 * self.font_size), txt_frag
                )

            if self.fill_color != self.text_color:
                s += &#34; Q&#34;

            if link:
                self.link(
                    self.x + dx,
                    self.y + (0.5 * h) - (0.5 * self.font_size),
                    styled_txt_width,
                    self.font_size,
                    link,
                )
        if s:
            self._out(s)
        self.lasth = h

        # XPos.LEFT -&gt; self.x stays the same
        if new_x == XPos.RIGHT:
            self.x += w
        elif new_x == XPos.START:
            self.x = s_start
        elif new_x == XPos.END:
            self.x = s_start + s_width
        elif new_x == XPos.WCONT:
            self.x = s_start + s_width - self.c_margin
        elif new_x == XPos.CENTER:
            self.x = (s_start + s_start + s_width) / 2.0
        elif new_x == XPos.LMARGIN:
            self.x = self.l_margin
        elif new_x == XPos.RMARGIN:
            self.x = self.w - self.r_margin

        # YPos.TOP:  -&gt; self.y stays the same
        # YPos.LAST: -&gt; self.y stays the same (single line)
        if new_y == YPos.NEXT:
            self.y += h
        if new_y == YPos.TMARGIN:
            self.y = self.t_margin
        if new_y == YPos.BMARGIN:
            self.y = self.h - self.b_margin

        return page_break_triggered

    def _preload_font_styles(self, txt, markdown):
        &#34;&#34;&#34;
        When Markdown styling is enabled, we require secondary fonts
        to ender text in bold &amp; italics.
        This function ensure that those fonts are available.
        It needs to perform Markdown parsing,
        so we return the resulting `styled_txt_frags` tuple
        to avoid repeating this processing later on.
        &#34;&#34;&#34;
        if not txt:
            return tuple()
        if not markdown:
            return tuple(
                [Fragment.from_string(txt, self.font_style, bool(self.underline))]
            )
        prev_font_style = self.font_style
        styled_txt_frags = tuple(self._markdown_parse(txt))
        page = self.page
        # We set the current to page to zero so that
        # set_font() does not produce any text object on the stream buffer:
        self.page = 0
        if any(&#34;B&#34; in frag.style for frag in styled_txt_frags):
            # Ensuring bold font is supported:
            self.set_font(style=&#34;B&#34;)
        if any(&#34;I&#34; in frag.style for frag in styled_txt_frags):
            # Ensuring italics font is supported:
            self.set_font(style=&#34;I&#34;)
        # Restoring initial style:
        self.set_font(style=prev_font_style)
        self.page = page
        return styled_txt_frags

    def _markdown_parse(self, txt):
        &#34;Split some text into fragments based on styling: **bold**, __italics__, --underlined--&#34;
        txt_frag, in_bold, in_italics, in_underline = (
            [],
            &#34;B&#34; in self.font_style,
            &#34;I&#34; in self.font_style,
            bool(self.underline),
        )
        while txt:
            is_marker = txt[:2] in (
                self.MARKDOWN_BOLD_MARKER,
                self.MARKDOWN_ITALICS_MARKER,
                self.MARKDOWN_UNDERLINE_MARKER,
            )
            half_marker = txt[0]
            # Check that previous &amp; next characters are not identical to the marker:
            if (
                is_marker
                and (not txt_frag or txt_frag[0] != half_marker)
                and (len(txt) &lt; 3 or txt[2] != half_marker)
            ):
                if txt_frag:
                    yield Fragment(
                        (&#34;B&#34; if in_bold else &#34;&#34;) + (&#34;I&#34; if in_italics else &#34;&#34;),
                        in_underline,
                        txt_frag,
                    )
                if txt[:2] == self.MARKDOWN_BOLD_MARKER:
                    in_bold = not in_bold
                if txt[:2] == self.MARKDOWN_ITALICS_MARKER:
                    in_italics = not in_italics
                if txt[:2] == self.MARKDOWN_UNDERLINE_MARKER:
                    in_underline = not in_underline
                txt_frag = []
                txt = txt[2:]
            else:
                txt_frag.append(txt[0])
                txt = txt[1:]
        if txt_frag:
            yield Fragment(
                (&#34;B&#34; if in_bold else &#34;&#34;) + (&#34;I&#34; if in_italics else &#34;&#34;),
                in_underline,
                txt_frag,
            )

    def will_page_break(self, height):
        &#34;&#34;&#34;
        Let you know if adding an element will trigger a page break,
        based on its height and the current ordinate (`y` position).

        Args:
            height (float): height of the section that would be added, e.g. a cell

        Returns: a boolean indicating if a page break would occur
        &#34;&#34;&#34;
        return (
            self.y + height &gt; self.page_break_trigger
            and not self.in_footer
            and self.accept_page_break
        )

    def _perform_page_break_if_need_be(self, h):
        if self.will_page_break(h):
            LOGGER.debug(
                &#34;Page break on page %d at y=%d for element of height %d &gt; %d&#34;,
                self.page,
                self.y,
                h,
                self.page_break_trigger,
            )
            self._perform_page_break()
            return True
        return False

    def _perform_page_break(self):
        x, ws = self.x, self.ws
        # Reset word spacing
        # We want each page to start with the default value, so that splitting
        # the document between pages later doesn&#39;t cause any trouble.
        if ws &gt; 0:
            self.ws = 0
            self._out(&#34;0 Tw&#34;)
        self.add_page(same=True)
        self.x = x  # restore x but not y after drawing header

    def _has_next_page(self):
        return self.pages_count &gt; self.page

    @check_page
    def multi_cell(
        self,
        w,
        h=None,
        txt=&#34;&#34;,
        border=0,
        align=&#34;J&#34;,
        fill=False,
        split_only=False,
        link=&#34;&#34;,
        ln=0,
        max_line_height=None,
        markdown=False,
        print_sh=False,
    ):
        &#34;&#34;&#34;
        This method allows printing text with line breaks. They can be automatic
        (breaking at the most recent space or soft-hyphen character) as soon as the text
        reaches the right border of the cell, or explicit (via the `\\n` character).
        As many cells as necessary are stacked, one below the other.
        Text can be aligned, centered or justified. The cell block can be framed and
        the background painted.

        Args:
            w (float): cell width. If 0, they extend up to the right margin of the page.
            h (float): cell height. Default value: None, meaning to use the current font size.
            txt (str): strign to print.
            border: Indicates if borders must be drawn around the cell.
                The value can be either a number (`0`: no border ; `1`: frame)
                or a string containing some or all of the following characters
                (in any order):
                `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
            align (str): Allows to center or align the text. Possible values are:
                `J`: justify (default value); `L` or empty string: left align ;
                `C`: center ; `R`: right align
            fill (bool): Indicates if the cell background must be painted (`True`)
                or transparent (`False`). Default value: False.
            split_only (bool): if `True`, does not output anything, only perform
                word-wrapping and return the resulting multi-lines array of strings.
            link (str): optional link to add on the cell, internal
                (identifier returned by `add_link`) or external URL.
            ln (int): Indicates where the current position should go after the call.
                Possible values are: `0`: to the bottom right ; `1`: to the beginning
                of the next line ; `2`: below with the same horizontal offset ;
                `3`: to the right with the same vertical offset. Default value: 0.
            max_line_height (float): optional maximum height of each sub-cell generated
            markdown (bool): enable minimal markdown-like markup to render part
                of text as bold / italics / underlined. Default to False.
            print_sh (bool): Treat a soft-hyphen (\\u00ad) as a normal printable
                character, instead of a line breaking opportunity. Default value: False

        Using `ln=3` and `maximum height=pdf.font_size` is useful to build tables
        with multiline text in cells.

        Returns: a boolean indicating if page break was triggered,
            or if `split_only == True`: `txt` splitted into lines in an array
        &#34;&#34;&#34;
        if isinstance(w, str) or isinstance(h, str):
            raise ValueError(
                &#34;Parameter &#39;w&#39; and &#39;h&#39; must be numbers, not strings.&#34;
                &#34; You can omit them by passing string content with txt=&#34;
            )
        new_x = XPos.RIGHT
        new_y = YPos.NEXT
        if ln == 1:
            new_x = XPos.LMARGIN
        elif ln == 2:
            new_x = XPos.LEFT
        elif ln == 3:
            new_y = YPos.TOP

        page_break_triggered = False
        if split_only:
            _out, _add_page, _perform_page_break_if_need_be = (
                self._out,
                self.add_page,
                self._perform_page_break_if_need_be,
            )
            self._out = lambda *args, **kwargs: None
            self.add_page = lambda *args, **kwargs: None
            self._perform_page_break_if_need_be = lambda *args, **kwargs: None

        # If width is 0, set width to available width between margins
        if w == 0:
            w = self.w - self.r_margin - self.x
        if h is None:
            h = self.font_size
        maximum_allowed_emwidth = (w - 2 * self.c_margin) * 1000 / self.font_size

        # Calculate text length
        txt = self.normalize_text(txt)
        normalized_string = txt.replace(&#34;\r&#34;, &#34;&#34;)
        styled_text_fragments = self._preload_font_styles(normalized_string, markdown)

        prev_font_style, prev_underline = self.font_style, self.underline
        if markdown and not split_only:
            self._markdown_leak_end_style = True
        prev_x, prev_y = self.x, self.y

        if not border:
            border = &#34;&#34;
        elif border == 1:
            border = &#34;LTRB&#34;

        text_lines = []
        multi_line_break = MultiLineBreak(
            styled_text_fragments,
            self.get_normalized_string_width_with_style,
            justify=(align == &#34;J&#34;),
            print_sh=print_sh,
        )
        text_line = multi_line_break.get_line_of_given_width(maximum_allowed_emwidth)
        while (text_line) is not None:
            text_lines.append(text_line)
            text_line = multi_line_break.get_line_of_given_width(
                maximum_allowed_emwidth
            )

        for text_line_index, text_line in enumerate(text_lines):
            is_last_line = text_line_index == len(text_lines) - 1

            if max_line_height is not None and h &gt; max_line_height and not is_last_line:
                current_cell_height = max_line_height
                h -= current_cell_height
            else:
                current_cell_height = h

            new_page = self._render_styled_cell_text(
                text_line,
                w,
                h=current_cell_height,
                border=&#34;&#34;.join(
                    (
                        &#34;T&#34; if &#34;T&#34; in border and text_line_index == 0 else &#34;&#34;,
                        &#34;L&#34; if &#34;L&#34; in border else &#34;&#34;,
                        &#34;R&#34; if &#34;R&#34; in border else &#34;&#34;,
                        &#34;B&#34; if &#34;B&#34; in border and is_last_line else &#34;&#34;,
                    )
                ),
                new_x=new_x if is_last_line else XPos.LEFT,
                new_y=new_y if is_last_line else YPos.NEXT,
                align=&#34;L&#34; if (align == &#34;J&#34; and is_last_line) else align,
                fill=fill,
                link=link,
            )
            if is_last_line and new_page and new_y == YPos.TOP:
                # When a page jump is performed and the requested y is TOP (ln=3),
                # pretend we started at the top of the text block on the new page.
                # cf. test_multi_cell_table_with_automatic_page_break
                prev_y = self.y
            page_break_triggered = page_break_triggered or new_page

        if new_y == YPos.TOP:  # We may have jumped a few lines -&gt; reset
            self.y = prev_y

        if split_only:
            # restore writing functions
            self._out, self.add_page, self._perform_page_break_if_need_be = (
                _out,
                _add_page,
                _perform_page_break_if_need_be,
            )
            self.set_xy(prev_x, prev_y)  # restore location
            result = []
            for text_line in text_lines:
                characters = []
                for frag in text_line.fragments:
                    characters.extend(frag.characters)
                result.append(&#34;&#34;.join(characters))
            return result
        if markdown:
            if self.font_style != prev_font_style:
                self.font_style = prev_font_style
                self.current_font = self.fonts[self.font_family + self.font_style]
            self.underline = prev_underline
            self._markdown_leak_end_style = False

        return page_break_triggered

    @check_page
    def write(
        self, h: float = None, txt: str = &#34;&#34;, link: str = &#34;&#34;, print_sh: bool = False
    ):
        &#34;&#34;&#34;
        Prints text from the current position.
        When the right margin is reached, a line break occurs at the most recent
        space or soft-hyphen character, and text continues from the left margin.
        A manual break happens any time the \\n character is met,
        Upon method exit, the current position is left just at the end of the text.

        Args:
            h (float): line height. Default value: None, meaning to use the current font size.
            txt (str): text content
            link (str): optional link to add on the text, internal
                (identifier returned by `add_link`) or external URL.
            print_sh (bool): Treat a soft-hyphen (\\u00ad) as a normal printable
                character, instead of a line breaking opportunity. Default value: False
        &#34;&#34;&#34;
        if not self.font_family:
            raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
        if isinstance(h, str):
            raise ValueError(
                &#34;Parameter &#39;h&#39; must be a number, not a string.&#34;
                &#34; You can omit it by passing string content with txt=&#34;
            )
        if h is None:
            h = self.font_size

        page_break_triggered = False
        normalized_string = self.normalize_text(txt).replace(&#34;\r&#34;, &#34;&#34;)
        styled_text_fragments = self._preload_font_styles(normalized_string, False)

        text_lines = []
        multi_line_break = MultiLineBreak(
            styled_text_fragments,
            self.get_normalized_string_width_with_style,
            print_sh=print_sh,
        )
        prev_x = self.x
        # first line from current x position to right margin
        first_width = self.w - prev_x - self.r_margin
        first_emwidth = (first_width - 2 * self.c_margin) * 1000 / self.font_size
        text_line = multi_line_break.get_line_of_given_width(
            first_emwidth, wordsplit=False
        )
        # remaining lines fill between margins
        full_width = self.w - self.l_margin - self.r_margin
        full_emwidth = (full_width - 2 * self.c_margin) * 1000 / self.font_size
        while (text_line) is not None:
            text_lines.append(text_line)
            text_line = multi_line_break.get_line_of_given_width(full_emwidth)
        if text_line:
            text_lines.append(text_line)
        if not text_lines:
            return False

        self.ws = 0  # currently only left aligned, so no word spacing
        for text_line_index, text_line in enumerate(text_lines):
            if text_line_index == 0:
                line_width = first_width
            else:
                line_width = full_width
                self.ln()
            new_page = self._render_styled_cell_text(
                text_line,
                line_width,
                h=h,
                border=0,
                new_x=XPos.WCONT,
                new_y=YPos.TOP,
                align=&#34;L&#34;,
                fill=False,
                link=link,
            )
            page_break_triggered = page_break_triggered or new_page

        return page_break_triggered

    @check_page
    def image(
        self,
        name,
        x=None,
        y=None,
        w=0,
        h=0,
        type=&#34;&#34;,
        link=&#34;&#34;,
        title=None,
        alt_text=None,
    ):
        &#34;&#34;&#34;
        Put an image on the page.

        The size of the image on the page can be specified in different ways:
        * explicit width and height (expressed in user units)
        * one explicit dimension, the other being calculated automatically
          in order to keep the original proportions
        * no explicit dimension, in which case the image is put at 72 dpi.

        **Remarks**:
        * if an image is used several times, only one copy is embedded in the file.
        * when using an animated GIF, only the first frame is used.

        Args:
            name: either a string representing a file path to an image, an URL to an image,
                an io.BytesIO, or a instance of `PIL.Image.Image`
            x (float): optional horizontal position where to put the image on the page.
                If not specified or equal to None, the current abscissa is used.
            y (float): optional vertical position where to put the image on the page.
                If not specified or equal to None, the current ordinate is used.
                After the call, the current ordinate is moved to the bottom of the image
            w (float): optional width of the image. If not specified or equal to zero,
                it is automatically calculated from the image size.
                Pass `pdf.epw` to scale horizontally to the full page width.
            h (float): optional height of the image. If not specified or equal to zero,
                it is automatically calculated from the image size.
                Pass `pdf.eph` to scale horizontally to the full page height.
            type (str): [**DEPRECATED**] unused, will be removed in a later version.
            link (str): optional link to add on the image, internal
                (identifier returned by `add_link`) or external URL.
            title (str): optional. Currently, never seem rendered by PDF readers.
            alt_text (str): optional alternative text describing the image,
                for accessibility purposes. Displayed by some PDF readers on hover.
        &#34;&#34;&#34;
        if type:
            warnings.warn(
                &#39;&#34;type&#34; parameter is deprecated, unused and will soon be removed&#39;,
                DeprecationWarning,
            )
        if str(name).endswith(&#34;.svg&#34;):
            # Insert it as a PDF path:
            img = load_image(str(name))
            return self._vector_image(img, x, y, w, h, link, title, alt_text)
        if isinstance(name, str):
            img = None
        elif isinstance(name, Image.Image):
            bytes = name.tobytes()
            # disabling bandit rule as we just build a cache key, this is secure
            name, img = hashlib.md5(bytes).hexdigest(), name  # nosec B303 B324
        elif isinstance(name, io.BytesIO):
            if _is_xml(name):
                return self._vector_image(name, x, y, w, h, link, title, alt_text)
            bytes = name.getvalue()
            # disabling bandit rule as we just build a cache key, this is secure
            name, img = hashlib.md5(bytes).hexdigest(), name  # nosec B303 B324
        else:
            name, img = str(name), name
        info = self.images.get(name)
        if info:
            info[&#34;usages&#34;] += 1
        else:
            if not img:
                img = load_image(name)
            info = get_img_info(img, self.image_filter)
            info[&#34;i&#34;] = len(self.images) + 1
            info[&#34;usages&#34;] = 1
            self.images[name] = info

        # Automatic width and height calculation if needed
        if w == 0 and h == 0:  # Put image at 72 dpi
            w = info[&#34;w&#34;] / self.k
            h = info[&#34;h&#34;] / self.k
        elif w == 0:
            w = h * info[&#34;w&#34;] / info[&#34;h&#34;]
        elif h == 0:
            h = w * info[&#34;h&#34;] / info[&#34;w&#34;]

        if self.oversized_images and info[&#34;usages&#34;] == 1:
            info = self._downscale_image(name, img, info, w, h)

        # Flowing mode
        if y is None:
            self._perform_page_break_if_need_be(h)
            y = self.y
            self.y += h
        if x is None:
            x = self.x

        stream_content = (
            f&#34;q {w * self.k:.2f} 0 0 {h * self.k:.2f} {x * self.k:.2f} &#34;
            f&#34;{(self.h - y - h) * self.k:.2f} cm /I{info[&#39;i&#39;]} Do Q&#34;
        )
        if title or alt_text:
            with self._marked_sequence(title=title, alt_text=alt_text):
                self._out(stream_content)
        else:
            self._out(stream_content)
        if link:
            self.link(x, y, w, h, link)

        return info

    def _vector_image(
        self,
        img: io.BytesIO,
        x=None,
        y=None,
        w=0,
        h=0,
        link=&#34;&#34;,
        title=None,
        alt_text=None,
    ):
        svg = SVGObject(img.getvalue())
        if w == 0 and h == 0:
            if not svg.width or not svg.height:
                raise ValueError(
                    &#39;&lt;svg&gt; has no &#34;height&#34; / &#34;width&#34;: w= or h= must be provided to FPDF.image()&#39;
                )
            w = (
                svg.width * self.epw / 100
                if isinstance(svg.width, Percent)
                else svg.width
            )
            h = (
                svg.height * self.eph / 100
                if isinstance(svg.height, Percent)
                else svg.height
            )
        else:
            _, _, vw, vh = svg.viewbox
            if w == 0:
                w = vw * h / vh
            elif h == 0:
                h = vh * w / vw

        # Flowing mode
        if y is None:
            self._perform_page_break_if_need_be(h)
            y = self.y
            self.y += h
        if x is None:
            x = self.x

        _, _, path = svg.transform_to_rect_viewport(
            scale=1, width=w, height=h, ignore_svg_top_attrs=True
        )
        path.transform = path.transform @ drawing.Transform.translation(x, y)

        try:
            old_x, old_y = self.x, self.y
            self.set_xy(0, 0)
            if title or alt_text:
                with self._marked_sequence(title=title, alt_text=alt_text):
                    self.draw_path(path)
            else:
                self.draw_path(path)
        finally:
            self.set_xy(old_x, old_y)
        if link:
            self.link(x, y, w, h, link)

    def _downscale_image(self, name, img, info, w, h):
        width_in_pt, height_in_pt = w * self.k, h * self.k
        lowres_name = f&#34;lowres-{name}&#34;
        lowres_info = self.images.get(lowres_name)
        if (
            info[&#34;w&#34;] &gt; width_in_pt * self.oversized_images_ratio
            and info[&#34;h&#34;] &gt; height_in_pt * self.oversized_images_ratio
        ):
            factor = (
                min(info[&#34;w&#34;] / width_in_pt, info[&#34;h&#34;] / height_in_pt)
                / self.oversized_images_ratio
            )
            if self.oversized_images.lower().startswith(&#34;warn&#34;):
                LOGGER.warning(
                    &#34;OVERSIZED: Image %s with size %.1fx%.1fpx is rendered at size %.1fx%.1fpt.&#34;
                    &#34; Set pdf.oversized_images = &#39;DOWNSCALE&#39; to reduce embedded image size by a factor %.1f&#34;,
                    name,
                    info[&#34;w&#34;],
                    info[&#34;h&#34;],
                    width_in_pt,
                    height_in_pt,
                    factor,
                )
            elif self.oversized_images.lower() == &#34;downscale&#34;:
                dims = (
                    round(width_in_pt * self.oversized_images_ratio),
                    round(height_in_pt * self.oversized_images_ratio),
                )
                info[&#34;usages&#34;] -= 1  # no need to embed the high-resolution image
                if lowres_info:  # Great, we&#39;ve already done the job!
                    info = lowres_info
                    if info[&#34;w&#34;] * info[&#34;h&#34;] &lt; dims[0] * dims[1]:
                        # The existing low-res image is too small, we need a bigger low-res image:
                        info.update(
                            get_img_info(
                                img or load_image(name), self.image_filter, dims
                            )
                        )
                        LOGGER.debug(
                            &#34;OVERSIZED: Updated low-res image with name=%s id=%d to dims=%s&#34;,
                            lowres_name,
                            info[&#34;i&#34;],
                            dims,
                        )
                    info[&#34;usages&#34;] += 1
                else:
                    info = get_img_info(
                        img or load_image(name), self.image_filter, dims
                    )
                    info[&#34;i&#34;] = len(self.images) + 1
                    info[&#34;usages&#34;] = 1
                    self.images[lowres_name] = info
                    LOGGER.debug(
                        &#34;OVERSIZED: Generated new low-res image with name=%s dims=%s id=%d&#34;,
                        lowres_name,
                        dims,
                        info[&#34;i&#34;],
                    )
            else:
                raise ValueError(
                    f&#34;Invalid value for attribute .oversized_images: {self.oversized_images}&#34;
                )
        elif lowres_info:
            # Embedding the same image in high-res after inserting it in low-res:
            lowres_info.update(info)
            del self.images[name]
            info = lowres_info
        return info

    @contextmanager
    def _marked_sequence(self, **kwargs):
        page_object_id = self._current_page_object_id()
        mcid = self.struct_builder.next_mcid_for_page(page_object_id)
        marked_content = self._add_marked_content(
            page_object_id, struct_type=&#34;/Figure&#34;, mcid=mcid, **kwargs
        )
        self._out(f&#34;/P &lt;&lt;/MCID {mcid}&gt;&gt; BDC&#34;)
        yield marked_content
        self._out(&#34;EMC&#34;)

    def _add_marked_content(self, page_object_id, **kwargs):
        struct_parents_id = self._struct_parents_id_per_page.get(page_object_id)
        if struct_parents_id is None:
            struct_parents_id = len(self._struct_parents_id_per_page)
            self._struct_parents_id_per_page[page_object_id] = struct_parents_id
        marked_content = MarkedContent(page_object_id, struct_parents_id, **kwargs)
        self.struct_builder.add_marked_content(marked_content)
        return marked_content

    def _current_page_object_id(self):
        # Predictable given that _putpages is invoked first in _enddoc:
        return 2 * self.page + 1

    @check_page
    def ln(self, h=None):
        &#34;&#34;&#34;
        Line Feed.
        The current abscissa goes back to the left margin and the ordinate increases by
        the amount passed as parameter.

        Args:
            h (float): The height of the break.
                By default, the value equals the height of the last printed cell.
        &#34;&#34;&#34;
        self.x = self.l_margin
        self.y += self.lasth if h is None else h

    def get_x(self):
        &#34;&#34;&#34;Returns the abscissa of the current position.&#34;&#34;&#34;
        return self.x

    def set_x(self, x):
        &#34;&#34;&#34;
        Defines the abscissa of the current position.
        If the value provided is negative, it is relative to the right of the page.

        Args:
            x (float): the new current abscissa
        &#34;&#34;&#34;
        self.x = x if x &gt;= 0 else self.w + x

    def get_y(self):
        &#34;&#34;&#34;Returns the ordinate of the current position.&#34;&#34;&#34;
        return self.y

    def set_y(self, y):
        &#34;&#34;&#34;
        Moves the current abscissa back to the left margin and sets the ordinate.
        If the value provided is negative, it is relative to the bottom of the page.

        Args:
            y (float): the new current ordinate
        &#34;&#34;&#34;
        self.x = self.l_margin
        self.y = y if y &gt;= 0 else self.h + y

    def set_xy(self, x, y):
        &#34;&#34;&#34;
        Defines the abscissa and ordinate of the current position.
        If the values provided are negative, they are relative respectively to the right and bottom of the page.

        Args:
            x (float): the new current abscissa
            y (float): the new current ordinate
        &#34;&#34;&#34;
        self.set_y(y)
        self.set_x(x)

    def output(self, name=&#34;&#34;, dest=&#34;&#34;):
        &#34;&#34;&#34;
        Output PDF to some destination.
        The method first calls [close](close.md) if necessary to terminate the document.

        By default the bytearray buffer is returned.
        If a `name` is given, the PDF is written to a new file.

        Args:
            name (str): optional File object or file path where to save the PDF under
            dest (str): [**DEPRECATED**] unused, will be removed in a later version
        &#34;&#34;&#34;
        if dest:
            warnings.warn(
                &#39;&#34;dest&#34; parameter is deprecated, unused and will soon be removed&#39;,
                DeprecationWarning,
            )
        # Finish document if necessary:
        if self.state &lt; DocumentState.CLOSED:
            self.close()
        if name:
            if isinstance(name, os.PathLike):
                name.write_bytes(self.buffer)
            elif isinstance(name, str):
                Path(name).write_bytes(self.buffer)
            else:
                name.write(self.buffer)
            return None
        return self.buffer

    def normalize_text(self, txt):
        &#34;&#34;&#34;Check that text input is in the correct format/encoding&#34;&#34;&#34;
        # - for TTF unicode fonts: unicode object (utf8 encoding)
        # - for built-in fonts: string instances (encoding: latin-1, cp1252)
        if not self.unifontsubset and self.core_fonts_encoding:
            return txt.encode(self.core_fonts_encoding).decode(&#34;latin-1&#34;)
        return txt

    def _putpages(self):
        nb = self.pages_count  # total number of pages
        if self.str_alias_nb_pages:
            self._substitute_page_number()
        if self._toc_placeholder:
            self._insert_table_of_contents()
        if self.def_orientation == &#34;P&#34;:
            dw_pt = self.dw_pt
            dh_pt = self.dh_pt
        else:
            dw_pt = self.dh_pt
            dh_pt = self.dw_pt
        filter = &#34;/Filter /FlateDecode &#34; if self.compress else &#34;&#34;
        for n in range(1, nb + 1):
            # Page
            self._newobj()
            self._out(&#34;&lt;&lt;/Type /Page&#34;)
            self._out(f&#34;/Parent {pdf_ref(1)}&#34;)
            page = self.pages[n]
            if page[&#34;duration&#34;]:
                self._out(f&#34;/Dur {page[&#39;duration&#39;]}&#34;)
            if page[&#34;transition&#34;]:
                self._out(f&#34;/Trans {page[&#39;transition&#39;].dict_as_string()}&#34;)
            w_pt, h_pt = page[&#34;w_pt&#34;], page[&#34;h_pt&#34;]
            if w_pt != dw_pt or h_pt != dh_pt:
                self._out(f&#34;/MediaBox [0 0 {w_pt:.2f} {h_pt:.2f}]&#34;)
            self._out(f&#34;/Resources {pdf_ref(2)}&#34;)

            page_annots = self.annots[n]
            if page_annots:  # Annotations, e.g. links:
                annots = &#34;&#34;
                for annot in page_annots:
                    # first four things in &#39;link&#39; list are coordinates?
                    rect = (
                        f&#34;{annot.x:.2f} {annot.y:.2f} &#34;
                        f&#34;{annot.x + annot.width:.2f} {annot.y - annot.height:.2f}&#34;
                    )

                    # start the annotation entry
                    annots += (
                        f&#34;&lt;&lt;/Type /Annot /Subtype /{annot.type}&#34;
                        f&#34; /Rect [{rect}] /Border [0 0 0]&#34;
                        # Flag &#34;Print&#34; (bit position 3) specifies to print
                        # the annotation when the page is printed.
                        # cf. https://docs.verapdf.org/validation/pdfa-part1/#rule-653-2
                        f&#34; /F 4&#34;
                    )

                    if annot.contents:
                        annots += f&#34; /Contents {enclose_in_parens(annot.contents)}&#34;

                    if annot.alt_text is not None:
                        # Note: the spec indicates that a /StructParent could be added **inside* this /Annot,
                        # but tests with Adobe Acrobat Reader reveal that the page /StructParents inserted below
                        # is enough to link the marked content in the hierarchy tree with this annotation link.
                        self._add_marked_content(
                            self.n, struct_type=&#34;/Link&#34;, alt_text=annot.alt_text
                        )

                    if annot.action:
                        annots += f&#34; /A &lt;&lt;{annot.action.dict_as_string()}&gt;&gt;&#34;

                    if annot.link:
                        if isinstance(annot.link, str):
                            annots += (
                                f&#34; /A &lt;&lt;/S /URI /URI {enclose_in_parens(annot.link)}&gt;&gt;&#34;
                            )
                        else:  # Dest type ending of annotation entry
                            assert annot.link in self.links, (
                                f&#34;Page {n} has a link with an invalid index: &#34;
                                f&#34;{annot.link} (doc #links={len(self.links)})&#34;
                            )
                            dest = self.links[annot.link]
                            annots += f&#34; /Dest {dest.as_str(self)}&#34;
                    annots += &#34;&gt;&gt;&#34;
                # End links list
                self._out(f&#34;/Annots [{annots}]&#34;)
            if self.pdf_version &gt; &#34;1.3&#34;:
                self._out(&#34;/Group &lt;&lt;/Type /Group /S /Transparency&#34; &#34;/CS /DeviceRGB&gt;&gt;&#34;)
            spid = self._struct_parents_id_per_page.get(self.n)
            if spid is not None:
                self._out(f&#34;/StructParents {spid}&#34;)
            self._out(f&#34;/Contents {pdf_ref(self.n + 1)}&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)

            # Page content
            content = page[&#34;content&#34;]
            p = zlib.compress(content) if self.compress else content
            self._newobj()
            self._out(f&#34;&lt;&lt;{filter}/Length {len(p)}&gt;&gt;&#34;)
            self._out(pdf_stream(p))
            self._out(&#34;endobj&#34;)
        # Pages root
        self.offsets[1] = len(self.buffer)
        self._out(&#34;1 0 obj&#34;)
        self._out(&#34;&lt;&lt;/Type /Pages&#34;)
        self._out(&#34;/Kids [&#34; + &#34; &#34;.join(pdf_ref(3 + 2 * i) for i in range(nb)) + &#34;]&#34;)
        self._out(f&#34;/Count {nb}&#34;)
        self._out(f&#34;/MediaBox [0 0 {dw_pt:.2f} {dh_pt:.2f}]&#34;)
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;endobj&#34;)

    def _substitute_page_number(self):
        nb = self.pages_count  # total number of pages
        substituted = False
        # Replace number of pages in fonts using subsets (unicode)
        alias = self.str_alias_nb_pages.encode(&#34;utf-16-be&#34;)
        encoded_nb = str(nb).encode(&#34;utf-16-be&#34;)
        for n in range(1, nb + 1):
            page = self.pages[n]
            new_content = page[&#34;content&#34;].replace(alias, encoded_nb)
            substituted |= page[&#34;content&#34;] != new_content
            page[&#34;content&#34;] = new_content
        # Now repeat for no pages in non-subset fonts
        alias = self.str_alias_nb_pages.encode(&#34;latin-1&#34;)
        encoded_nb = str(nb).encode(&#34;latin-1&#34;)
        for n in range(1, nb + 1):
            page = self.pages[n]
            new_content = page[&#34;content&#34;].replace(alias, encoded_nb)
            substituted |= page[&#34;content&#34;] != new_content
            page[&#34;content&#34;] = new_content
        if substituted:
            LOGGER.debug(
                &#34;Substitution of &#39;%s&#39; was performed in the document&#34;,
                self.str_alias_nb_pages,
            )

    def _insert_table_of_contents(self):
        prev_state = self.state
        tocp = self._toc_placeholder
        self.page = tocp.start_page
        # Doc has been closed but we want to write to self.pages[self.page] instead of self.buffer:
        self.state = DocumentState.GENERATING_PAGE
        self.y = tocp.y
        tocp.render_function(self, self._outline)
        expected_final_page = tocp.start_page + tocp.pages - 1
        if self.page != expected_final_page:
            too = &#34;many&#34; if self.page &gt; expected_final_page else &#34;few&#34;
            error_msg = f&#34;The rendering function passed to FPDF.insert_toc_placeholder triggered too {too} page breaks: &#34;
            error_msg += f&#34;ToC ended on page {self.page} while it was expected to span exactly {tocp.pages} pages&#34;
            raise FPDFException(error_msg)
        self.state = prev_state

    def _putfonts(self):
        nf = self.n
        for diff in self.diffs.values():
            # Encodings
            self._newobj()
            self._out(
                &#34;&lt;&lt;/Type /Encoding /BaseEncoding /WinAnsiEncoding &#34;
                + &#34;/Differences [&#34;
                + diff
                + &#34;]&gt;&gt;&#34;
            )
            self._out(&#34;endobj&#34;)

        for name, info in self.font_files.items():
            if &#34;type&#34; in info and info[&#34;type&#34;] != &#34;TTF&#34;:
                # Font file embedding
                self._newobj()
                info[&#34;n&#34;] = self.n
                font = (FPDF_FONT_DIR / name).read_bytes()
                compressed = substr(name, -2) == &#34;.z&#34;
                if not compressed and &#34;length2&#34; in info:
                    header = ord(font[0]) == 128
                    if header:
                        # Strip first binary header
                        font = substr(font, 6)
                    if header and ord(font[info[&#34;length1&#34;]]) == 128:
                        # Strip second binary header
                        font = substr(font, 0, info[&#34;length1&#34;]) + substr(
                            font, info[&#34;length1&#34;] + 6
                        )

                self._out(f&#34;&lt;&lt;/Length {len(font)}&#34;)
                if compressed:
                    self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(f&#34;/Length1 {info[&#39;length1&#39;]}&#34;)
                if &#34;length2&#34; in info:
                    self._out(f&#34;/Length2 {info[&#39;length2&#39;]} /Length3 0&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(font))
                self._out(&#34;endobj&#34;)

        # Font objects
        flist = [(x[1][&#34;i&#34;], x[0], x[1]) for x in self.fonts.items()]
        flist.sort()
        for _, font_name, font in flist:
            self.fonts[font_name][&#34;n&#34;] = self.n + 1
            my_type = font[&#34;type&#34;]
            name = font[&#34;name&#34;]
            # Standard font
            if my_type == &#34;core&#34;:
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(f&#34;/BaseFont /{name}&#34;)
                self._out(&#34;/Subtype /Type1&#34;)
                if name not in (&#34;Symbol&#34;, &#34;ZapfDingbats&#34;):
                    self._out(&#34;/Encoding /WinAnsiEncoding&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

            # Additional Type1 or TrueType font
            elif my_type in (&#34;Type1&#34;, &#34;TrueType&#34;):
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(f&#34;/BaseFont /{name}&#34;)
                self._out(f&#34;/Subtype /{my_type}&#34;)
                self._out(&#34;/FirstChar 32 /LastChar 255&#34;)
                self._out(f&#34;/Widths {pdf_ref(self.n + 1)}&#34;)
                self._out(f&#34;/FontDescriptor {pdf_ref(self.n + 2)}&#34;)
                if font[&#34;enc&#34;]:
                    if &#34;diff&#34; in font:
                        self._out(f&#34;/Encoding {pdf_ref(nf + font[&#39;diff&#39;])}&#34;)
                    else:
                        self._out(&#34;/Encoding /WinAnsiEncoding&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Widths
                self._newobj()
                self._out(
                    &#34;[&#34;
                    + &#34; &#34;.join(_char_width(font, chr(i)) for i in range(32, 256))
                    + &#34;]&#34;
                )
                self._out(&#34;endobj&#34;)

                # Descriptor
                self._newobj()
                s = f&#34;&lt;&lt;/Type /FontDescriptor /FontName /{name}&#34;
                for k in (
                    &#34;Ascent&#34;,
                    &#34;Descent&#34;,
                    &#34;CapHeight&#34;,
                    &#34;Flags&#34;,
                    &#34;FontBBox&#34;,
                    &#34;ItalicAngle&#34;,
                    &#34;StemV&#34;,
                    &#34;MissingWidth&#34;,
                ):
                    s += f&#34; /{k} {font[&#39;desc&#39;][k]}&#34;

                filename = font[&#34;file&#34;]
                if filename:
                    s += &#34; /FontFile&#34;
                    if my_type != &#34;Type1&#34;:
                        s += &#34;2&#34;
                    s += &#34; &#34; + pdf_ref(self.font_files[filename][&#34;n&#34;])
                self._out(f&#34;{s}&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)
            elif my_type == &#34;TTF&#34;:
                self.fonts[font_name][&#34;n&#34;] = self.n + 1
                ttf = TTFontFile()
                fontname = f&#34;MPDFAA+{font[&#39;name&#39;]}&#34;
                subset = font[&#34;subset&#34;].dict()
                del subset[0]
                ttfontstream = ttf.makeSubset(font[&#34;ttffile&#34;], subset)
                ttfontsize = len(ttfontstream)
                fontstream = zlib.compress(ttfontstream)
                codeToGlyph = ttf.codeToGlyph
                # del codeToGlyph[0]

                # Type0 Font
                # A composite font - a font composed of other fonts,
                # organized hierarchically
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /Type0&#34;)
                self._out(f&#34;/BaseFont /{fontname}&#34;)
                self._out(&#34;/Encoding /Identity-H&#34;)
                self._out(f&#34;/DescendantFonts [{pdf_ref(self.n + 1)}]&#34;)
                self._out(f&#34;/ToUnicode {pdf_ref(self.n + 2)}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # CIDFontType2
                # A CIDFont whose glyph descriptions are based on
                # TrueType font technology
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /Font&#34;)
                self._out(&#34;/Subtype /CIDFontType2&#34;)
                self._out(f&#34;/BaseFont /{fontname}&#34;)
                self._out(f&#34;/CIDSystemInfo {pdf_ref(self.n + 2)}&#34;)
                self._out(f&#34;/FontDescriptor {pdf_ref(self.n + 3)}&#34;)
                if font[&#34;desc&#34;].get(&#34;MissingWidth&#34;):
                    self._out(f&#34;/DW {font[&#39;desc&#39;][&#39;MissingWidth&#39;]}&#34;)
                self._putTTfontwidths(font, ttf.maxUni)
                self._out(f&#34;/CIDToGIDMap {pdf_ref(self.n + 4)}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # bfChar
                # This table informs the PDF reader about the unicode
                # character that each used 16-bit code belongs to. It
                # allows searching the file and copying text from it.
                bfChar = []
                subset = font[&#34;subset&#34;].dict()
                for code in subset:
                    code_mapped = subset.get(code)
                    if code &gt; 0xFFFF:
                        # Calculate surrogate pair
                        code_high = 0xD800 | (code - 0x10000) &gt;&gt; 10
                        code_low = 0xDC00 | (code &amp; 0x3FF)
                        bfChar.append(
                            f&#34;&lt;{code_mapped:04X}&gt; &lt;{code_high:04X}{code_low:04X}&gt;\n&#34;
                        )
                    else:
                        bfChar.append(f&#34;&lt;{code_mapped:04X}&gt; &lt;{code:04X}&gt;\n&#34;)

                # ToUnicode
                self._newobj()
                toUni = (
                    &#34;/CIDInit /ProcSet findresource begin\n&#34;
                    &#34;12 dict begin\n&#34;
                    &#34;begincmap\n&#34;
                    &#34;/CIDSystemInfo\n&#34;
                    &#34;&lt;&lt;/Registry (Adobe)\n&#34;
                    &#34;/Ordering (UCS)\n&#34;
                    &#34;/Supplement 0\n&#34;
                    &#34;&gt;&gt; def\n&#34;
                    &#34;/CMapName /Adobe-Identity-UCS def\n&#34;
                    &#34;/CMapType 2 def\n&#34;
                    &#34;1 begincodespacerange\n&#34;
                    &#34;&lt;0000&gt; &lt;FFFF&gt;\n&#34;
                    &#34;endcodespacerange\n&#34;
                    f&#34;{len(bfChar)} beginbfchar\n&#34;
                    f&#34;{&#39;&#39;.join(bfChar)}&#34;
                    &#34;endbfchar\n&#34;
                    &#34;endcmap\n&#34;
                    &#34;CMapName currentdict /CMap defineresource pop\n&#34;
                    &#34;end\n&#34;
                    &#34;end&#34;
                )
                self._out(f&#34;&lt;&lt;/Length {len(toUni)}&gt;&gt;&#34;)
                self._out(pdf_stream(toUni))
                self._out(&#34;endobj&#34;)

                # CIDSystemInfo dictionary
                self._newobj()
                self._out(&#34;&lt;&lt;/Registry (Adobe)&#34;)
                self._out(&#34;/Ordering (UCS)&#34;)
                self._out(&#34;/Supplement 0&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Font descriptor
                self._newobj()
                self._out(&#34;&lt;&lt;/Type /FontDescriptor&#34;)
                self._out(&#34;/FontName /&#34; + fontname)
                for kd in (
                    &#34;Ascent&#34;,
                    &#34;Descent&#34;,
                    &#34;CapHeight&#34;,
                    &#34;Flags&#34;,
                    &#34;FontBBox&#34;,
                    &#34;ItalicAngle&#34;,
                    &#34;StemV&#34;,
                    &#34;MissingWidth&#34;,
                ):
                    v = font[&#34;desc&#34;][kd]
                    if kd == &#34;Flags&#34;:
                        v = v | 4
                        v = v &amp; ~32  # SYMBOLIC font flag
                    self._out(f&#34; /{kd} {v}&#34;)
                self._out(f&#34;/FontFile2 {pdf_ref(self.n + 2)}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(&#34;endobj&#34;)

                # Embed CIDToGIDMap
                # A specification of the mapping from CIDs to glyph indices
                cidtogidmap = [&#34;\x00&#34;] * 256 * 256 * 2
                for cc, glyph in codeToGlyph.items():
                    cidtogidmap[cc * 2] = chr(glyph &gt;&gt; 8)
                    cidtogidmap[cc * 2 + 1] = chr(glyph &amp; 0xFF)
                cidtogidmap = &#34;&#34;.join(cidtogidmap)
                # manage binary data as latin1 until PEP461-like function is implemented
                cidtogidmap = zlib.compress(cidtogidmap.encode(&#34;latin1&#34;))
                self._newobj()
                self._out(f&#34;&lt;&lt;/Length {len(cidtogidmap)}&#34;)
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(cidtogidmap))
                self._out(&#34;endobj&#34;)

                # Font file
                self._newobj()
                self._out(f&#34;&lt;&lt;/Length {len(fontstream)}&#34;)
                self._out(&#34;/Filter /FlateDecode&#34;)
                self._out(f&#34;/Length1 {ttfontsize}&#34;)
                self._out(&#34;&gt;&gt;&#34;)
                self._out(pdf_stream(fontstream))
                self._out(&#34;endobj&#34;)
                del ttf
            else:
                # Allow for additional types
                mtd = f&#34;_put{my_type.lower()}&#34;
                # check if self has a attr mtd which is callable (method)
                if not callable(getattr(self, mtd, None)):
                    raise FPDFException(f&#34;Unsupported font type: {my_type}&#34;)
                self.mtd(font)  # pylint: disable=no-member

    def _putTTfontwidths(self, font, maxUni):
        rangeid = 0
        range_ = {}
        range_interval = {}
        prevcid = -2
        prevwidth = -1
        interval = False
        startcid = 1
        cwlen = maxUni + 1

        # for each character
        subset = font[&#34;subset&#34;].dict()
        for cid in range(startcid, cwlen):
            width = _char_width(font, cid)
            if &#34;dw&#34; not in font or (font[&#34;dw&#34;] and width != font[&#34;dw&#34;]):
                cid_mapped = subset.get(cid)
                if cid_mapped is None:
                    continue
                if cid_mapped == (prevcid + 1):
                    if width == prevwidth:
                        if width == range_[rangeid][0]:
                            range_.setdefault(rangeid, []).append(width)
                        else:
                            range_[rangeid].pop()
                            # new range
                            rangeid = prevcid
                            range_[rangeid] = [prevwidth, width]
                        interval = True
                        range_interval[rangeid] = True
                    else:
                        if interval:
                            # new range
                            rangeid = cid_mapped
                            range_[rangeid] = [width]
                        else:
                            range_[rangeid].append(width)
                        interval = False
                else:
                    rangeid = cid_mapped
                    range_[rangeid] = [width]
                    interval = False
                prevcid = cid_mapped
                prevwidth = width
        prevk = -1
        nextk = -1
        prevint = False

        ri = range_interval
        for k, ws in sorted(range_.items()):
            cws = len(ws)
            if k == nextk and not prevint and (k not in ri or cws &lt; 3):
                if k in ri:
                    del ri[k]
                range_[prevk] = range_[prevk] + range_[k]
                del range_[k]
            else:
                prevk = k
            nextk = k + cws
            if k in ri:
                prevint = cws &gt; 3
                del ri[k]
                nextk -= 1
            else:
                prevint = False
        w = []
        for k, ws in sorted(range_.items()):
            if len(set(ws)) == 1:
                w.append(f&#34; {k} {k + len(ws) - 1} {ws[0]}&#34;)
            else:
                w.append(f&#34; {k} [ {&#39; &#39;.join(str(int(h)) for h in ws)} ]\n&#34;)
        self._out(f&#34;/W [{&#39;&#39;.join(w)}]&#34;)

    def _putimages(self):
        for img_info in sorted(
            self.images.values(), key=lambda img_info: img_info[&#34;i&#34;]
        ):
            if img_info[&#34;usages&#34;] == 0:
                continue
            self._putimage(img_info)
            del img_info[&#34;data&#34;]
            if &#34;smask&#34; in img_info:
                del img_info[&#34;smask&#34;]

    def _putimage(self, info):
        if &#34;data&#34; not in info:
            return
        self._newobj()
        info[&#34;n&#34;] = self.n
        self._out(&#34;&lt;&lt;/Type /XObject&#34;)
        self._out(&#34;/Subtype /Image&#34;)
        self._out(f&#34;/Width {info[&#39;w&#39;]}&#34;)
        self._out(f&#34;/Height {info[&#39;h&#39;]}&#34;)

        if info[&#34;cs&#34;] == &#34;Indexed&#34;:
            self._out(
                f&#34;/ColorSpace [/Indexed /DeviceRGB &#34;
                f&#34;{len(info[&#39;pal&#39;]) // 3 - 1} {pdf_ref(self.n + 1)}]&#34;
            )
        else:
            self._out(f&#34;/ColorSpace /{info[&#39;cs&#39;]}&#34;)
            if info[&#34;cs&#34;] == &#34;DeviceCMYK&#34;:
                self._out(&#34;/Decode [1 0 1 0 1 0 1 0]&#34;)

        self._out(f&#34;/BitsPerComponent {info[&#39;bpc&#39;]}&#34;)

        if &#34;f&#34; in info:
            self._out(f&#34;/Filter /{info[&#39;f&#39;]}&#34;)
        if &#34;dp&#34; in info:
            self._out(f&#34;/DecodeParms &lt;&lt;{info[&#39;dp&#39;]}&gt;&gt;&#34;)

        if &#34;trns&#34; in info and isinstance(info[&#34;trns&#34;], list):
            trns = &#34; &#34;.join(f&#34;{x} {x}&#34; for x in info[&#34;trns&#34;])
            self._out(f&#34;/Mask [{trns}]&#34;)

        if self.allow_images_transparency and &#34;smask&#34; in info:
            self._out(f&#34;/SMask {pdf_ref(self.n + 1)}&#34;)

        self._out(f&#34;/Length {len(info[&#39;data&#39;])}&gt;&gt;&#34;)
        self._out(pdf_stream(info[&#34;data&#34;]))
        self._out(&#34;endobj&#34;)

        # Soft mask
        if self.allow_images_transparency and &#34;smask&#34; in info:
            dp = f&#34;/Predictor 15 /Colors 1 /BitsPerComponent 8 /Columns {info[&#39;w&#39;]}&#34;
            smask = {
                &#34;w&#34;: info[&#34;w&#34;],
                &#34;h&#34;: info[&#34;h&#34;],
                &#34;cs&#34;: &#34;DeviceGray&#34;,
                &#34;bpc&#34;: 8,
                &#34;f&#34;: info[&#34;f&#34;],
                &#34;dp&#34;: dp,
                &#34;data&#34;: info[&#34;smask&#34;],
            }
            self._putimage(smask)

        # Palette
        if info[&#34;cs&#34;] == &#34;Indexed&#34;:
            self._newobj()
            filter, pal = (
                (&#34;/Filter /FlateDecode &#34;, zlib.compress(info[&#34;pal&#34;]))
                if self.compress
                else (&#34;&#34;, info[&#34;pal&#34;])
            )
            self._out(f&#34;&lt;&lt;{filter}/Length {len(pal)}&gt;&gt;&#34;)
            self._out(pdf_stream(pal))
            self._out(&#34;endobj&#34;)

    def _putxobjectdict(self):
        img_ids = [
            (img_info[&#34;i&#34;], img_info[&#34;n&#34;])
            for img_info in self.images.values()
            if img_info[&#34;usages&#34;]
        ]
        img_ids.sort()
        for idx, n in img_ids:
            self._out(f&#34;/I{idx} {pdf_ref(n)}&#34;)

    def _put_graphics_state_dicts(self):
        for state_dict, name in self._drawing_graphics_state_registry.items():
            self._newobj()
            self._graphics_state_obj_refs[name] = self.n
            self._out(state_dict)
            self._out(&#34;endobj&#34;)

    def _put_graphics_state_refs(self):
        for name, obj_id in self._graphics_state_obj_refs.items():
            self._out(f&#34;{drawing.render_pdf_primitive(name)} {pdf_ref(obj_id)}&#34;)

    def _putresourcedict(self):
        # From section 10.1, &#34;Procedure Sets&#34;, of PDF 1.7 spec:
        # &gt; Beginning with PDF 1.4, this feature is considered obsolete.
        # &gt; For compatibility with existing consumer applications,
        # &gt; PDF producer applications should continue to specify procedure sets
        # &gt; (preferably, all of those listed in Table 10.1).
        self._out(&#34;/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]&#34;)
        self._out(&#34;/Font &lt;&lt;&#34;)
        font_ids = [(x[&#34;i&#34;], x[&#34;n&#34;]) for x in self.fonts.values()]
        font_ids.sort()
        for idx, n in font_ids:
            self._out(f&#34;/F{idx} {pdf_ref(n)}&#34;)
        self._out(&#34;&gt;&gt;&#34;)
        self._out(&#34;/XObject &lt;&lt;&#34;)
        self._putxobjectdict()
        self._out(&#34;&gt;&gt;&#34;)

        if self._drawing_graphics_state_registry:
            self._out(&#34;/ExtGState &lt;&lt;&#34;)
            self._put_graphics_state_refs()
            self._out(&#34;&gt;&gt;&#34;)

    def _putresources(self):
        with self._trace_size(&#34;resources.fonts&#34;):
            self._putfonts()
        with self._trace_size(&#34;resources.images&#34;):
            self._putimages()
        with self._trace_size(&#34;resources.gfxstate&#34;):
            self._put_graphics_state_dicts()

        # Resource dictionary
        with self._trace_size(&#34;resources.dict&#34;):
            self.offsets[2] = len(self.buffer)
            self._out(&#34;2 0 obj&#34;)
            self._out(&#34;&lt;&lt;&#34;)
            self._putresourcedict()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)

    def _put_structure_tree(self):
        &#34;Builds a Structure Hierarchy, including image alternate descriptions&#34;
        # This property is later used by _putcatalog to insert a reference to the StructTreeRoot:
        self._struct_tree_root_obj_id = self.n + 1
        self.struct_builder.serialize(
            first_object_id=self._struct_tree_root_obj_id, fpdf=self
        )

    def _put_document_outline(self):
        # This property is later used by _putcatalog to insert a reference to the Outlines:
        self._outlines_obj_id = self.n + 1
        serialize_outline(
            self._outline, first_object_id=self._outlines_obj_id, fpdf=self
        )

    def _put_xmp_metadata(self):
        xpacket = f&#39;&lt;?xpacket begin=&#34;ï»¿&#34; id=&#34;W5M0MpCehiHzreSzNTczkc9d&#34;?&gt;\n{self.xmp_metadata}\n&lt;?xpacket end=&#34;w&#34;?&gt;\n&#39;
        self._newobj()
        self._out(f&#34;&lt;&lt;/Type /Metadata /Subtype /XML /Length {len(xpacket)}&gt;&gt;&#34;)
        self._out(pdf_stream(xpacket))
        self._out(&#34;endobj&#34;)
        self._xmp_metadata_obj_id = self.n

    def _putinfo(self):
        info_d = {
            &#34;/Title&#34;: enclose_in_parens(getattr(self, &#34;title&#34;, None)),
            &#34;/Subject&#34;: enclose_in_parens(getattr(self, &#34;subject&#34;, None)),
            &#34;/Author&#34;: enclose_in_parens(getattr(self, &#34;author&#34;, None)),
            &#34;/Keywords&#34;: enclose_in_parens(getattr(self, &#34;keywords&#34;, None)),
            &#34;/Creator&#34;: enclose_in_parens(getattr(self, &#34;creator&#34;, None)),
            &#34;/Producer&#34;: enclose_in_parens(getattr(self, &#34;producer&#34;, None)),
        }

        if hasattr(self, &#34;creation_date&#34;):
            try:
                creation_date = self.creation_date
                date_string = f&#34;{creation_date:%Y%m%d%H%M%S}&#34;
            except Exception as error:
                raise FPDFException(
                    f&#34;Could not format date: {creation_date}&#34;
                ) from error
        else:
            date_string = f&#34;{datetime.now():%Y%m%d%H%M%S}&#34;
        info_d[&#34;/CreationDate&#34;] = enclose_in_parens(f&#34;D:{date_string}&#34;)

        self._out(pdf_d(info_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;, has_empty_fields=True))

    def _putcatalog(self):
        catalog_d = {
            &#34;/Type&#34;: &#34;/Catalog&#34;,
            # Pages is always the 1st object of the document, cf. the end of _putpages:
            &#34;/Pages&#34;: pdf_ref(1),
        }
        lang = enclose_in_parens(getattr(self, &#34;lang&#34;, None))
        if lang:
            catalog_d[&#34;/Lang&#34;] = lang

        if self.zoom_mode in ZOOM_CONFIGS:
            zoom_config = [
                pdf_ref(3),  # reference to object ID of the 1st page
                *ZOOM_CONFIGS[self.zoom_mode],
            ]
        else:  # zoom_mode is a number, not one of the allowed strings:
            zoom_config = [&#34;/XYZ&#34;, &#34;null&#34;, &#34;null&#34;, str(self.zoom_mode / 100)]
        catalog_d[&#34;/OpenAction&#34;] = pdf_l(zoom_config)

        if self.layout_mode in LAYOUT_NAMES:
            catalog_d[&#34;/PageLayout&#34;] = LAYOUT_NAMES[self.layout_mode]
        if self._xmp_metadata_obj_id:
            catalog_d[&#34;/Metadata&#34;] = pdf_ref(self._xmp_metadata_obj_id)
        if self._struct_tree_root_obj_id:
            catalog_d[&#34;/MarkInfo&#34;] = pdf_d({&#34;/Marked&#34;: &#34;true&#34;})
            catalog_d[&#34;/StructTreeRoot&#34;] = pdf_ref(self._struct_tree_root_obj_id)
        if self._outlines_obj_id:
            catalog_d[&#34;/Outlines&#34;] = pdf_ref(self._outlines_obj_id)

        self._out(pdf_d(catalog_d, open_dict=&#34;&#34;, close_dict=&#34;&#34;))

    def _putheader(self):
        self._out(f&#34;%PDF-{self.pdf_version}&#34;)

    def _puttrailer(self):
        self._out(f&#34;/Size {self.n + 1}&#34;)
        self._out(f&#34;/Root {pdf_ref(self.n)}&#34;)  # Catalog object index
        self._out(f&#34;/Info {pdf_ref(self.n - 1)}&#34;)  # Info object index

    def _enddoc(self):
        LOGGER.debug(&#34;Final doc sections size summary:&#34;)
        with self._trace_size(&#34;header&#34;):
            self._putheader()
        with self._trace_size(&#34;pages&#34;):
            self._putpages()
        self._putresources()  # trace_size is performed inside
        if not self.struct_builder.empty():
            with self._trace_size(&#34;structure_tree&#34;):
                self._put_structure_tree()
        if self._outline:
            with self._trace_size(&#34;document_outline&#34;):
                self._put_document_outline()
        if self.xmp_metadata:
            self._put_xmp_metadata()
        # Info
        with self._trace_size(&#34;info&#34;):
            self._newobj()
            self._out(&#34;&lt;&lt;&#34;)
            self._putinfo()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)
        # Catalog
        with self._trace_size(&#34;catalog&#34;):
            self._newobj()
            self._out(&#34;&lt;&lt;&#34;)
            self._putcatalog()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;endobj&#34;)
        # Cross-ref
        with self._trace_size(&#34;xref&#34;):
            o = len(self.buffer)
            self._out(&#34;xref&#34;)
            self._out(f&#34;0 {self.n + 1}&#34;)
            self._out(&#34;0000000000 65535 f &#34;)
            for i in range(1, self.n + 1):
                self._out(f&#34;{self.offsets[i]:010} 00000 n &#34;)
        # Trailer
        with self._trace_size(&#34;trailer&#34;):
            self._out(&#34;trailer&#34;)
            self._out(&#34;&lt;&lt;&#34;)
            self._puttrailer()
            self._out(&#34;&gt;&gt;&#34;)
            self._out(&#34;startxref&#34;)
            self._out(o)
        self._out(&#34;%%EOF&#34;)
        self.state = DocumentState.CLOSED

    def _beginpage(
        self, orientation, format, same, duration, transition, new_page=True
    ):
        self.page += 1
        if new_page:
            page = {
                &#34;content&#34;: bytearray(),
                &#34;duration&#34;: duration,
                &#34;transition&#34;: transition,
            }
            self.pages[self.page] = page
        else:
            page = self.pages[self.page]
        self.state = DocumentState.GENERATING_PAGE
        self.x = self.l_margin
        self.y = self.t_margin
        self.font_family = &#34;&#34;
        self.font_stretching = 100
        if same:
            if orientation or format:
                raise ValueError(
                    f&#34;Inconsistent parameters: same={same} but orientation={orientation} format={format}&#34;
                )
        else:
            # Set page format if provided, else use default value:
            page_width_pt, page_height_pt = (
                get_page_format(format, self.k) if format else (self.dw_pt, self.dh_pt)
            )
            self._set_orientation(
                orientation or self.def_orientation, page_width_pt, page_height_pt
            )
            self.page_break_trigger = self.h - self.b_margin
        page[&#34;w_pt&#34;], page[&#34;h_pt&#34;] = self.w_pt, self.h_pt

    def _endpage(self):
        # End of page contents
        self.state = DocumentState.READY

    def _newobj(self):
        # Begin a new object
        self.n += 1
        self.offsets[self.n] = len(self.buffer)
        self._out(f&#34;{self.n} 0 obj&#34;)
        return self.n

    def _do_underline(self, x, y, txt):
        &#34;Draw an horizontal line starting from (x, y) with a length equal to &#39;txt&#39; width&#34;
        up = self.current_font[&#34;up&#34;]
        ut = self.current_font[&#34;ut&#34;]
        w = self.get_string_width(txt, True) + self.ws * txt.count(&#34; &#34;)
        return (
            f&#34;{x * self.k:.2f} &#34;
            f&#34;{(self.h - y + up / 1000 * self.font_size) * self.k:.2f} &#34;
            f&#34;{w * self.k:.2f} {-ut / 1000 * self.font_size_pt:.2f} re f&#34;
        )

    def _out(self, s):
        if self.state == DocumentState.CLOSED:
            raise FPDFException(
                &#34;Content cannot be added on a closed document, after calling output()&#34;
            )
        if not isinstance(s, bytes):
            if not isinstance(s, str):
                s = str(s)
            s = s.encode(&#34;latin1&#34;)
        if self.state == DocumentState.GENERATING_PAGE:
            self.pages[self.page][&#34;content&#34;] += s + b&#34;\n&#34;
        else:
            self.buffer += s + b&#34;\n&#34;

    @check_page
    def interleaved2of5(self, txt, x, y, w=1, h=10):
        &#34;&#34;&#34;Barcode I2of5 (numeric), adds a 0 if odd length&#34;&#34;&#34;
        narrow = w / 3
        wide = w

        # wide/narrow codes for the digits
        bar_char = {
            &#34;0&#34;: &#34;nnwwn&#34;,
            &#34;1&#34;: &#34;wnnnw&#34;,
            &#34;2&#34;: &#34;nwnnw&#34;,
            &#34;3&#34;: &#34;wwnnn&#34;,
            &#34;4&#34;: &#34;nnwnw&#34;,
            &#34;5&#34;: &#34;wnwnn&#34;,
            &#34;6&#34;: &#34;nwwnn&#34;,
            &#34;7&#34;: &#34;nnnww&#34;,
            &#34;8&#34;: &#34;wnnwn&#34;,
            &#34;9&#34;: &#34;nwnwn&#34;,
            &#34;A&#34;: &#34;nn&#34;,
            &#34;Z&#34;: &#34;wn&#34;,
        }
        # The caller should do this, or we can&#39;t rotate the thing.
        # self.set_fill_color(0)
        code = txt
        # add leading zero if code-length is odd
        if len(code) % 2 != 0:
            code = f&#34;0{code}&#34;

        # add start and stop codes
        code = f&#34;AA{code.lower()}ZA&#34;

        for i in range(0, len(code), 2):
            # choose next pair of digits
            char_bar = code[i]
            char_space = code[i + 1]
            # check whether it is a valid digit
            if char_bar not in bar_char:
                raise RuntimeError(f&#39;Char &#34;{char_bar}&#34; invalid for I25:&#39;)
            if char_space not in bar_char:
                raise RuntimeError(f&#39;Char &#34;{char_space}&#34; invalid for I25: &#39;)

            # create a wide/narrow-seq (first digit=bars, second digit=spaces)
            seq = &#34;&#34;.join(
                f&#34;{cb}{cs}&#34; for cb, cs in zip(bar_char[char_bar], bar_char[char_space])
            )

            for bar_index, char in enumerate(seq):
                # set line_width depending on value
                line_width = narrow if char == &#34;n&#34; else wide

                # draw every second value, the other is represented by space
                if bar_index % 2 == 0:
                    self.rect(x, y, line_width, h, &#34;F&#34;)

                x += line_width

    @check_page
    def code39(self, txt, x, y, w=1.5, h=5):
        &#34;&#34;&#34;Barcode 3of9&#34;&#34;&#34;
        dim = {&#34;w&#34;: w, &#34;n&#34;: w / 3}
        if not txt.startswith(&#34;*&#34;) or not txt.endswith(&#34;*&#34;):
            warnings.warn(
                &#34;Code 39 input must start and end with a &#39;*&#39; character to be valid.&#34;
                &#34; This method does not insert it automatically.&#34;
            )
        chars = {
            &#34;0&#34;: &#34;nnnwwnwnn&#34;,
            &#34;1&#34;: &#34;wnnwnnnnw&#34;,
            &#34;2&#34;: &#34;nnwwnnnnw&#34;,
            &#34;3&#34;: &#34;wnwwnnnnn&#34;,
            &#34;4&#34;: &#34;nnnwwnnnw&#34;,
            &#34;5&#34;: &#34;wnnwwnnnn&#34;,
            &#34;6&#34;: &#34;nnwwwnnnn&#34;,
            &#34;7&#34;: &#34;nnnwnnwnw&#34;,
            &#34;8&#34;: &#34;wnnwnnwnn&#34;,
            &#34;9&#34;: &#34;nnwwnnwnn&#34;,
            &#34;A&#34;: &#34;wnnnnwnnw&#34;,
            &#34;B&#34;: &#34;nnwnnwnnw&#34;,
            &#34;C&#34;: &#34;wnwnnwnnn&#34;,
            &#34;D&#34;: &#34;nnnnwwnnw&#34;,
            &#34;E&#34;: &#34;wnnnwwnnn&#34;,
            &#34;F&#34;: &#34;nnwnwwnnn&#34;,
            &#34;G&#34;: &#34;nnnnnwwnw&#34;,
            &#34;H&#34;: &#34;wnnnnwwnn&#34;,
            &#34;I&#34;: &#34;nnwnnwwnn&#34;,
            &#34;J&#34;: &#34;nnnnwwwnn&#34;,
            &#34;K&#34;: &#34;wnnnnnnww&#34;,
            &#34;L&#34;: &#34;nnwnnnnww&#34;,
            &#34;M&#34;: &#34;wnwnnnnwn&#34;,
            &#34;N&#34;: &#34;nnnnwnnww&#34;,
            &#34;O&#34;: &#34;wnnnwnnwn&#34;,
            &#34;P&#34;: &#34;nnwnwnnwn&#34;,
            &#34;Q&#34;: &#34;nnnnnnwww&#34;,
            &#34;R&#34;: &#34;wnnnnnwwn&#34;,
            &#34;S&#34;: &#34;nnwnnnwwn&#34;,
            &#34;T&#34;: &#34;nnnnwnwwn&#34;,
            &#34;U&#34;: &#34;wwnnnnnnw&#34;,
            &#34;V&#34;: &#34;nwwnnnnnw&#34;,
            &#34;W&#34;: &#34;wwwnnnnnn&#34;,
            &#34;X&#34;: &#34;nwnnwnnnw&#34;,
            &#34;Y&#34;: &#34;wwnnwnnnn&#34;,
            &#34;Z&#34;: &#34;nwwnwnnnn&#34;,
            &#34;-&#34;: &#34;nwnnnnwnw&#34;,
            &#34;.&#34;: &#34;wwnnnnwnn&#34;,
            &#34; &#34;: &#34;nwwnnnwnn&#34;,
            &#34;*&#34;: &#34;nwnnwnwnn&#34;,
            &#34;$&#34;: &#34;nwnwnwnnn&#34;,
            &#34;/&#34;: &#34;nwnwnnnwn&#34;,
            &#34;+&#34;: &#34;nwnnnwnwn&#34;,
            &#34;%&#34;: &#34;nnnwnwnwn&#34;,
        }
        # The caller should do this, or we can&#39;t rotate the thing.
        # self.set_fill_color(0)
        for c in txt.upper():
            if c not in chars:
                raise RuntimeError(f&#39;Invalid char &#34;{c}&#34; for Code39&#39;)
            for i, d in enumerate(chars[c]):
                if i % 2 == 0:
                    self.rect(x, y, dim[d], h, &#34;F&#34;)
                x += dim[d]
            x += dim[&#34;n&#34;]

    @check_page
    @contextmanager
    def rect_clip(self, x, y, w, h):
        self._out(
            (
                f&#34;q {x * self.k:.2f} {(self.h - y - h) * self.k:.2f} {w * self.k:.2f} &#34;
                f&#34;{h * self.k:.2f} re W n\n&#34;
            )
        )
        yield
        self._out(&#34;Q\n&#34;)

    @contextmanager
    def _trace_size(self, label):
        prev_size = len(self.buffer)
        yield
        LOGGER.debug(&#34;- %s.size: %s&#34;, label, _sizeof_fmt(len(self.buffer) - prev_size))

    @contextmanager
    def unbreakable(self):
        &#34;&#34;&#34;
        Ensures that all rendering performed in this context appear on a single page
        by performing page break beforehand if need be.

        Notes
        -----

        Using this method means to duplicate the FPDF `bytearray` buffer:
        when generating large PDFs, doubling memory usage may be troublesome.
        &#34;&#34;&#34;
        prev_page, prev_y = self.page, self.y
        recorder = FPDFRecorder(self, accept_page_break=False)
        LOGGER.debug(&#34;Starting unbreakable block&#34;)
        yield recorder
        y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph
        if prev_y + y_scroll &gt; self.page_break_trigger or recorder.page &gt; prev_page:
            LOGGER.debug(&#34;Performing page jump due to unbreakable height&#34;)
            recorder.rewind()
            # pylint: disable=protected-access
            # Performing this call through .pdf so that it does not get recorded &amp; replayed:
            recorder.pdf._perform_page_break()
            recorder.replay()
        LOGGER.debug(&#34;Ending unbreakable block&#34;)

    @check_page
    def insert_toc_placeholder(self, render_toc_function, pages=1):
        &#34;&#34;&#34;
        Configure Table Of Contents rendering at the end of the document generation,
        and reserve some vertical space right now in order to insert it.

        Args:
            render_toc_function (function): a function that will be invoked to render the ToC.
                This function will receive 2 parameters: `pdf`, an instance of FPDF, and `outline`,
                a list of `OutlineSection`.
            pages (int): the number of pages that the Table of Contents will span,
                including the current one that will. As many page breaks as the value of this argument
                will occur immediately after calling this method.
        &#34;&#34;&#34;
        if not callable(render_toc_function):
            raise TypeError(
                f&#34;The first argument must be a callable, got: {type(render_toc_function)}&#34;
            )
        if self._toc_placeholder:
            raise FPDFException(
                &#34;A placeholder for the table of contents has already been defined&#34;
                f&#34; on page {self._toc_placeholder.start_page}&#34;
            )
        self._toc_placeholder = ToCPlaceholder(
            render_toc_function, self.page, self.y, pages
        )
        for _ in range(pages):
            self.add_page()

    def set_section_title_styles(
        self,
        level0,
        level1=None,
        level2=None,
        level3=None,
        level4=None,
        level5=None,
        level6=None,
    ):
        &#34;&#34;&#34;
        Defines a style for section titles.
        After calling this method, calls to `start_section` will render section names visually.

        Args:
            level0 (TitleStyle): style for the top level section titles
            level1 (TitleStyle): optional style for the level 1 section titles
            level2 (TitleStyle): optional style for the level 2 section titles
            level3 (TitleStyle): optional style for the level 3 section titles
            level4 (TitleStyle): optional style for the level 4 section titles
            level5 (TitleStyle): optional style for the level 5 section titles
            level6 (TitleStyle): optional style for the level 6 section titles
        &#34;&#34;&#34;
        for level in (level0, level1, level2, level3, level4, level5, level6):
            if level and not isinstance(level, TitleStyle):
                raise TypeError(
                    f&#34;Arguments must all be TitleStyle instances, got: {type(level)}&#34;
                )
        self.section_title_styles = {
            0: level0,
            1: level1,
            2: level2,
            3: level3,
            4: level4,
            5: level5,
            6: level6,
        }

    @check_page
    def start_section(self, name, level=0):
        &#34;&#34;&#34;
        Start a section in the document outline.
        If section_title_styles have been configured,
        render the section name visually as a title.

        Args:
            name (str): section name
            level (int): section level in the document outline. 0 means top-level.
        &#34;&#34;&#34;
        if level &lt; 0:
            raise ValueError(&#39;&#34;level&#34; mut be equal or greater than zero&#39;)
        if self._outline and level &gt; self._outline[-1].level + 1:
            raise ValueError(
                f&#34;Incoherent hierarchy: cannot start a level {level} section after a level {self._outline[-1].level} one&#34;
            )
        dest = DestinationXYZ(self.page, y=self.y)
        struct_elem = None
        if self.section_title_styles:
            with self._marked_sequence(title=name) as marked_content:
                struct_elem = self.struct_builder.struct_elem_per_mc[marked_content]
                with self._apply_style(self.section_title_styles[level]):
                    self.multi_cell(w=self.epw, h=self.font_size, txt=name, ln=1)
        self._outline.append(OutlineSection(name, level, self.page, dest, struct_elem))

    @contextmanager
    def _apply_style(self, title_style):
        prev_font = (self.font_family, self.font_style, self.font_size_pt)
        self.set_font(
            title_style.font_family, title_style.font_style, title_style.font_size_pt
        )
        prev_text_color = self.text_color
        if title_style.color is not None:
            if isinstance(title_style.color, Sequence):
                self.set_text_color(*title_style.color)
            else:
                self.set_text_color(title_style.color)
        prev_underline = self.underline
        self.underline = title_style.underline
        if title_style.t_margin:
            self.ln(title_style.t_margin)
        if title_style.l_margin:
            self.set_x(title_style.l_margin)
        yield
        if title_style.b_margin:
            self.ln(title_style.b_margin)
        self.set_font(*prev_font)
        self.text_color = prev_text_color
        self.underline = prev_underline</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.FPDF.MARKDOWN_BOLD_MARKER"><code class="name">var <span class="ident">MARKDOWN_BOLD_MARKER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.FPDF.MARKDOWN_ITALICS_MARKER"><code class="name">var <span class="ident">MARKDOWN_ITALICS_MARKER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.FPDF.MARKDOWN_UNDERLINE_MARKER"><code class="name">var <span class="ident">MARKDOWN_UNDERLINE_MARKER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.FPDF.accept_page_break"><code class="name">var <span class="ident">accept_page_break</span></code></dt>
<dd>
<div class="desc"><p>Whenever a page break condition is met, this method is called,
and the break is issued or not depending on the returned value.</p>
<p>The default implementation returns a value according to the mode selected by <code>set_auto_page_break()</code>.
This method is called automatically and should not be called directly by the application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def accept_page_break(self):
    &#34;&#34;&#34;
    Whenever a page break condition is met, this method is called,
    and the break is issued or not depending on the returned value.

    The default implementation returns a value according to the mode selected by `set_auto_page_break()`.
    This method is called automatically and should not be called directly by the application.
    &#34;&#34;&#34;
    return self.auto_page_break</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.eph"><code class="name">var <span class="ident">eph</span></code></dt>
<dd>
<div class="desc"><p>Effective page height: the page height minus its vertical margins.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def eph(self):
    &#34;&#34;&#34;
    Effective page height: the page height minus its vertical margins.
    &#34;&#34;&#34;
    return self.h - self.t_margin - self.b_margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.epw"><code class="name">var <span class="ident">epw</span></code></dt>
<dd>
<div class="desc"><p>Effective page width: the page width minus its horizontal margins.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def epw(self):
    &#34;&#34;&#34;
    Effective page width: the page width minus its horizontal margins.
    &#34;&#34;&#34;
    return self.w - self.l_margin - self.r_margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.pages_count"><code class="name">var <span class="ident">pages_count</span></code></dt>
<dd>
<div class="desc"><p>Returns the total pages of the document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pages_count(self):
    &#34;&#34;&#34;
    Returns the total pages of the document.
    &#34;&#34;&#34;
    return len(self.pages)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.unifontsubset"><code class="name">var <span class="ident">unifontsubset</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unifontsubset(self):
    return self.current_font.get(&#34;type&#34;) == &#34;TTF&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.FPDF.add_action"><code class="name flex">
<span>def <span class="ident">add_action</span></span>(<span>self, action, x, y, w, h)</span>
</code></dt>
<dd>
<div class="desc"><p>Puts an Action annotation on a rectangular area of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong> :&ensp;<code><a title="fpdf.actions.Action" href="actions.html#fpdf.actions.Action">Action</a></code></dt>
<dd>the action to add</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>horizontal position (from the left) to the left side of the link rectangle</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>vertical position (from the top) to the bottom side of the link rectangle</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>width of the link rectangle</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>width of the link rectangle</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def add_action(self, action, x, y, w, h):
    &#34;&#34;&#34;
    Puts an Action annotation on a rectangular area of the page.

    Args:
        action (fpdf.actions.Action): the action to add
        x (float): horizontal position (from the left) to the left side of the link rectangle
        y (float): vertical position (from the top) to the bottom side of the link rectangle
        w (float): width of the link rectangle
        h (float): width of the link rectangle
    &#34;&#34;&#34;
    self.annots[self.page].append(
        Annotation(
            &#34;Action&#34;,
            x * self.k,
            self.h_pt - y * self.k,
            w * self.k,
            h * self.k,
            action=action,
        )
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.add_font"><code class="name flex">
<span>def <span class="ident">add_font</span></span>(<span>self, family, style='', fname=None, uni='DEPRECATED')</span>
</code></dt>
<dd>
<div class="desc"><p>Imports a TrueType or OpenType font and makes it available
for later calls to the <code>set_font()</code> method.</p>
<p><strong>Warning:</strong> there is partial support for Type1 and legacy fonts in .pkl font definition files,
generated by the <code>MakeFont</code> utility, but this feature is getting deprecated in favour of TrueType Unicode font support
(whose fonts are automatically processed with the included <code>ttfonts.py</code> module).</p>
<p>You will find more information on the "Unicode" documentation page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>family</code></strong> :&ensp;<code>str</code></dt>
<dd>font family. Used as a reference for <code>set_font()</code></dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code></dt>
<dd>font style. "B" for bold, "I" for italic.</dd>
<dt><strong><code>fname</code></strong> :&ensp;<code>str</code></dt>
<dd>font file name. You can specify a relative or full path.
If the file is not found, it will be searched in <code><a title="fpdf.FPDF_FONT_DIR" href="#fpdf.FPDF_FONT_DIR">FPDF_FONT_DIR</a></code>.</dd>
<dt><strong><code>uni</code></strong> :&ensp;<code>bool</code></dt>
<dd>[<strong>DEPRECATED</strong>] unused</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_font(self, family, style=&#34;&#34;, fname=None, uni=&#34;DEPRECATED&#34;):
    &#34;&#34;&#34;
    Imports a TrueType or OpenType font and makes it available
    for later calls to the `set_font()` method.

    **Warning:** there is partial support for Type1 and legacy fonts in .pkl font definition files,
    generated by the `MakeFont` utility, but this feature is getting deprecated in favour of TrueType Unicode font support
    (whose fonts are automatically processed with the included `ttfonts.py` module).

    You will find more information on the &#34;Unicode&#34; documentation page.

    Args:
        family (str): font family. Used as a reference for `set_font()`
        style (str): font style. &#34;B&#34; for bold, &#34;I&#34; for italic.
        fname (str): font file name. You can specify a relative or full path.
            If the file is not found, it will be searched in `FPDF_FONT_DIR`.
        uni (bool): [**DEPRECATED**] unused
    &#34;&#34;&#34;
    if uni != &#34;DEPRECATED&#34;:
        warnings.warn(
            &#39;&#34;uni&#34; parameter is deprecated, unused and will soon be removed&#39;,
            DeprecationWarning,
        )
    else:
        uni = str(fname).endswith(&#34;.ttf&#34;)
    if not fname:
        raise ValueError(&#39;&#34;fname&#34; parameter is required&#39;)
    style = &#34;&#34;.join(sorted(style.upper()))
    if any(letter not in &#34;BI&#34; for letter in style):
        raise ValueError(
            f&#34;Unknown style provided (only B &amp; I letters are allowed): {style}&#34;
        )
    fontkey = f&#34;{family.lower()}{style}&#34;

    # Check if font already added or one of the core fonts
    if fontkey in self.fonts or fontkey in self.core_fonts:
        warnings.warn(f&#34;Core font or font already added &#39;{fontkey}&#39;: doing nothing&#34;)
        return
    if uni:
        for parent in (&#34;.&#34;, FPDF_FONT_DIR):
            if not parent:
                continue
            if (Path(parent) / fname).exists():
                ttffilename = Path(parent) / fname
                break
        else:
            raise FileNotFoundError(f&#34;TTF Font file not found: {fname}&#34;)

        # include numbers in the subset! (if alias present)
        # ensure that alias is mapped 1-by-1 additionally (must be replaceable)
        sbarr = &#34;\x00 &#34;
        if self.str_alias_nb_pages:
            sbarr += &#34;0123456789&#34;
            sbarr += self.str_alias_nb_pages

        ttf = TTFontFile()
        ttf.getMetrics(ttffilename)
        desc = {
            &#34;Ascent&#34;: round(ttf.ascent),
            &#34;Descent&#34;: round(ttf.descent),
            &#34;CapHeight&#34;: round(ttf.capHeight),
            &#34;Flags&#34;: ttf.flags,
            &#34;FontBBox&#34;: (
                f&#34;[{ttf.bbox[0]:.0f} {ttf.bbox[1]:.0f}&#34;
                f&#34; {ttf.bbox[2]:.0f} {ttf.bbox[3]:.0f}]&#34;
            ),
            &#34;ItalicAngle&#34;: int(ttf.italicAngle),
            &#34;StemV&#34;: round(ttf.stemV),
            &#34;MissingWidth&#34;: round(ttf.defaultWidth),
        }

        # Generate metrics .pkl file
        font_dict = {
            &#34;type&#34;: &#34;TTF&#34;,
            &#34;name&#34;: re.sub(&#34;[ ()]&#34;, &#34;&#34;, ttf.fullName),
            &#34;desc&#34;: desc,
            &#34;up&#34;: round(ttf.underlinePosition),
            &#34;ut&#34;: round(ttf.underlineThickness),
            &#34;ttffile&#34;: ttffilename,
            &#34;fontkey&#34;: fontkey,
            &#34;originalsize&#34;: os.stat(ttffilename).st_size,
            &#34;cw&#34;: ttf.charWidths,
        }

        self.fonts[fontkey] = {
            &#34;i&#34;: len(self.fonts) + 1,
            &#34;type&#34;: font_dict[&#34;type&#34;],
            &#34;name&#34;: font_dict[&#34;name&#34;],
            &#34;desc&#34;: font_dict[&#34;desc&#34;],
            &#34;up&#34;: font_dict[&#34;up&#34;],
            &#34;ut&#34;: font_dict[&#34;ut&#34;],
            &#34;cw&#34;: font_dict[&#34;cw&#34;],
            &#34;ttffile&#34;: font_dict[&#34;ttffile&#34;],
            &#34;fontkey&#34;: fontkey,
            &#34;subset&#34;: SubsetMap(map(ord, sbarr)),
        }
        self.font_files[fontkey] = {
            &#34;length1&#34;: font_dict[&#34;originalsize&#34;],
            &#34;type&#34;: &#34;TTF&#34;,
            &#34;ttffile&#34;: ttffilename,
        }
    else:
        warnings.warn(
            &#34;Support for .pkl font files definition is deprecated, and will be removed from fpdf2 soon.&#34;
            &#34; If you require this feature, please report your need on fpdf2 GitHub project.&#34;,
            DeprecationWarning,
        )
        font_dict = pickle.loads(Path(fname).read_bytes())
        font_dict[&#34;i&#34;] = len(self.fonts) + 1
        self.fonts[fontkey] = font_dict
        diff = font_dict.get(&#34;diff&#34;)
        if diff:
            # Search existing encodings
            nb = len(self.diffs)
            for i in range(1, nb + 1):
                if self.diffs[i] == diff:
                    d = i
                    break
            else:
                d = nb + 1
                self.diffs[d] = diff
            self.fonts[fontkey][&#34;diff&#34;] = d
        filename = font_dict.get(&#34;filename&#34;)
        if filename:
            if font_dict[&#34;type&#34;] == &#34;TrueType&#34;:
                originalsize = font_dict[&#34;originalsize&#34;]
                self.font_files[filename] = {&#34;length1&#34;: originalsize}
            else:
                self.font_files[filename] = {
                    &#34;length1&#34;: font_dict[&#34;size1&#34;],
                    &#34;length2&#34;: font_dict[&#34;size2&#34;],
                }</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.add_link"><code class="name flex">
<span>def <span class="ident">add_link</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new internal link and returns its identifier.
An internal link is a clickable area which directs to another place within the document.</p>
<p>The identifier can then be passed to the <code>cell()</code>, <code>write()</code>, <code>image()</code> or <code>link()</code> methods.
The destination must be defined using <code>set_link()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_link(self):
    &#34;&#34;&#34;
    Creates a new internal link and returns its identifier.
    An internal link is a clickable area which directs to another place within the document.

    The identifier can then be passed to the `cell()`, `write()`, `image()` or `link()` methods.
    The destination must be defined using `set_link()`.
    &#34;&#34;&#34;
    n = len(self.links) + 1
    self.links[n] = DestinationXYZ(page=1)
    return n</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.add_page"><code class="name flex">
<span>def <span class="ident">add_page</span></span>(<span>self, orientation='', format='', same=False, duration=0, transition=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new page to the document.
If a page is already present, the <code>footer()</code> method is called first.
Then the page
is added, the current position is set to the top-left corner,
with respect to the left and top margins, and the <code>header()</code> method is called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>orientation</code></strong> :&ensp;<code>str</code></dt>
<dd>"portrait" (can be abbreviated "P")
or "landscape" (can be abbreviated "L"). Default to "portrait".</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>"a3", "a4", "a5", "letter", "legal" or a tuple
(width, height). Default to "a4".</dd>
<dt><strong><code>same</code></strong> :&ensp;<code>bool</code></dt>
<dd>indicates to use the same page format as the previous page.
Default to False.</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>float</code></dt>
<dd>optional page’s display duration, i.e. the maximum length of time,
in seconds, that the page is displayed in presentation mode,
before the viewer application automatically advances to the next page.
Can be configured globally through the <code>page_duration</code> FPDF property.
As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.</dd>
<dt><strong><code>transition</code></strong> :&ensp;<code>Transition child class</code></dt>
<dd>optional visual transition to use when moving
from another page to the given page during a presentation.
Can be configured globally through the <code>page_transition</code> FPDF property.
As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_page(
    self, orientation=&#34;&#34;, format=&#34;&#34;, same=False, duration=0, transition=None
):
    &#34;&#34;&#34;
    Adds a new page to the document.
    If a page is already present, the `footer()` method is called first.
    Then the page  is added, the current position is set to the top-left corner,
    with respect to the left and top margins, and the `header()` method is called.

    Args:
        orientation (str): &#34;portrait&#34; (can be abbreviated &#34;P&#34;)
            or &#34;landscape&#34; (can be abbreviated &#34;L&#34;). Default to &#34;portrait&#34;.
        format (str): &#34;a3&#34;, &#34;a4&#34;, &#34;a5&#34;, &#34;letter&#34;, &#34;legal&#34; or a tuple
            (width, height). Default to &#34;a4&#34;.
        same (bool): indicates to use the same page format as the previous page.
            Default to False.
        duration (float): optional page’s display duration, i.e. the maximum length of time,
            in seconds, that the page is displayed in presentation mode,
            before the viewer application automatically advances to the next page.
            Can be configured globally through the `page_duration` FPDF property.
            As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.
        transition (Transition child class): optional visual transition to use when moving
            from another page to the given page during a presentation.
            Can be configured globally through the `page_transition` FPDF property.
            As of june 2021, onored by Adobe Acrobat reader, but ignored by Sumatra PDF reader.
    &#34;&#34;&#34;
    if self.state == DocumentState.CLOSED:
        raise FPDFException(
            &#34;A page cannot be added on a closed document, after calling output()&#34;
        )
    if self.state == DocumentState.UNINITIALIZED:
        self.open()

    family = self.font_family
    style = f&#34;{self.font_style}U&#34; if self.underline else self.font_style
    size = self.font_size_pt
    lw = self.line_width
    dc = self.draw_color
    fc = self.fill_color
    tc = self.text_color
    stretching = self.font_stretching

    if self.page &gt; 0:
        # Page footer
        self.in_footer = 1
        self.footer()
        self.in_footer = 0
        # close page
        self._endpage()

    # Start new page
    self._beginpage(
        orientation,
        format,
        same,
        duration or self.page_duration,
        transition or self.page_transition,
        new_page=not self._has_next_page(),
    )

    self._out(&#34;2 J&#34;)  # Set line cap style to square
    self.line_width = lw  # Set line width
    self._out(f&#34;{lw * self.k:.2f} w&#34;)

    # Set font
    if family:
        self.set_font(family, style, size)

    # Set colors
    self.draw_color = dc
    if dc != &#34;0 G&#34;:
        self._out(dc)
    self.fill_color = fc
    if fc != &#34;0 g&#34;:
        self._out(fc)
    self.text_color = tc

    # BEGIN Page header
    self.header()

    if self.line_width != lw:  # Restore line width
        self.line_width = lw
        self._out(f&#34;{lw * self.k:.2f} w&#34;)

    if family:
        self.set_font(family, style, size)  # Restore font

    if self.draw_color != dc:  # Restore colors
        self.draw_color = dc
        self._out(dc)
    if self.fill_color != fc:
        self.fill_color = fc
        self._out(fc)
    self.text_color = tc

    if stretching != 100:  # Restore stretching
        self.set_stretching(stretching)
    # END Page header</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.alias_nb_pages"><code class="name flex">
<span>def <span class="ident">alias_nb_pages</span></span>(<span>self, alias='{nb}')</span>
</code></dt>
<dd>
<div class="desc"><p>Defines an alias for the total number of pages.
It will be substituted as the document is closed.</p>
<p>This is useful to insert the number of pages of the document
at a time when this number is not known by the program.</p>
<p>This substitution can be disabled for performances reasons, by caling <code>alias_nb_pages(None)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>alias</code></strong> :&ensp;<code>str</code></dt>
<dd>the alias. Defaults to "{nb}".</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>When using this feature with the <code>cell</code> / <code>multicell</code> methods,
or the <code>underline</code> attribute of <code><a title="fpdf.FPDF" href="#fpdf.FPDF">FPDF</a></code> class,
the width of the text rendered will take into account the alias length,
not the length of the "actual number of pages" string,
which can causes slight positioning differences.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alias_nb_pages(self, alias=&#34;{nb}&#34;):
    &#34;&#34;&#34;
    Defines an alias for the total number of pages.
    It will be substituted as the document is closed.

    This is useful to insert the number of pages of the document
    at a time when this number is not known by the program.

    This substitution can be disabled for performances reasons, by caling `alias_nb_pages(None)`.

    Args:
        alias (str): the alias. Defaults to &#34;{nb}&#34;.

    Notes
    -----

    When using this feature with the `cell` / `multicell` methods,
    or the `underline` attribute of `FPDF` class,
    the width of the text rendered will take into account the alias length,
    not the length of the &#34;actual number of pages&#34; string,
    which can causes slight positioning differences.
    &#34;&#34;&#34;
    self.str_alias_nb_pages = alias</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.arc"><code class="name flex">
<span>def <span class="ident">arc</span></span>(<span>self, x, y, a, start_angle, end_angle, b=None, inclination=0, clockwise=False, start_from_center=False, end_at_center=False, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs an arc.
It can be drawn (border only), filled (with no border) or both.
a (float): Semi-major axis diameter.
b (float): Semi-minor axis diameter, if None, equals to a (default: None).
start_angle (float): Start angle of the arc (in degrees).
end_angle (float): End angle of the arc (in degrees).
inclination (float): Inclination of the arc in respect of the x-axis (default: 0).
clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).
start_from_center (bool): Start drawing from the center of the circle (default: False).
end_at_center (bool): End drawing at the center of the circle (default: False).
style (str): Style of rendering. Possible values are:
* <code>D</code> or None: draw border. This is the default value.
* <code>F</code>: fill
* <code>DF</code> or <code>FD</code>: draw and fill</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arc(
    self,
    x,
    y,
    a,
    start_angle,
    end_angle,
    b=None,
    inclination=0,
    clockwise=False,
    start_from_center=False,
    end_at_center=False,
    style=None,
):
    &#34;&#34;&#34;
    Outputs an arc.
    It can be drawn (border only), filled (with no border) or both.
        a (float): Semi-major axis diameter.
        b (float): Semi-minor axis diameter, if None, equals to a (default: None).
        start_angle (float): Start angle of the arc (in degrees).
        end_angle (float): End angle of the arc (in degrees).
        inclination (float): Inclination of the arc in respect of the x-axis (default: 0).
        clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).
        start_from_center (bool): Start drawing from the center of the circle (default: False).
        end_at_center (bool): End drawing at the center of the circle (default: False).
        style (str): Style of rendering. Possible values are:
            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    op = _style_to_operator(style)

    if b is None:
        b = a

    a /= 2
    b /= 2

    cx = x + a
    cy = y + b

    # Functions used only to construct other points of the bezier curve
    def deg_to_rad(deg):
        return deg * math.pi / 180

    def angle_to_param(angle):
        angle = deg_to_rad(angle % 360)
        eta = math.atan2(math.sin(angle) / b, math.cos(angle) / a)

        if eta &lt; 0:
            eta += 2 * math.pi
        return eta

    theta = deg_to_rad(inclination)
    cos_theta = math.cos(theta)
    sin_theta = math.sin(theta)

    def evaluate(eta):
        a_cos_eta = a * math.cos(eta)
        b_sin_eta = b * math.sin(eta)

        return [
            cx + a_cos_eta * cos_theta - b_sin_eta * sin_theta,
            cy + a_cos_eta * sin_theta + b_sin_eta * cos_theta,
        ]

    def derivative_evaluate(eta):
        a_sin_eta = a * math.sin(eta)
        b_cos_eta = b * math.cos(eta)

        return [
            -a_sin_eta * cos_theta - b_cos_eta * sin_theta,
            -a_sin_eta * sin_theta + b_cos_eta * cos_theta,
        ]

    # Calculating start_eta and end_eta so that
    #   start_eta &lt; end_eta   &lt;= start_eta + 2*PI if counterclockwise
    #   end_eta   &lt; start_eta &lt;= end_eta + 2*PI   if clockwise
    start_eta = angle_to_param(start_angle)
    end_eta = angle_to_param(end_angle)

    if not clockwise and end_eta &lt;= start_eta:
        end_eta += 2 * math.pi
    elif clockwise and end_eta &gt;= start_eta:
        start_eta += 2 * math.pi

    start_point = evaluate(start_eta)

    # Move to the start point
    if start_from_center:
        self._out(f&#34;{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} m&#34;)
        self._out(
            f&#34;{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} l&#34;
        )
    else:
        self._out(
            f&#34;{start_point[0] * self.k:.2f} {(self.h - start_point[1]) * self.k:.2f} m&#34;
        )

    # Number of curves to use, maximal segment angle is 2*PI/max_curves
    max_curves = 4
    n = min(
        max_curves, math.ceil(abs(end_eta - start_eta) / (2 * math.pi / max_curves))
    )
    d_eta = (end_eta - start_eta) / n

    alpha = math.sin(d_eta) * (math.sqrt(4 + 3 * math.tan(d_eta / 2) ** 2) - 1) / 3

    eta2 = start_eta
    p2 = evaluate(eta2)
    p2_prime = derivative_evaluate(eta2)

    for i in range(n):
        p1 = p2
        p1_prime = p2_prime

        eta2 += d_eta
        p2 = evaluate(eta2)
        p2_prime = derivative_evaluate(eta2)

        control_point_1 = [p1[0] + alpha * p1_prime[0], p1[1] + alpha * p1_prime[1]]
        control_point_2 = [p2[0] - alpha * p2_prime[0], p2[1] - alpha * p2_prime[1]]

        end = &#34;&#34;
        if i == n - 1 and not end_at_center:
            end = f&#34; {op}&#34;

        self._out(
            (
                f&#34;{control_point_1[0] * self.k:.2f} {(self.h - control_point_1[1]) * self.k:.2f} &#34;
                f&#34;{control_point_2[0] * self.k:.2f} {(self.h - control_point_2[1]) * self.k:.2f} &#34;
                f&#34;{p2[0] * self.k:.2f} {(self.h - p2[1]) * self.k:.2f} c&#34; + end
            )
        )

    if end_at_center:
        self._out(f&#34;{cx * self.k:.2f} {(self.h - cy) * self.k:.2f} l {op}&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.cell"><code class="name flex">
<span>def <span class="ident">cell</span></span>(<span>self, w=None, h=None, txt='', border=0, ln=0, align='', fill=False, link='', center=False, markdown=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a cell (rectangular area) with optional borders, background color and
character string. The upper-left corner of the cell corresponds to the current
position. The text can be aligned or centered. After the call, the current
position moves to the right or to the next line. It is possible to put a link
on the text.</p>
<p>If automatic page breaking is enabled and the cell goes beyond the limit, a
page break is performed before outputting.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>Cell width. Default value: None, meaning to fit text width.
If 0, the cell extends up to the right margin.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>Cell height. Default value: None, meaning an height equal
to the current font size.</dd>
<dt><strong><code>txt</code></strong> :&ensp;<code>str</code></dt>
<dd>String to print. Default value: empty string.</dd>
<dt><strong><code>border</code></strong></dt>
<dd>Indicates if borders must be drawn around the cell.
The value can be either a number (<code>0</code>: no border ; <code>1</code>: frame)
or a string containing some or all of the following characters
(in any order):
<code>L</code>: left ; <code>T</code>: top ; <code>R</code>: right ; <code>B</code>: bottom. Default value: 0.</dd>
<dt><strong><code>ln</code></strong> :&ensp;<code>int</code></dt>
<dd>Indicates where the current position should go after the call.
Possible values are: <code>0</code>: to the right ; <code>1</code>: to the beginning of the
next line ; <code>2</code>: below. Putting 1 is equivalent to putting 0 and calling
<code>ln</code> just after. Default value: 0.</dd>
<dt><strong><code>align</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows to center or align the text inside the cell.
Possible values are: <code>L</code> or empty string: left align (default value) ;
<code>C</code>: center ; <code>R</code>: right align</dd>
<dt><strong><code>fill</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the cell background must be painted (<code>True</code>)
or transparent (<code>False</code>). Default value: False.</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str</code></dt>
<dd>optional link to add on the cell, internal
(identifier returned by <code>add_link</code>) or external URL.</dd>
<dt><strong><code>center</code></strong> :&ensp;<code>bool</code></dt>
<dd>center the cell horizontally in the page</dd>
<dt><strong><code>markdown</code></strong> :&ensp;<code>bool</code></dt>
<dd>enable minimal markdown-like markup to render part
of text as bold / italics / underlined. Default to False.</dd>
</dl>
<p>Returns: a boolean indicating if page break was triggered</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def cell(
    self,
    w=None,
    h=None,
    txt=&#34;&#34;,
    border=0,
    ln=0,
    align=&#34;&#34;,
    fill=False,
    link=&#34;&#34;,
    center=False,
    markdown=False,
):
    &#34;&#34;&#34;
    Prints a cell (rectangular area) with optional borders, background color and
    character string. The upper-left corner of the cell corresponds to the current
    position. The text can be aligned or centered. After the call, the current
    position moves to the right or to the next line. It is possible to put a link
    on the text.

    If automatic page breaking is enabled and the cell goes beyond the limit, a
    page break is performed before outputting.

    Args:
        w (float): Cell width. Default value: None, meaning to fit text width.
            If 0, the cell extends up to the right margin.
        h (float): Cell height. Default value: None, meaning an height equal
            to the current font size.
        txt (str): String to print. Default value: empty string.
        border: Indicates if borders must be drawn around the cell.
            The value can be either a number (`0`: no border ; `1`: frame)
            or a string containing some or all of the following characters
            (in any order):
            `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
        ln (int): Indicates where the current position should go after the call.
            Possible values are: `0`: to the right ; `1`: to the beginning of the
            next line ; `2`: below. Putting 1 is equivalent to putting 0 and calling
            `ln` just after. Default value: 0.
        align (str): Allows to center or align the text inside the cell.
            Possible values are: `L` or empty string: left align (default value) ;
            `C`: center ; `R`: right align
        fill (bool): Indicates if the cell background must be painted (`True`)
            or transparent (`False`). Default value: False.
        link (str): optional link to add on the cell, internal
            (identifier returned by `add_link`) or external URL.
        center (bool): center the cell horizontally in the page
        markdown (bool): enable minimal markdown-like markup to render part
            of text as bold / italics / underlined. Default to False.

    Returns: a boolean indicating if page break was triggered
    &#34;&#34;&#34;
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    if isinstance(w, str) or isinstance(h, str):
        raise ValueError(
            &#34;Parameter &#39;w&#39; and &#39;h&#39; must be numbers, not strings.&#34;
            &#34; You can omit them by passing string content with txt=&#34;
        )
    if isinstance(border, int) and border not in (0, 1):
        warnings.warn(
            &#39;Integer values for &#34;border&#34; parameter other than 1 are currently &#39;
            &#34;ignored&#34;
        )
        border = 1
    new_x = XPos.RIGHT
    new_y = YPos.TOP
    if ln == 1:
        new_x = XPos.LMARGIN
        new_y = YPos.NEXT
    elif ln == 2:
        new_x = XPos.LEFT
        new_y = YPos.NEXT
    # Font styles preloading must be performed before any call to FPDF.get_string_width:
    txt = self.normalize_text(txt)
    styled_txt_frags = self._preload_font_styles(txt, markdown)
    return self._render_styled_cell_text(
        TextLine(
            styled_txt_frags,
            text_width=0.0,
            number_of_spaces_between_words=0,
            justify=False,
        ),
        w,
        h,
        border,
        new_x=new_x,
        new_y=new_y,
        align=align,
        fill=fill,
        link=link,
        center=center,
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.circle"><code class="name flex">
<span>def <span class="ident">circle</span></span>(<span>self, x, y, r, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs a circle.
It can be drawn (border only), filled (with no border) or both.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of upper-left bounging box.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of upper-left bounging box.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius of the circle.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code></dt>
<dd>Style of rendering. Possible values are:
* <code>D</code> or None: draw border. This is the default value.
* <code>F</code>: fill
* <code>DF</code> or <code>FD</code>: draw and fill</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def circle(self, x, y, r, style=None):
    &#34;&#34;&#34;
    Outputs a circle.
    It can be drawn (border only), filled (with no border) or both.

    Args:
        x (float): Abscissa of upper-left bounging box.
        y (float): Ordinate of upper-left bounging box.
        r (float): Radius of the circle.
        style (str): Style of rendering. Possible values are:
            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    self.ellipse(x, y, r, r, style)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Terminates the PDF document.</p>
<p>It is not necessary to call this method explicitly because <code>output()</code> does it automatically.
If the document contains no page, <code>add_page()</code> is called to prevent from generating an invalid document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Terminates the PDF document.

    It is not necessary to call this method explicitly because `output()` does it automatically.
    If the document contains no page, `add_page()` is called to prevent from generating an invalid document.
    &#34;&#34;&#34;
    if self.state == DocumentState.CLOSED:
        return
    if self.page == 0:
        self.add_page()

    # Page footer
    self.in_footer = 1
    self.footer()
    self.in_footer = 0

    self._endpage()  # close page
    self._enddoc()  # close document</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.code39"><code class="name flex">
<span>def <span class="ident">code39</span></span>(<span>self, txt, x, y, w=1.5, h=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Barcode 3of9</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def code39(self, txt, x, y, w=1.5, h=5):
    &#34;&#34;&#34;Barcode 3of9&#34;&#34;&#34;
    dim = {&#34;w&#34;: w, &#34;n&#34;: w / 3}
    if not txt.startswith(&#34;*&#34;) or not txt.endswith(&#34;*&#34;):
        warnings.warn(
            &#34;Code 39 input must start and end with a &#39;*&#39; character to be valid.&#34;
            &#34; This method does not insert it automatically.&#34;
        )
    chars = {
        &#34;0&#34;: &#34;nnnwwnwnn&#34;,
        &#34;1&#34;: &#34;wnnwnnnnw&#34;,
        &#34;2&#34;: &#34;nnwwnnnnw&#34;,
        &#34;3&#34;: &#34;wnwwnnnnn&#34;,
        &#34;4&#34;: &#34;nnnwwnnnw&#34;,
        &#34;5&#34;: &#34;wnnwwnnnn&#34;,
        &#34;6&#34;: &#34;nnwwwnnnn&#34;,
        &#34;7&#34;: &#34;nnnwnnwnw&#34;,
        &#34;8&#34;: &#34;wnnwnnwnn&#34;,
        &#34;9&#34;: &#34;nnwwnnwnn&#34;,
        &#34;A&#34;: &#34;wnnnnwnnw&#34;,
        &#34;B&#34;: &#34;nnwnnwnnw&#34;,
        &#34;C&#34;: &#34;wnwnnwnnn&#34;,
        &#34;D&#34;: &#34;nnnnwwnnw&#34;,
        &#34;E&#34;: &#34;wnnnwwnnn&#34;,
        &#34;F&#34;: &#34;nnwnwwnnn&#34;,
        &#34;G&#34;: &#34;nnnnnwwnw&#34;,
        &#34;H&#34;: &#34;wnnnnwwnn&#34;,
        &#34;I&#34;: &#34;nnwnnwwnn&#34;,
        &#34;J&#34;: &#34;nnnnwwwnn&#34;,
        &#34;K&#34;: &#34;wnnnnnnww&#34;,
        &#34;L&#34;: &#34;nnwnnnnww&#34;,
        &#34;M&#34;: &#34;wnwnnnnwn&#34;,
        &#34;N&#34;: &#34;nnnnwnnww&#34;,
        &#34;O&#34;: &#34;wnnnwnnwn&#34;,
        &#34;P&#34;: &#34;nnwnwnnwn&#34;,
        &#34;Q&#34;: &#34;nnnnnnwww&#34;,
        &#34;R&#34;: &#34;wnnnnnwwn&#34;,
        &#34;S&#34;: &#34;nnwnnnwwn&#34;,
        &#34;T&#34;: &#34;nnnnwnwwn&#34;,
        &#34;U&#34;: &#34;wwnnnnnnw&#34;,
        &#34;V&#34;: &#34;nwwnnnnnw&#34;,
        &#34;W&#34;: &#34;wwwnnnnnn&#34;,
        &#34;X&#34;: &#34;nwnnwnnnw&#34;,
        &#34;Y&#34;: &#34;wwnnwnnnn&#34;,
        &#34;Z&#34;: &#34;nwwnwnnnn&#34;,
        &#34;-&#34;: &#34;nwnnnnwnw&#34;,
        &#34;.&#34;: &#34;wwnnnnwnn&#34;,
        &#34; &#34;: &#34;nwwnnnwnn&#34;,
        &#34;*&#34;: &#34;nwnnwnwnn&#34;,
        &#34;$&#34;: &#34;nwnwnwnnn&#34;,
        &#34;/&#34;: &#34;nwnwnnnwn&#34;,
        &#34;+&#34;: &#34;nwnnnwnwn&#34;,
        &#34;%&#34;: &#34;nnnwnwnwn&#34;,
    }
    # The caller should do this, or we can&#39;t rotate the thing.
    # self.set_fill_color(0)
    for c in txt.upper():
        if c not in chars:
            raise RuntimeError(f&#39;Invalid char &#34;{c}&#34; for Code39&#39;)
        for i, d in enumerate(chars[c]):
            if i % 2 == 0:
                self.rect(x, y, dim[d], h, &#34;F&#34;)
            x += dim[d]
        x += dim[&#34;n&#34;]</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.dashed_line"><code class="name flex">
<span>def <span class="ident">dashed_line</span></span>(<span>self, x1, y1, x2, y2, dash_length=1, space_length=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a dashed line between two points.
<strong>DEPRECATED</strong> 2.4.6
- use set_dash_pattern() and the normal drawing operations instead</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of first point</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of first point</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of second point</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of second point</dd>
<dt><strong><code>dash_length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the dash</dd>
<dt><strong><code>space_length</code></strong> :&ensp;<code>float</code></dt>
<dd>Length of the space between 2 dashes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def dashed_line(self, x1, y1, x2, y2, dash_length=1, space_length=1):
    &#34;&#34;&#34;
    Draw a dashed line between two points.
    **DEPRECATED** 2.4.6
    - use set_dash_pattern() and the normal drawing operations instead

    Args:
        x1 (float): Abscissa of first point
        y1 (float): Ordinate of first point
        x2 (float): Abscissa of second point
        y2 (float): Ordinate of second point
        dash_length (float): Length of the dash
        space_length (float): Length of the space between 2 dashes
    &#34;&#34;&#34;
    warnings.warn(
        &#34;dashed_line() is deprecated, and will be removed in a future release. &#34;
        &#34;Use set_dash_pattern() and the normal drawing operations instead.&#34;,
        DeprecationWarning,
    )
    self.set_dash_pattern(dash_length, space_length)
    self.line(x1, y1, x2, y2)
    self.set_dash_pattern()</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.draw_path"><code class="name flex">
<span>def <span class="ident">draw_path</span></span>(<span>self, path, debug_stream=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a pre-constructed path to the document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code><a title="fpdf.drawing.PaintedPath" href="drawing.html#fpdf.drawing.PaintedPath">PaintedPath</a></code></dt>
<dd>the path to be drawn.</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>TextIO</code></dt>
<dd>print a pretty tree of all items to be rendered
to the provided stream. To store the output in a string, use
<code>io.StringIO</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_path(self, path, debug_stream=None):
    &#34;&#34;&#34;
    Add a pre-constructed path to the document.

    Args:
        path (drawing.PaintedPath): the path to be drawn.
        debug_stream (TextIO): print a pretty tree of all items to be rendered
            to the provided stream. To store the output in a string, use
            `io.StringIO`.
    &#34;&#34;&#34;
    with self.drawing_context(debug_stream=debug_stream) as ctxt:
        ctxt.add_item(path)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.drawing_context"><code class="name flex">
<span>def <span class="ident">drawing_context</span></span>(<span>self, debug_stream=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a context for drawing paths on the current page.</p>
<p>If this context manager is called again inside of an active context, it will
raise an exception, as base drawing contexts cannot be nested.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>TextIO</code></dt>
<dd>print a pretty tree of all items to be rendered
to the provided stream. To store the output in a string, use
<code>io.StringIO</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
@check_page
def drawing_context(self, debug_stream=None):
    &#34;&#34;&#34;
    Create a context for drawing paths on the current page.

    If this context manager is called again inside of an active context, it will
    raise an exception, as base drawing contexts cannot be nested.

    Args:
        debug_stream (TextIO): print a pretty tree of all items to be rendered
            to the provided stream. To store the output in a string, use
            `io.StringIO`.
    &#34;&#34;&#34;

    if self._current_draw_context is not None:
        raise FPDFException(
            &#34;cannot create a drawing context while one is already open&#34;
        )

    context = drawing.DrawingContext()
    self._current_draw_context = context
    try:
        yield context
    finally:
        self._current_draw_context = None

    starting_style = drawing.GraphicsStyle()
    starting_style.allow_transparency = self.allow_images_transparency
    starting_style.stroke_width = self.line_width

    dash_info = self.dash_pattern
    dash_pattern = (dash_info[&#34;dash&#34;], dash_info[&#34;gap&#34;])
    if (dash_pattern[0] == 0) or (dash_pattern[1] == 0):
        dash_pattern = None

    starting_style.stroke_dash_pattern = dash_pattern
    starting_style.stroke_dash_phase = dash_info[&#34;phase&#34;]

    render_args = (
        self._drawing_graphics_state_registry,
        drawing.Point(self.x, self.y),
        self.k,
        self.h,
        starting_style,
    )

    if debug_stream:
        rendered = context.render_debug(*render_args, debug_stream)
    else:
        rendered = context.render(*render_args)

    self._out(rendered)

    self.pdf_version = max(self.pdf_version, &#34;1.4&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>self, x, y, w, h, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs an ellipse.
It can be drawn (border only), filled (with no border) or both.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of upper-left bounging box.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of upper-left bounging box.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>Width.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>Height.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code></dt>
<dd>Style of rendering. Possible values are:
* <code>D</code> or empty string: draw border. This is the default value.
* <code>F</code>: fill
* <code>DF</code> or <code>FD</code>: draw and fill</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def ellipse(self, x, y, w, h, style=None):
    &#34;&#34;&#34;
    Outputs an ellipse.
    It can be drawn (border only), filled (with no border) or both.

    Args:
        x (float): Abscissa of upper-left bounging box.
        y (float): Ordinate of upper-left bounging box.
        w (float): Width.
        h (float): Height.
        style (str): Style of rendering. Possible values are:
            * `D` or empty string: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    op = _style_to_operator(style)

    cx = x + w / 2
    cy = y + h / 2
    rx = w / 2
    ry = h / 2

    lx = 4 / 3 * (math.sqrt(2) - 1) * rx
    ly = 4 / 3 * (math.sqrt(2) - 1) * ry

    self._out(
        (
            f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} m &#34;
            f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} &#34;
            f&#34;{(cx + lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} &#34;
            f&#34;{cx * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} c&#34;
        )
    )
    self._out(
        (
            f&#34;{(cx - lx) * self.k:.2f} {(self.h - cy + ry) * self.k:.2f} &#34;
            f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy + ly) * self.k:.2f} &#34;
            f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c&#34;
        )
    )
    self._out(
        (
            f&#34;{(cx - rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} &#34;
            f&#34;{(cx - lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} &#34;
            f&#34;{cx * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} c&#34;
        )
    )
    self._out(
        (
            f&#34;{(cx + lx) * self.k:.2f} {(self.h - cy - ry) * self.k:.2f} &#34;
            f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy - ly) * self.k:.2f} &#34;
            f&#34;{(cx + rx) * self.k:.2f} {(self.h - cy) * self.k:.2f} c {op}&#34;
        )
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.footer"><code class="name flex">
<span>def <span class="ident">footer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Footer to be implemented in your own inherited class.</p>
<p>This is automatically called by <code>add_page()</code> and <code>close()</code>
and should not be called directly by the user application.
The default implementation performs nothing: you have to override this method
in a subclass to implement your own rendering logic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def footer(self):
    &#34;&#34;&#34;
    Footer to be implemented in your own inherited class.

    This is automatically called by `add_page()` and `close()`
    and should not be called directly by the user application.
    The default implementation performs nothing: you have to override this method
    in a subclass to implement your own rendering logic.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.get_normalized_string_width_with_style"><code class="name flex">
<span>def <span class="ident">get_normalized_string_width_with_style</span></span>(<span>self, string, style)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the length of a string with given style</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>string</code></strong> :&ensp;<code>str</code></dt>
<dd>the string whose length is to be computed.</dd>
</dl>
<p>style (str) : the string representing the style</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_normalized_string_width_with_style(self, string, style):
    &#34;&#34;&#34;
    Returns the length of a string with given style

    Args:
        string (str): the string whose length is to be computed.
        style (str) : the string representing the style
    &#34;&#34;&#34;
    w = 0
    font = self.fonts[self.font_family + style]
    if self.unifontsubset:
        for char in string:
            w += _char_width(font, ord(char))
    else:
        w += sum(_char_width(font, char) for char in string)
    return w</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.get_string_width"><code class="name flex">
<span>def <span class="ident">get_string_width</span></span>(<span>self, s, normalized=False, markdown=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the length of a string in user unit. A font must be selected.
The value is calculated with stretching and spacing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong> :&ensp;<code>str</code></dt>
<dd>the string whose length is to be computed.</dd>
<dt><strong><code>normalized</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether normalization needs to be performed on the input string.</dd>
<dt><strong><code>markdown</code></strong> :&ensp;<code>bool</code></dt>
<dd>indicates if basic markdown support is enabled</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_string_width(self, s, normalized=False, markdown=False):
    &#34;&#34;&#34;
    Returns the length of a string in user unit. A font must be selected.
    The value is calculated with stretching and spacing.

    Args:
        s (str): the string whose length is to be computed.
        normalized (bool): whether normalization needs to be performed on the input string.
        markdown (bool): indicates if basic markdown support is enabled
    &#34;&#34;&#34;
    # normalized is parameter for internal use
    s = s if normalized else self.normalize_text(s)
    w = 0
    for frag in (
        self._markdown_parse(s)
        if markdown
        else (Fragment.from_string(s, self.font_style, bool(self.underline)),)
    ):
        w += self.get_normalized_string_width_with_style(frag.string, frag.style)
    if self.font_stretching != 100:
        w *= self.font_stretching / 100
    return w * self.font_size / 1000</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.get_x"><code class="name flex">
<span>def <span class="ident">get_x</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the abscissa of the current position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_x(self):
    &#34;&#34;&#34;Returns the abscissa of the current position.&#34;&#34;&#34;
    return self.x</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.get_y"><code class="name flex">
<span>def <span class="ident">get_y</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the ordinate of the current position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_y(self):
    &#34;&#34;&#34;Returns the ordinate of the current position.&#34;&#34;&#34;
    return self.y</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Header to be implemented in your own inherited class</p>
<p>This is automatically called by <code>add_page()</code>
and should not be called directly by the user application.
The default implementation performs nothing: you have to override this method
in a subclass to implement your own rendering logic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self):
    &#34;&#34;&#34;
    Header to be implemented in your own inherited class

    This is automatically called by `add_page()`
    and should not be called directly by the user application.
    The default implementation performs nothing: you have to override this method
    in a subclass to implement your own rendering logic.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>self, name, x=None, y=None, w=0, h=0, type='', link='', title=None, alt_text=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Put an image on the page.</p>
<p>The size of the image on the page can be specified in different ways:
* explicit width and height (expressed in user units)
* one explicit dimension, the other being calculated automatically
in order to keep the original proportions
* no explicit dimension, in which case the image is put at 72 dpi.</p>
<p><strong>Remarks</strong>:
* if an image is used several times, only one copy is embedded in the file.
* when using an animated GIF, only the first frame is used.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>either a string representing a file path to an image, an URL to an image,
an io.BytesIO, or a instance of <code>PIL.Image.Image</code></dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>optional horizontal position where to put the image on the page.
If not specified or equal to None, the current abscissa is used.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>optional vertical position where to put the image on the page.
If not specified or equal to None, the current ordinate is used.
After the call, the current ordinate is moved to the bottom of the image</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>optional width of the image. If not specified or equal to zero,
it is automatically calculated from the image size.
Pass <code>pdf.epw</code> to scale horizontally to the full page width.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>optional height of the image. If not specified or equal to zero,
it is automatically calculated from the image size.
Pass <code>pdf.eph</code> to scale horizontally to the full page height.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED</strong>] unused, will be removed in a later version.</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str</code></dt>
<dd>optional link to add on the image, internal
(identifier returned by <code>add_link</code>) or external URL.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>optional. Currently, never seem rendered by PDF readers.</dd>
<dt><strong><code>alt_text</code></strong> :&ensp;<code>str</code></dt>
<dd>optional alternative text describing the image,
for accessibility purposes. Displayed by some PDF readers on hover.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def image(
    self,
    name,
    x=None,
    y=None,
    w=0,
    h=0,
    type=&#34;&#34;,
    link=&#34;&#34;,
    title=None,
    alt_text=None,
):
    &#34;&#34;&#34;
    Put an image on the page.

    The size of the image on the page can be specified in different ways:
    * explicit width and height (expressed in user units)
    * one explicit dimension, the other being calculated automatically
      in order to keep the original proportions
    * no explicit dimension, in which case the image is put at 72 dpi.

    **Remarks**:
    * if an image is used several times, only one copy is embedded in the file.
    * when using an animated GIF, only the first frame is used.

    Args:
        name: either a string representing a file path to an image, an URL to an image,
            an io.BytesIO, or a instance of `PIL.Image.Image`
        x (float): optional horizontal position where to put the image on the page.
            If not specified or equal to None, the current abscissa is used.
        y (float): optional vertical position where to put the image on the page.
            If not specified or equal to None, the current ordinate is used.
            After the call, the current ordinate is moved to the bottom of the image
        w (float): optional width of the image. If not specified or equal to zero,
            it is automatically calculated from the image size.
            Pass `pdf.epw` to scale horizontally to the full page width.
        h (float): optional height of the image. If not specified or equal to zero,
            it is automatically calculated from the image size.
            Pass `pdf.eph` to scale horizontally to the full page height.
        type (str): [**DEPRECATED**] unused, will be removed in a later version.
        link (str): optional link to add on the image, internal
            (identifier returned by `add_link`) or external URL.
        title (str): optional. Currently, never seem rendered by PDF readers.
        alt_text (str): optional alternative text describing the image,
            for accessibility purposes. Displayed by some PDF readers on hover.
    &#34;&#34;&#34;
    if type:
        warnings.warn(
            &#39;&#34;type&#34; parameter is deprecated, unused and will soon be removed&#39;,
            DeprecationWarning,
        )
    if str(name).endswith(&#34;.svg&#34;):
        # Insert it as a PDF path:
        img = load_image(str(name))
        return self._vector_image(img, x, y, w, h, link, title, alt_text)
    if isinstance(name, str):
        img = None
    elif isinstance(name, Image.Image):
        bytes = name.tobytes()
        # disabling bandit rule as we just build a cache key, this is secure
        name, img = hashlib.md5(bytes).hexdigest(), name  # nosec B303 B324
    elif isinstance(name, io.BytesIO):
        if _is_xml(name):
            return self._vector_image(name, x, y, w, h, link, title, alt_text)
        bytes = name.getvalue()
        # disabling bandit rule as we just build a cache key, this is secure
        name, img = hashlib.md5(bytes).hexdigest(), name  # nosec B303 B324
    else:
        name, img = str(name), name
    info = self.images.get(name)
    if info:
        info[&#34;usages&#34;] += 1
    else:
        if not img:
            img = load_image(name)
        info = get_img_info(img, self.image_filter)
        info[&#34;i&#34;] = len(self.images) + 1
        info[&#34;usages&#34;] = 1
        self.images[name] = info

    # Automatic width and height calculation if needed
    if w == 0 and h == 0:  # Put image at 72 dpi
        w = info[&#34;w&#34;] / self.k
        h = info[&#34;h&#34;] / self.k
    elif w == 0:
        w = h * info[&#34;w&#34;] / info[&#34;h&#34;]
    elif h == 0:
        h = w * info[&#34;h&#34;] / info[&#34;w&#34;]

    if self.oversized_images and info[&#34;usages&#34;] == 1:
        info = self._downscale_image(name, img, info, w, h)

    # Flowing mode
    if y is None:
        self._perform_page_break_if_need_be(h)
        y = self.y
        self.y += h
    if x is None:
        x = self.x

    stream_content = (
        f&#34;q {w * self.k:.2f} 0 0 {h * self.k:.2f} {x * self.k:.2f} &#34;
        f&#34;{(self.h - y - h) * self.k:.2f} cm /I{info[&#39;i&#39;]} Do Q&#34;
    )
    if title or alt_text:
        with self._marked_sequence(title=title, alt_text=alt_text):
            self._out(stream_content)
    else:
        self._out(stream_content)
    if link:
        self.link(x, y, w, h, link)

    return info</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.insert_toc_placeholder"><code class="name flex">
<span>def <span class="ident">insert_toc_placeholder</span></span>(<span>self, render_toc_function, pages=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure Table Of Contents rendering at the end of the document generation,
and reserve some vertical space right now in order to insert it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>render_toc_function</code></strong> :&ensp;<code>function</code></dt>
<dd>a function that will be invoked to render the ToC.
This function will receive 2 parameters: <code>pdf</code>, an instance of FPDF, and <code><a title="fpdf.outline" href="outline.html">fpdf.outline</a></code>,
a list of <code>OutlineSection</code>.</dd>
<dt><strong><code>pages</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of pages that the Table of Contents will span,
including the current one that will. As many page breaks as the value of this argument
will occur immediately after calling this method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def insert_toc_placeholder(self, render_toc_function, pages=1):
    &#34;&#34;&#34;
    Configure Table Of Contents rendering at the end of the document generation,
    and reserve some vertical space right now in order to insert it.

    Args:
        render_toc_function (function): a function that will be invoked to render the ToC.
            This function will receive 2 parameters: `pdf`, an instance of FPDF, and `outline`,
            a list of `OutlineSection`.
        pages (int): the number of pages that the Table of Contents will span,
            including the current one that will. As many page breaks as the value of this argument
            will occur immediately after calling this method.
    &#34;&#34;&#34;
    if not callable(render_toc_function):
        raise TypeError(
            f&#34;The first argument must be a callable, got: {type(render_toc_function)}&#34;
        )
    if self._toc_placeholder:
        raise FPDFException(
            &#34;A placeholder for the table of contents has already been defined&#34;
            f&#34; on page {self._toc_placeholder.start_page}&#34;
        )
    self._toc_placeholder = ToCPlaceholder(
        render_toc_function, self.page, self.y, pages
    )
    for _ in range(pages):
        self.add_page()</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.interleaved2of5"><code class="name flex">
<span>def <span class="ident">interleaved2of5</span></span>(<span>self, txt, x, y, w=1, h=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Barcode I2of5 (numeric), adds a 0 if odd length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def interleaved2of5(self, txt, x, y, w=1, h=10):
    &#34;&#34;&#34;Barcode I2of5 (numeric), adds a 0 if odd length&#34;&#34;&#34;
    narrow = w / 3
    wide = w

    # wide/narrow codes for the digits
    bar_char = {
        &#34;0&#34;: &#34;nnwwn&#34;,
        &#34;1&#34;: &#34;wnnnw&#34;,
        &#34;2&#34;: &#34;nwnnw&#34;,
        &#34;3&#34;: &#34;wwnnn&#34;,
        &#34;4&#34;: &#34;nnwnw&#34;,
        &#34;5&#34;: &#34;wnwnn&#34;,
        &#34;6&#34;: &#34;nwwnn&#34;,
        &#34;7&#34;: &#34;nnnww&#34;,
        &#34;8&#34;: &#34;wnnwn&#34;,
        &#34;9&#34;: &#34;nwnwn&#34;,
        &#34;A&#34;: &#34;nn&#34;,
        &#34;Z&#34;: &#34;wn&#34;,
    }
    # The caller should do this, or we can&#39;t rotate the thing.
    # self.set_fill_color(0)
    code = txt
    # add leading zero if code-length is odd
    if len(code) % 2 != 0:
        code = f&#34;0{code}&#34;

    # add start and stop codes
    code = f&#34;AA{code.lower()}ZA&#34;

    for i in range(0, len(code), 2):
        # choose next pair of digits
        char_bar = code[i]
        char_space = code[i + 1]
        # check whether it is a valid digit
        if char_bar not in bar_char:
            raise RuntimeError(f&#39;Char &#34;{char_bar}&#34; invalid for I25:&#39;)
        if char_space not in bar_char:
            raise RuntimeError(f&#39;Char &#34;{char_space}&#34; invalid for I25: &#39;)

        # create a wide/narrow-seq (first digit=bars, second digit=spaces)
        seq = &#34;&#34;.join(
            f&#34;{cb}{cs}&#34; for cb, cs in zip(bar_char[char_bar], bar_char[char_space])
        )

        for bar_index, char in enumerate(seq):
            # set line_width depending on value
            line_width = narrow if char == &#34;n&#34; else wide

            # draw every second value, the other is represented by space
            if bar_index % 2 == 0:
                self.rect(x, y, line_width, h, &#34;F&#34;)

            x += line_width</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>self, x1, y1, x2, y2)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a line between two points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of first point</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of first point</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of second point</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of second point</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def line(self, x1, y1, x2, y2):
    &#34;&#34;&#34;
    Draw a line between two points.

    Args:
        x1 (float): Abscissa of first point
        y1 (float): Ordinate of first point
        x2 (float): Abscissa of second point
        y2 (float): Ordinate of second point
    &#34;&#34;&#34;
    self._out(
        f&#34;{x1 * self.k:.2f} {(self.h - y1) * self.k:.2f} m {x2 * self.k:.2f} &#34;
        f&#34;{(self.h - y2) * self.k:.2f} l S&#34;
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.link"><code class="name flex">
<span>def <span class="ident">link</span></span>(<span>self, x, y, w, h, link, alt_text=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Puts a link annotation on a rectangular area of the page.
Text or image links are generally put via <a href="#fpdf.FPDF.cell">cell</a>,
<a href="#fpdf.FPDF.write">write</a> or <a href="#fpdf.FPDF.image">image</a>,
but this method can be useful for instance to define a clickable area inside an image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>horizontal position (from the left) to the left side of the link rectangle</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>vertical position (from the top) to the bottom side of the link rectangle</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>width of the link rectangle</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>width of the link rectangle</dd>
<dt><strong><code>link</code></strong></dt>
<dd>either an URL or a integer returned by <code>add_link</code>, defining an internal link to a page</dd>
<dt><strong><code>alt_text</code></strong> :&ensp;<code>str</code></dt>
<dd>optional textual description of the link, for accessibility purposes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def link(self, x, y, w, h, link, alt_text=None):
    &#34;&#34;&#34;
    Puts a link annotation on a rectangular area of the page.
    Text or image links are generally put via [cell](#fpdf.FPDF.cell),
    [write](#fpdf.FPDF.write) or [image](#fpdf.FPDF.image),
    but this method can be useful for instance to define a clickable area inside an image.

    Args:
        x (float): horizontal position (from the left) to the left side of the link rectangle
        y (float): vertical position (from the top) to the bottom side of the link rectangle
        w (float): width of the link rectangle
        h (float): width of the link rectangle
        link: either an URL or a integer returned by `add_link`, defining an internal link to a page
        alt_text (str): optional textual description of the link, for accessibility purposes
    &#34;&#34;&#34;
    self.annots[self.page].append(
        Annotation(
            &#34;Link&#34;,
            x * self.k,
            self.h_pt - y * self.k,
            w * self.k,
            h * self.k,
            link=link,
            alt_text=alt_text,
        )
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.ln"><code class="name flex">
<span>def <span class="ident">ln</span></span>(<span>self, h=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Line Feed.
The current abscissa goes back to the left margin and the ordinate increases by
the amount passed as parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>The height of the break.
By default, the value equals the height of the last printed cell.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def ln(self, h=None):
    &#34;&#34;&#34;
    Line Feed.
    The current abscissa goes back to the left margin and the ordinate increases by
    the amount passed as parameter.

    Args:
        h (float): The height of the break.
            By default, the value equals the height of the last printed cell.
    &#34;&#34;&#34;
    self.x = self.l_margin
    self.y += self.lasth if h is None else h</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.local_context"><code class="name flex">
<span>def <span class="ident">local_context</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a local grapics state, which won't affect the surrounding code.
This method must be used as a context manager using <code>with</code>:</p>
<pre><code>with pdf.local_context():
    set_some_state()
    draw_some_stuff()
</code></pre>
<p>The affected settings are:
draw_color
fill_color
text_color
underline
font_style
font_stretching
font_family
font_size_pt
font_size
dash_pattern
line_width</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
@contextmanager
def local_context(self):
    &#34;&#34;&#34;
    Create a local grapics state, which won&#39;t affect the surrounding code.
    This method must be used as a context manager using `with`:

        with pdf.local_context():
            set_some_state()
            draw_some_stuff()

    The affected settings are:
        draw_color
        fill_color
        text_color
        underline
        font_style
        font_stretching
        font_family
        font_size_pt
        font_size
        dash_pattern
        line_width
    &#34;&#34;&#34;
    self._push_local_stack()
    self._out(&#34;\nq &#34;)
    yield
    self._out(&#34; Q\n&#34;)
    self._pop_local_stack()</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.multi_cell"><code class="name flex">
<span>def <span class="ident">multi_cell</span></span>(<span>self, w, h=None, txt='', border=0, align='J', fill=False, split_only=False, link='', ln=0, max_line_height=None, markdown=False, print_sh=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This method allows printing text with line breaks. They can be automatic
(breaking at the most recent space or soft-hyphen character) as soon as the text
reaches the right border of the cell, or explicit (via the <code>\n</code> character).
As many cells as necessary are stacked, one below the other.
Text can be aligned, centered or justified. The cell block can be framed and
the background painted.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>cell width. If 0, they extend up to the right margin of the page.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>cell height. Default value: None, meaning to use the current font size.</dd>
<dt><strong><code>txt</code></strong> :&ensp;<code>str</code></dt>
<dd>strign to print.</dd>
<dt><strong><code>border</code></strong></dt>
<dd>Indicates if borders must be drawn around the cell.
The value can be either a number (<code>0</code>: no border ; <code>1</code>: frame)
or a string containing some or all of the following characters
(in any order):
<code>L</code>: left ; <code>T</code>: top ; <code>R</code>: right ; <code>B</code>: bottom. Default value: 0.</dd>
<dt><strong><code>align</code></strong> :&ensp;<code>str</code></dt>
<dd>Allows to center or align the text. Possible values are:
<code>J</code>: justify (default value); <code>L</code> or empty string: left align ;
<code>C</code>: center ; <code>R</code>: right align</dd>
<dt><strong><code>fill</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the cell background must be painted (<code>True</code>)
or transparent (<code>False</code>). Default value: False.</dd>
<dt><strong><code>split_only</code></strong> :&ensp;<code>bool</code></dt>
<dd>if <code>True</code>, does not output anything, only perform
word-wrapping and return the resulting multi-lines array of strings.</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str</code></dt>
<dd>optional link to add on the cell, internal
(identifier returned by <code>add_link</code>) or external URL.</dd>
<dt><strong><code>ln</code></strong> :&ensp;<code>int</code></dt>
<dd>Indicates where the current position should go after the call.
Possible values are: <code>0</code>: to the bottom right ; <code>1</code>: to the beginning
of the next line ; <code>2</code>: below with the same horizontal offset ;
<code>3</code>: to the right with the same vertical offset. Default value: 0.</dd>
<dt><strong><code>max_line_height</code></strong> :&ensp;<code>float</code></dt>
<dd>optional maximum height of each sub-cell generated</dd>
<dt><strong><code>markdown</code></strong> :&ensp;<code>bool</code></dt>
<dd>enable minimal markdown-like markup to render part
of text as bold / italics / underlined. Default to False.</dd>
<dt><strong><code>print_sh</code></strong> :&ensp;<code>bool</code></dt>
<dd>Treat a soft-hyphen (\u00ad) as a normal printable
character, instead of a line breaking opportunity. Default value: False</dd>
</dl>
<p>Using <code>ln=3</code> and <code>maximum height=pdf.font_size</code> is useful to build tables
with multiline text in cells.</p>
<p>Returns: a boolean indicating if page break was triggered,
or if <code>split_only == True</code>: <code>txt</code> splitted into lines in an array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def multi_cell(
    self,
    w,
    h=None,
    txt=&#34;&#34;,
    border=0,
    align=&#34;J&#34;,
    fill=False,
    split_only=False,
    link=&#34;&#34;,
    ln=0,
    max_line_height=None,
    markdown=False,
    print_sh=False,
):
    &#34;&#34;&#34;
    This method allows printing text with line breaks. They can be automatic
    (breaking at the most recent space or soft-hyphen character) as soon as the text
    reaches the right border of the cell, or explicit (via the `\\n` character).
    As many cells as necessary are stacked, one below the other.
    Text can be aligned, centered or justified. The cell block can be framed and
    the background painted.

    Args:
        w (float): cell width. If 0, they extend up to the right margin of the page.
        h (float): cell height. Default value: None, meaning to use the current font size.
        txt (str): strign to print.
        border: Indicates if borders must be drawn around the cell.
            The value can be either a number (`0`: no border ; `1`: frame)
            or a string containing some or all of the following characters
            (in any order):
            `L`: left ; `T`: top ; `R`: right ; `B`: bottom. Default value: 0.
        align (str): Allows to center or align the text. Possible values are:
            `J`: justify (default value); `L` or empty string: left align ;
            `C`: center ; `R`: right align
        fill (bool): Indicates if the cell background must be painted (`True`)
            or transparent (`False`). Default value: False.
        split_only (bool): if `True`, does not output anything, only perform
            word-wrapping and return the resulting multi-lines array of strings.
        link (str): optional link to add on the cell, internal
            (identifier returned by `add_link`) or external URL.
        ln (int): Indicates where the current position should go after the call.
            Possible values are: `0`: to the bottom right ; `1`: to the beginning
            of the next line ; `2`: below with the same horizontal offset ;
            `3`: to the right with the same vertical offset. Default value: 0.
        max_line_height (float): optional maximum height of each sub-cell generated
        markdown (bool): enable minimal markdown-like markup to render part
            of text as bold / italics / underlined. Default to False.
        print_sh (bool): Treat a soft-hyphen (\\u00ad) as a normal printable
            character, instead of a line breaking opportunity. Default value: False

    Using `ln=3` and `maximum height=pdf.font_size` is useful to build tables
    with multiline text in cells.

    Returns: a boolean indicating if page break was triggered,
        or if `split_only == True`: `txt` splitted into lines in an array
    &#34;&#34;&#34;
    if isinstance(w, str) or isinstance(h, str):
        raise ValueError(
            &#34;Parameter &#39;w&#39; and &#39;h&#39; must be numbers, not strings.&#34;
            &#34; You can omit them by passing string content with txt=&#34;
        )
    new_x = XPos.RIGHT
    new_y = YPos.NEXT
    if ln == 1:
        new_x = XPos.LMARGIN
    elif ln == 2:
        new_x = XPos.LEFT
    elif ln == 3:
        new_y = YPos.TOP

    page_break_triggered = False
    if split_only:
        _out, _add_page, _perform_page_break_if_need_be = (
            self._out,
            self.add_page,
            self._perform_page_break_if_need_be,
        )
        self._out = lambda *args, **kwargs: None
        self.add_page = lambda *args, **kwargs: None
        self._perform_page_break_if_need_be = lambda *args, **kwargs: None

    # If width is 0, set width to available width between margins
    if w == 0:
        w = self.w - self.r_margin - self.x
    if h is None:
        h = self.font_size
    maximum_allowed_emwidth = (w - 2 * self.c_margin) * 1000 / self.font_size

    # Calculate text length
    txt = self.normalize_text(txt)
    normalized_string = txt.replace(&#34;\r&#34;, &#34;&#34;)
    styled_text_fragments = self._preload_font_styles(normalized_string, markdown)

    prev_font_style, prev_underline = self.font_style, self.underline
    if markdown and not split_only:
        self._markdown_leak_end_style = True
    prev_x, prev_y = self.x, self.y

    if not border:
        border = &#34;&#34;
    elif border == 1:
        border = &#34;LTRB&#34;

    text_lines = []
    multi_line_break = MultiLineBreak(
        styled_text_fragments,
        self.get_normalized_string_width_with_style,
        justify=(align == &#34;J&#34;),
        print_sh=print_sh,
    )
    text_line = multi_line_break.get_line_of_given_width(maximum_allowed_emwidth)
    while (text_line) is not None:
        text_lines.append(text_line)
        text_line = multi_line_break.get_line_of_given_width(
            maximum_allowed_emwidth
        )

    for text_line_index, text_line in enumerate(text_lines):
        is_last_line = text_line_index == len(text_lines) - 1

        if max_line_height is not None and h &gt; max_line_height and not is_last_line:
            current_cell_height = max_line_height
            h -= current_cell_height
        else:
            current_cell_height = h

        new_page = self._render_styled_cell_text(
            text_line,
            w,
            h=current_cell_height,
            border=&#34;&#34;.join(
                (
                    &#34;T&#34; if &#34;T&#34; in border and text_line_index == 0 else &#34;&#34;,
                    &#34;L&#34; if &#34;L&#34; in border else &#34;&#34;,
                    &#34;R&#34; if &#34;R&#34; in border else &#34;&#34;,
                    &#34;B&#34; if &#34;B&#34; in border and is_last_line else &#34;&#34;,
                )
            ),
            new_x=new_x if is_last_line else XPos.LEFT,
            new_y=new_y if is_last_line else YPos.NEXT,
            align=&#34;L&#34; if (align == &#34;J&#34; and is_last_line) else align,
            fill=fill,
            link=link,
        )
        if is_last_line and new_page and new_y == YPos.TOP:
            # When a page jump is performed and the requested y is TOP (ln=3),
            # pretend we started at the top of the text block on the new page.
            # cf. test_multi_cell_table_with_automatic_page_break
            prev_y = self.y
        page_break_triggered = page_break_triggered or new_page

    if new_y == YPos.TOP:  # We may have jumped a few lines -&gt; reset
        self.y = prev_y

    if split_only:
        # restore writing functions
        self._out, self.add_page, self._perform_page_break_if_need_be = (
            _out,
            _add_page,
            _perform_page_break_if_need_be,
        )
        self.set_xy(prev_x, prev_y)  # restore location
        result = []
        for text_line in text_lines:
            characters = []
            for frag in text_line.fragments:
                characters.extend(frag.characters)
            result.append(&#34;&#34;.join(characters))
        return result
    if markdown:
        if self.font_style != prev_font_style:
            self.font_style = prev_font_style
            self.current_font = self.fonts[self.font_family + self.font_style]
        self.underline = prev_underline
        self._markdown_leak_end_style = False

    return page_break_triggered</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.new_path"><code class="name flex">
<span>def <span class="ident">new_path</span></span>(<span>self, x=0, y=0, paint_rule=PathPaintRule.AUTO, debug_stream=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a path for appending lines and curves to.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of the path starting point</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of the path starting point</dd>
<dt><strong><code>paint_rule</code></strong> :&ensp;<code><a title="fpdf.drawing.PathPaintRule" href="drawing.html#fpdf.drawing.PathPaintRule">PathPaintRule</a></code></dt>
<dd>Optional choice of how the path should
be painted. The default (AUTO) automatically selects stroke/fill based
on the path style settings.</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>TextIO</code></dt>
<dd>print a pretty tree of all items to be rendered
to the provided stream. To store the output in a string, use
<code>io.StringIO</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def new_path(
    self, x=0, y=0, paint_rule=drawing.PathPaintRule.AUTO, debug_stream=None
):
    &#34;&#34;&#34;
    Create a path for appending lines and curves to.

    Args:
        x (float): Abscissa of the path starting point
        y (float): Ordinate of the path starting point
        paint_rule (drawing.PathPaintRule): Optional choice of how the path should
            be painted. The default (AUTO) automatically selects stroke/fill based
            on the path style settings.
        debug_stream (TextIO): print a pretty tree of all items to be rendered
            to the provided stream. To store the output in a string, use
            `io.StringIO`.

    &#34;&#34;&#34;
    with self.drawing_context(debug_stream=debug_stream) as ctxt:
        path = drawing.PaintedPath(x=x, y=y)
        path.style.paint_rule = paint_rule
        yield path
        ctxt.add_item(path)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.normalize_text"><code class="name flex">
<span>def <span class="ident">normalize_text</span></span>(<span>self, txt)</span>
</code></dt>
<dd>
<div class="desc"><p>Check that text input is in the correct format/encoding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_text(self, txt):
    &#34;&#34;&#34;Check that text input is in the correct format/encoding&#34;&#34;&#34;
    # - for TTF unicode fonts: unicode object (utf8 encoding)
    # - for built-in fonts: string instances (encoding: latin-1, cp1252)
    if not self.unifontsubset and self.core_fonts_encoding:
        return txt.encode(self.core_fonts_encoding).decode(&#34;latin-1&#34;)
    return txt</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts the generation of the PDF document.
It is not necessary to call it explicitly because <code>add_page()</code> does it automatically.</p>
<h2 id="notes">Notes</h2>
<p>This method does not add any page.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self):
    &#34;&#34;&#34;
    Starts the generation of the PDF document.
    It is not necessary to call it explicitly because `add_page()` does it automatically.

    Notes
    -----

    This method does not add any page.
    &#34;&#34;&#34;
    self.state = DocumentState.READY</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.output"><code class="name flex">
<span>def <span class="ident">output</span></span>(<span>self, name='', dest='')</span>
</code></dt>
<dd>
<div class="desc"><p>Output PDF to some destination.
The method first calls <a href="close.md">close</a> if necessary to terminate the document.</p>
<p>By default the bytearray buffer is returned.
If a <code>name</code> is given, the PDF is written to a new file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>optional File object or file path where to save the PDF under</dd>
<dt><strong><code>dest</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED</strong>] unused, will be removed in a later version</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output(self, name=&#34;&#34;, dest=&#34;&#34;):
    &#34;&#34;&#34;
    Output PDF to some destination.
    The method first calls [close](close.md) if necessary to terminate the document.

    By default the bytearray buffer is returned.
    If a `name` is given, the PDF is written to a new file.

    Args:
        name (str): optional File object or file path where to save the PDF under
        dest (str): [**DEPRECATED**] unused, will be removed in a later version
    &#34;&#34;&#34;
    if dest:
        warnings.warn(
            &#39;&#34;dest&#34; parameter is deprecated, unused and will soon be removed&#39;,
            DeprecationWarning,
        )
    # Finish document if necessary:
    if self.state &lt; DocumentState.CLOSED:
        self.close()
    if name:
        if isinstance(name, os.PathLike):
            name.write_bytes(self.buffer)
        elif isinstance(name, str):
            Path(name).write_bytes(self.buffer)
        else:
            name.write(self.buffer)
        return None
    return self.buffer</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.page_no"><code class="name flex">
<span>def <span class="ident">page_no</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the current page number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def page_no(self):
    &#34;&#34;&#34;Get the current page number&#34;&#34;&#34;
    return self.page</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.polygon"><code class="name flex">
<span>def <span class="ident">polygon</span></span>(<span>self, point_list, fill=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs a polygon defined by three or more points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point_list</code></strong> :&ensp;<code>list</code> of <code>tuples</code></dt>
<dd>List of Abscissa and Ordinate of
polygon that should be drawn</dd>
<dt><strong><code>fill</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true polygon will be filled</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def polygon(self, point_list, fill=False):
    &#34;&#34;&#34;
    Outputs a polygon defined by three or more points.

    Args:
        point_list (list of tuples): List of Abscissa and Ordinate of
                                    polygon that should be drawn
        fill (bool): If true polygon will be filled
    &#34;&#34;&#34;
    self.polyline(point_list, fill=fill, polygon=True)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.polyline"><code class="name flex">
<span>def <span class="ident">polyline</span></span>(<span>self, point_list, fill=False, polygon=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws lines between two or more points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>point_list</code></strong> :&ensp;<code>list</code> of <code>tuples</code></dt>
<dd>List of Abscissa and Ordinate of
segments that should be drawn</dd>
<dt><strong><code>fill</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true then polyline should be filled</dd>
<dt><strong><code>polygon</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, close path before stroking</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def polyline(self, point_list, fill=False, polygon=False):
    &#34;&#34;&#34;
    Draws lines between two or more points.

    Args:
        point_list (list of tuples): List of Abscissa and Ordinate of
                                    segments that should be drawn
        fill (bool): If true then polyline should be filled
        polygon (bool): If true, close path before stroking
    &#34;&#34;&#34;
    operator = &#34;m&#34;
    for point in point_list:
        self._out(
            f&#34;{point[0] * self.k:.2f} {(self.h - point[1]) * self.k:.2f} {operator}&#34;
        )
        operator = &#34;l&#34;
    if polygon:
        self._out(&#34; h &#34;)
    if fill:
        self._out(&#34; B &#34;)
    else:
        self._out(&#34; S &#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.rect"><code class="name flex">
<span>def <span class="ident">rect</span></span>(<span>self, x, y, w, h, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs a rectangle.
It can be drawn (border only), filled (with no border) or both.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of upper-left bounging box.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of upper-left bounging box.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>Width.</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>Height.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code></dt>
<dd>Style of rendering. Possible values are:
* <code>D</code> or empty string: draw border. This is the default value.
* <code>F</code>: fill
* <code>DF</code> or <code>FD</code>: draw and fill</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def rect(self, x, y, w, h, style=None):
    &#34;&#34;&#34;
    Outputs a rectangle.
    It can be drawn (border only), filled (with no border) or both.

    Args:
        x (float): Abscissa of upper-left bounging box.
        y (float): Ordinate of upper-left bounging box.
        w (float): Width.
        h (float): Height.
        style (str): Style of rendering. Possible values are:
            * `D` or empty string: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    op = _style_to_operator(style)
    self._out(
        f&#34;{x * self.k:.2f} {(self.h - y) * self.k:.2f} {w * self.k:.2f} &#34;
        f&#34;{-h * self.k:.2f} re {op}&#34;
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.rect_clip"><code class="name flex">
<span>def <span class="ident">rect_clip</span></span>(<span>self, x, y, w, h)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
@contextmanager
def rect_clip(self, x, y, w, h):
    self._out(
        (
            f&#34;q {x * self.k:.2f} {(self.h - y - h) * self.k:.2f} {w * self.k:.2f} &#34;
            f&#34;{h * self.k:.2f} re W n\n&#34;
        )
    )
    yield
    self._out(&#34;Q\n&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.regular_polygon"><code class="name flex">
<span>def <span class="ident">regular_polygon</span></span>(<span>self, x, y, numSides, polyWidth, rotateDegrees=0, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs a regular polygon with n sides
It can be rotated
Style can also be applied (fill, border&hellip;)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of upper-left bounding box.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of upper-left bounding box.</dd>
<dt><strong><code>numSides</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of sides for polygon.</dd>
<dt><strong><code>polyWidth</code></strong> :&ensp;<code>float</code></dt>
<dd>width of the polygon.</dd>
<dt><strong><code>rotateDegrees</code></strong> :&ensp;<code>float</code></dt>
<dd>degree amount to rotate polygon. (can be left blank)</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code></dt>
<dd>Style of rendering. Possible values are: (can be left blank)
* <code>D</code> or None: draw border. This is the default value.
* <code>F</code>: fill
* <code>DF</code> or <code>FD</code>: draw and fill</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def regular_polygon(self, x, y, numSides, polyWidth, rotateDegrees=0, style=None):
    &#34;&#34;&#34;
    Outputs a regular polygon with n sides
    It can be rotated
    Style can also be applied (fill, border...)

    Args:
        x (float): Abscissa of upper-left bounding box.
        y (float): Ordinate of upper-left bounding box.
        numSides (int): Number of sides for polygon.
        polyWidth (float): width of the polygon.
        rotateDegrees (float): degree amount to rotate polygon. (can be left blank)
        style (str): Style of rendering. Possible values are: (can be left blank)
            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill

    &#34;&#34;&#34;
    radius = polyWidth / 2
    centerX = x + radius
    centerY = y - radius
    # center point is (centerX, centerY)
    points = []
    i = 1
    for i in range(1, numSides + 1):
        point = centerX + radius * math.cos(
            math.radians((360 / numSides) * i) + math.radians(rotateDegrees)
        ), centerY + radius * math.sin(
            math.radians((360 / numSides) * i) + math.radians(rotateDegrees)
        )
        points.append(point)
        i += 1
    # creates list of touples containing cordinate points of vertices

    self.polygon(points, style)
    # passes points through polygon function</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, angle, x=None, y=None)</span>
</code></dt>
<dd>
<div class="desc"><div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;2.1.0</p>
<p>Use <code>rotation</code> instead.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def rotate(self, angle, x=None, y=None):
    &#34;&#34;&#34;
    .. deprecated:: 2.1.0
      Use `rotation` instead.
    &#34;&#34;&#34;
    warnings.warn(
        &#34;rotate() can produces malformed PDFs and is deprecated. &#34;
        &#34;Use the rotation() context manager instead.&#34;,
        DeprecationWarning,
    )
    if x is None:
        x = self.x
    if y is None:
        y = self.y

    if self.angle != 0:
        self._out(&#34;Q&#34;)
    self.angle = angle
    if angle != 0:
        angle *= math.pi / 180
        c = math.cos(angle)
        s = math.sin(angle)
        cx = x * self.k
        cy = (self.h - y) * self.k
        s = (
            f&#34;q {c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm &#34;
            f&#34;1 0 0 1 {-cx:.2F} {-cy:.2F} cm&#34;
        )
        self._out(s)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.rotation"><code class="name flex">
<span>def <span class="ident">rotation</span></span>(<span>self, angle, x=None, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This method allows to perform a rotation around a given center.
It must be used as a context-manager using <code>with</code>:</p>
<pre><code>with rotation(angle=90, x=x, y=y):
    pdf.something()
</code></pre>
<p>The rotation affects all elements which are printed inside the indented
context (with the exception of clickable areas).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>float</code></dt>
<dd>angle in degrees</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>abscissa of the center of the rotation</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>ordinate of the center of the rotation</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Only the rendering is altered. The <code>get_x()</code> and <code>get_y()</code> methods are
not affected, nor the automatic page break mechanism.
The rotation also establishes a local graphics state, so that any
graphics state settings changed within will not affect the operations
invoked after it has finished.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
@contextmanager
def rotation(self, angle, x=None, y=None):
    &#34;&#34;&#34;
    This method allows to perform a rotation around a given center.
    It must be used as a context-manager using `with`:

        with rotation(angle=90, x=x, y=y):
            pdf.something()

    The rotation affects all elements which are printed inside the indented
    context (with the exception of clickable areas).

    Args:
        angle (float): angle in degrees
        x (float): abscissa of the center of the rotation
        y (float): ordinate of the center of the rotation

    Notes
    -----

    Only the rendering is altered. The `get_x()` and `get_y()` methods are
    not affected, nor the automatic page break mechanism.
    The rotation also establishes a local graphics state, so that any
    graphics state settings changed within will not affect the operations
    invoked after it has finished.
    &#34;&#34;&#34;
    if x is None:
        x = self.x
    if y is None:
        y = self.y
    angle *= math.pi / 180
    c, s = math.cos(angle), math.sin(angle)
    cx, cy = x * self.k, (self.h - y) * self.k
    with self.local_context():
        self._out(
            f&#34;{c:.5F} {s:.5F} {-s:.5F} {c:.5F} {cx:.2F} {cy:.2F} cm &#34;
            f&#34;1 0 0 1 {-cx:.2F} {-cy:.2F} cm\n&#34;
        )
        yield</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_author"><code class="name flex">
<span>def <span class="ident">set_author</span></span>(<span>self, author)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the author of the document.</p>
<h2 id="args">Args</h2>
<p>author(str): the name of the author</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_author(self, author):
    &#34;&#34;&#34;
    Defines the author of the document.

    Args:
        author(str): the name of the author
    &#34;&#34;&#34;
    self.author = author</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_auto_page_break"><code class="name flex">
<span>def <span class="ident">set_auto_page_break</span></span>(<span>self, auto, margin=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set auto page break mode and triggering bottom margin.
By default, the mode is on and the bottom margin is 2 cm.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>auto</code></strong> :&ensp;<code>bool</code></dt>
<dd>enable or disable this mode</dd>
<dt><strong><code>margin</code></strong> :&ensp;<code>float</code></dt>
<dd>optional bottom margin (distance from the bottom of the page)
in the unit specified to FPDF constructor</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_auto_page_break(self, auto, margin=0):
    &#34;&#34;&#34;
    Set auto page break mode and triggering bottom margin.
    By default, the mode is on and the bottom margin is 2 cm.

    Args:
        auto (bool): enable or disable this mode
        margin (float): optional bottom margin (distance from the bottom of the page)
            in the unit specified to FPDF constructor
    &#34;&#34;&#34;
    self.auto_page_break = auto
    self.b_margin = margin
    self.page_break_trigger = self.h - self.b_margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_compression"><code class="name flex">
<span>def <span class="ident">set_compression</span></span>(<span>self, compress)</span>
</code></dt>
<dd>
<div class="desc"><p>Activates or deactivates page compression.</p>
<p>When activated, the internal representation of each page is compressed
using the zlib/deflate method (FlateDecode), which leads to a compression ratio
of about 2 for the resulting document.</p>
<p>Page compression is enabled by default.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>compress</code></strong> :&ensp;<code>bool</code></dt>
<dd>indicates if compression should be enabled</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_compression(self, compress):
    &#34;&#34;&#34;
    Activates or deactivates page compression.

    When activated, the internal representation of each page is compressed
    using the zlib/deflate method (FlateDecode), which leads to a compression ratio
    of about 2 for the resulting document.

    Page compression is enabled by default.

    Args:
        compress (bool): indicates if compression should be enabled
    &#34;&#34;&#34;
    self.compress = compress</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_creation_date"><code class="name flex">
<span>def <span class="ident">set_creation_date</span></span>(<span>self, date=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets Creation of Date time, or current time if None given.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_creation_date(self, date=None):
    &#34;&#34;&#34;Sets Creation of Date time, or current time if None given.&#34;&#34;&#34;
    self.creation_date = datetime.now() if date is None else date</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_creator"><code class="name flex">
<span>def <span class="ident">set_creator</span></span>(<span>self, creator)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the creator of the document.
This is typically the name of the application that generates the PDF.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>creator</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the PDF creator</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_creator(self, creator):
    &#34;&#34;&#34;
    Defines the creator of the document.
    This is typically the name of the application that generates the PDF.

    Args:
        creator (str): name of the PDF creator
    &#34;&#34;&#34;
    self.creator = creator</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_dash_pattern"><code class="name flex">
<span>def <span class="ident">set_dash_pattern</span></span>(<span>self, dash=0, gap=0, phase=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the current dash pattern for lines and curves.</p>
<h2 id="args">Args</h2>
<p>dash (float &gt;= 0):
The length of the dashes in current units.</p>
<p>gap (float &gt;= 0):
The length of the gaps between dashes in current units.
If omitted, the dash length will be used.</p>
<p>phase (float &gt;= 0):
Where in the sequence to start drawing.
Omitting 'dash' (= 0) resets the pattern to a solid line.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dash_pattern(self, dash=0, gap=0, phase=0):
    &#34;&#34;&#34;
    Set the current dash pattern for lines and curves.

    Args:
        dash (float &gt;= 0):
            The length of the dashes in current units.

        gap (float &gt;= 0):
            The length of the gaps between dashes in current units.
            If omitted, the dash length will be used.

        phase (float &gt;= 0):
            Where in the sequence to start drawing.

    Omitting &#39;dash&#39; (= 0) resets the pattern to a solid line.
    &#34;&#34;&#34;
    if not (isinstance(dash, (int, float)) and dash &gt;= 0):
        raise ValueError(&#34;Dash length must be zero or a positive number.&#34;)
    if not (isinstance(gap, (int, float)) and gap &gt;= 0):
        raise ValueError(&#34;gap length must be zero or a positive number.&#34;)
    if not (isinstance(phase, (int, float)) and phase &gt;= 0):
        raise ValueError(&#34;Phase must be zero or a positive number.&#34;)

    pattern = dict(dash=dash, gap=gap, phase=phase)

    if pattern != self.dash_pattern:
        self.dash_pattern = pattern

        if dash:
            if gap:
                dstr = f&#34;[{dash * self.k:.3f} {gap * self.k:.3f}] {phase *self.k:.3f} d&#34;
            else:
                dstr = f&#34;[{dash * self.k:.3f}] {phase *self.k:.3f} d&#34;
        else:
            dstr = &#34;[] 0 d&#34;

        self._out(dstr)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_display_mode"><code class="name flex">
<span>def <span class="ident">set_display_mode</span></span>(<span>self, zoom, layout='continuous')</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the way the document is to be displayed by the viewer.</p>
<p>It allows to set tje zoom level: pages can be displayed entirely on screen,
occupy the full width of the window, use the real size,
be scaled by a specific zooming factor or use the viewer default (configured in its Preferences menu).</p>
<p>The page layout can also be specified: single page at a time, continuous display, two columns or viewer default.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>zoom</code></strong></dt>
<dd>either "fullpage", "fullwidth", "real", "default",
or a number indicating the zooming factor to use, interpreted as a percentage.
The zoom level set by default is "default".</dd>
<dt><strong><code>layout</code></strong> :&ensp;<code>str</code></dt>
<dd>either "single", "continuous", "two" or "default",
meaning to use the viewer default mode.
The layout set by default is "default",
and this method default value is "continuous".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_display_mode(self, zoom, layout=&#34;continuous&#34;):
    &#34;&#34;&#34;
    Defines the way the document is to be displayed by the viewer.

    It allows to set tje zoom level: pages can be displayed entirely on screen,
    occupy the full width of the window, use the real size,
    be scaled by a specific zooming factor or use the viewer default (configured in its Preferences menu).

    The page layout can also be specified: single page at a time, continuous display, two columns or viewer default.

    Args:
        zoom: either &#34;fullpage&#34;, &#34;fullwidth&#34;, &#34;real&#34;, &#34;default&#34;,
            or a number indicating the zooming factor to use, interpreted as a percentage.
            The zoom level set by default is &#34;default&#34;.
        layout (str): either &#34;single&#34;, &#34;continuous&#34;, &#34;two&#34; or &#34;default&#34;,
            meaning to use the viewer default mode.
            The layout set by default is &#34;default&#34;,
            and this method default value is &#34;continuous&#34;.
    &#34;&#34;&#34;
    if zoom in ZOOM_CONFIGS or not isinstance(zoom, str):
        self.zoom_mode = zoom
    elif zoom != &#34;default&#34;:
        raise FPDFException(f&#34;Incorrect zoom display mode: {zoom}&#34;)

    if layout in LAYOUT_NAMES:
        self.layout_mode = layout
    elif layout != &#34;default&#34;:
        raise FPDFException(f&#34;Incorrect layout display mode: {layout}&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_doc_option"><code class="name flex">
<span>def <span class="ident">set_doc_option</span></span>(<span>self, opt, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a document option.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>opt</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the option to set</dd>
</dl>
<p>value (str) option value</p>
<div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;2.4.0</p>
<p>Simply set the <code>core_fonts_encoding</code> property as a replacement.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_doc_option(self, opt, value):
    &#34;&#34;&#34;
    Defines a document option.

    Args:
        opt (str): name of the option to set
        value (str) option value

    .. deprecated:: 2.4.0
        Simply set the `core_fonts_encoding` property as a replacement.
    &#34;&#34;&#34;
    warnings.warn(
        &#34;set_doc_option() is deprecated. &#34;
        &#34;Simply set the `core_fonts_encoding` property as a replacement.&#34;,
        DeprecationWarning,
    )
    if opt != &#34;core_fonts_encoding&#34;:
        raise FPDFException(f&#39;Unknown document option &#34;{opt}&#34;&#39;)
    self.core_fonts_encoding = value</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_draw_color"><code class="name flex">
<span>def <span class="ident">set_draw_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the color used for all stroking operations (lines, rectangles and cell borders).
It can be expressed in RGB components or grey scale.
The method can be called before the first page is created and the value is retained from page to page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code></dt>
<dd>if <code>g</code> and <code>b</code> are given, this indicates the red component.
Else, this indicates the grey level. The value must be between 0 and 255.</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>int</code></dt>
<dd>green component (between 0 and 255)</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>blue component (between 0 and 255)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_draw_color(self, r, g=-1, b=-1):
    &#34;&#34;&#34;
    Defines the color used for all stroking operations (lines, rectangles and cell borders).
    It can be expressed in RGB components or grey scale.
    The method can be called before the first page is created and the value is retained from page to page.

    Args:
        r (int): if `g` and `b` are given, this indicates the red component.
            Else, this indicates the grey level. The value must be between 0 and 255.
        g (int): green component (between 0 and 255)
        b (int): blue component (between 0 and 255)
    &#34;&#34;&#34;
    if (r == 0 and g == 0 and b == 0) or g == -1:
        self.draw_color = f&#34;{r / 255:.3f} G&#34;
    else:
        self.draw_color = f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} RG&#34;
    if self.page &gt; 0:
        self._out(self.draw_color)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_fill_color"><code class="name flex">
<span>def <span class="ident">set_fill_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the color used for all filling operations (filled rectangles and cell backgrounds).
It can be expressed in RGB components or grey scale.
The method can be called before the first page is created and the value is retained from page to page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code></dt>
<dd>if <code>g</code> and <code>b</code> are given, this indicates the red component.
Else, this indicates the grey level. The value must be between 0 and 255.</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>int</code></dt>
<dd>green component (between 0 and 255)</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>blue component (between 0 and 255)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fill_color(self, r, g=-1, b=-1):
    &#34;&#34;&#34;
    Defines the color used for all filling operations (filled rectangles and cell backgrounds).
    It can be expressed in RGB components or grey scale.
    The method can be called before the first page is created and the value is retained from page to page.

    Args:
        r (int): if `g` and `b` are given, this indicates the red component.
            Else, this indicates the grey level. The value must be between 0 and 255.
        g (int): green component (between 0 and 255)
        b (int): blue component (between 0 and 255)
    &#34;&#34;&#34;
    if (r == 0 and g == 0 and b == 0) or g == -1:
        self.fill_color = f&#34;{r / 255:.3f} g&#34;
    else:
        self.fill_color = f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} rg&#34;
    if self.page &gt; 0:
        self._out(self.fill_color)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_font"><code class="name flex">
<span>def <span class="ident">set_font</span></span>(<span>self, family=None, style='', size=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the font used to print character strings.
It is mandatory to call this method at least once before printing text.</p>
<p>Default encoding is not specified, but all text writing methods accept only
unicode for external fonts and one byte encoding for standard.</p>
<p>Standard fonts use <code>Latin-1</code> encoding by default, but Windows
encoding <code>cp1252</code> (Western Europe) can be used with
<code>self.core_fonts_encoding = encoding</code>.</p>
<p>The font specified is retained from page to page.
The method can be called before the first page is created.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>family</code></strong> :&ensp;<code>str</code></dt>
<dd>name of a font added with <code><a title="fpdf.FPDF.add_font" href="#fpdf.FPDF.add_font">FPDF.add_font()</a></code>,
or name of one of the 14 standard "PostScript" fonts:
Courier (fixed-width), Helvetica (sans serif), Times (serif),
Symbol (symbolic) or ZapfDingbats (symbolic)
If an empty string is provided, the current family is retained.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code></dt>
<dd>empty string (by default) or a combination
of one or several letters among B (bold), I (italic) and U (underline).
Bold and italic styles do not apply to Symbol and ZapfDingbats fonts.</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code></dt>
<dd>in points. The default value is the current size.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font(self, family=None, style=&#34;&#34;, size=0):
    &#34;&#34;&#34;
    Sets the font used to print character strings.
    It is mandatory to call this method at least once before printing text.

    Default encoding is not specified, but all text writing methods accept only
    unicode for external fonts and one byte encoding for standard.

    Standard fonts use `Latin-1` encoding by default, but Windows
    encoding `cp1252` (Western Europe) can be used with
    `self.core_fonts_encoding = encoding`.

    The font specified is retained from page to page.
    The method can be called before the first page is created.

    Args:
        family (str): name of a font added with `FPDF.add_font`,
            or name of one of the 14 standard &#34;PostScript&#34; fonts:
            Courier (fixed-width), Helvetica (sans serif), Times (serif),
            Symbol (symbolic) or ZapfDingbats (symbolic)
            If an empty string is provided, the current family is retained.
        style (str): empty string (by default) or a combination
            of one or several letters among B (bold), I (italic) and U (underline).
            Bold and italic styles do not apply to Symbol and ZapfDingbats fonts.
        size (float): in points. The default value is the current size.
    &#34;&#34;&#34;
    if not family:
        family = self.font_family

    family = family.lower()
    style = &#34;&#34;.join(sorted(style.upper()))
    if any(letter not in &#34;BIU&#34; for letter in style):
        raise ValueError(
            f&#34;Unknown style provided (only B/I/U letters are allowed): {style}&#34;
        )
    if &#34;U&#34; in style:
        self.underline = True
        style = style.replace(&#34;U&#34;, &#34;&#34;)
    else:
        self.underline = False

    if family in self.font_aliases and family + style not in self.fonts:
        warnings.warn(
            f&#34;Substituting font {family} by core font &#34;
            f&#34;{self.font_aliases[family]}&#34;
        )
        family = self.font_aliases[family]
    elif family in (&#34;symbol&#34;, &#34;zapfdingbats&#34;) and style:
        warnings.warn(
            f&#34;Built-in font {family} only has a single &#39;style&#39; and can&#39;t be bold &#34;
            f&#34;or italic&#34;
        )
        style = &#34;&#34;

    if size == 0:
        size = self.font_size_pt

    # Test if font is already selected
    if (
        self.font_family == family
        and self.font_style == style
        and self.font_size_pt == size
    ):
        return

    # Test if used for the first time
    fontkey = family + style
    if fontkey not in self.fonts:
        if fontkey not in self.core_fonts:
            raise FPDFException(
                f&#34;Undefined font: {fontkey} - &#34;
                f&#34;Use built-in fonts or FPDF.add_font() beforehand&#34;
            )
        # If it&#39;s one of the core fonts, add it to self.fonts
        self.fonts[fontkey] = {
            &#34;i&#34;: len(self.fonts) + 1,
            &#34;type&#34;: &#34;core&#34;,
            &#34;name&#34;: self.core_fonts[fontkey],
            &#34;up&#34;: -100,
            &#34;ut&#34;: 50,
            &#34;cw&#34;: fpdf_charwidths[fontkey],
            &#34;fontkey&#34;: fontkey,
        }

    # Select it
    self.font_family = family
    self.font_style = style
    self.font_size_pt = size
    self.font_size = size / self.k
    self.current_font = self.fonts[fontkey]
    if self.page &gt; 0:
        self._out(f&#34;BT /F{self.current_font[&#39;i&#39;]} {self.font_size_pt:.2f} Tf ET&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_font_size"><code class="name flex">
<span>def <span class="ident">set_font_size</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the font size in points</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>float</code></dt>
<dd>font size in points</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font_size(self, size):
    &#34;&#34;&#34;
    Configure the font size in points

    Args:
        size (float): font size in points
    &#34;&#34;&#34;
    if self.font_size_pt == size:
        return
    self.font_size_pt = size
    self.font_size = size / self.k
    if self.page &gt; 0:
        if not self.current_font:
            raise FPDFException(
                &#34;Cannot set font size: a font must be selected first&#34;
            )
        self._out(f&#34;BT /F{self.current_font[&#39;i&#39;]} {self.font_size_pt:.2f} Tf ET&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_image_filter"><code class="name flex">
<span>def <span class="ident">set_image_filter</span></span>(<span>self, image_filter)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<dl>
<dt><strong><code>image_filter</code></strong> :&ensp;<code>str</code></dt>
<dd>name of a support image filter or "AUTO",
meaning to use the best image filter given the images provided.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_image_filter(self, image_filter):
    &#34;&#34;&#34;
    Args:
        image_filter (str): name of a support image filter or &#34;AUTO&#34;,
            meaning to use the best image filter given the images provided.
    &#34;&#34;&#34;
    if image_filter not in SUPPORTED_IMAGE_FILTERS:
        raise ValueError(
            f&#34;&#39;{image_filter}&#39; is not a supported image filter: {&#39;&#39;.join(SUPPORTED_IMAGE_FILTERS)}&#34;
        )
    self.image_filter = image_filter</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_keywords"><code class="name flex">
<span>def <span class="ident">set_keywords</span></span>(<span>self, keywords)</span>
</code></dt>
<dd>
<div class="desc"><p>Associate keywords with the document</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>keywords</code></strong> :&ensp;<code>str</code></dt>
<dd>a space-separated list of words</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_keywords(self, keywords):
    &#34;&#34;&#34;
    Associate keywords with the document

    Args:
        keywords (str): a space-separated list of words
    &#34;&#34;&#34;
    self.keywords = keywords</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_lang"><code class="name flex">
<span>def <span class="ident">set_lang</span></span>(<span>self, lang)</span>
</code></dt>
<dd>
<div class="desc"><p>A language identifier specifying the natural language for all text in the document
except where overridden by language specifications for structure elements or marked content.
A language identifier can either be the empty text string, to indicate that the language is unknown,
or a Language-Tag as defined in RFC 3066, "Tags for the Identification of Languages".</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lang</code></strong> :&ensp;<code>str</code></dt>
<dd>the document main language</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_lang(self, lang):
    &#34;&#34;&#34;
    A language identifier specifying the natural language for all text in the document
    except where overridden by language specifications for structure elements or marked content.
    A language identifier can either be the empty text string, to indicate that the language is unknown,
    or a Language-Tag as defined in RFC 3066, &#34;Tags for the Identification of Languages&#34;.

    Args:
        lang (str): the document main language
    &#34;&#34;&#34;
    self.lang = lang</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_left_margin"><code class="name flex">
<span>def <span class="ident">set_left_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the document left margin.
Also sets the current FPDF.x on the page to this minimum horizontal position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>margin</code></strong> :&ensp;<code>float</code></dt>
<dd>margin in the unit specified to FPDF constructor</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_left_margin(self, margin):
    &#34;&#34;&#34;
    Sets the document left margin.
    Also sets the current FPDF.x on the page to this minimum horizontal position.

    Args:
        margin (float): margin in the unit specified to FPDF constructor
    &#34;&#34;&#34;
    if self.x &lt; margin or self.x == self.l_margin:
        self.x = margin
    self.l_margin = margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_line_width"><code class="name flex">
<span>def <span class="ident">set_line_width</span></span>(<span>self, width)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the line width of all stroking operations (lines, rectangles and cell borders).
By default, the value equals 0.2 mm.
The method can be called before the first page is created and the value is retained from page to page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong> :&ensp;<code>float</code></dt>
<dd>the width in user unit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_line_width(self, width):
    &#34;&#34;&#34;
    Defines the line width of all stroking operations (lines, rectangles and cell borders).
    By default, the value equals 0.2 mm.
    The method can be called before the first page is created and the value is retained from page to page.

    Args:
        width (float): the width in user unit
    &#34;&#34;&#34;
    self.line_width = width
    if self.page &gt; 0:
        self._out(f&#34;{width * self.k:.2f} w&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_link"><code class="name flex">
<span>def <span class="ident">set_link</span></span>(<span>self, link, y=0, x=0, page=-1, zoom='null')</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the page and position a link points to.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>link</code></strong> :&ensp;<code>int</code></dt>
<dd>a link identifier returned by <code>add_link</code>.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>optional ordinate of target position.
The default value is 0 (top of page).</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>optional abscissa of target position.
The default value is 0 (top of page).</dd>
<dt><strong><code>page</code></strong> :&ensp;<code>int</code></dt>
<dd>optional number of target page.
-1 indicates the current page, which is the default value.</dd>
<dt><strong><code>zoom</code></strong> :&ensp;<code>float</code></dt>
<dd>optional new zoom level after following the link.
Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_link(self, link, y=0, x=0, page=-1, zoom=&#34;null&#34;):
    &#34;&#34;&#34;
    Defines the page and position a link points to.

    Args:
        link (int): a link identifier returned by `add_link`.
        y (float): optional ordinate of target position.
            The default value is 0 (top of page).
        x (float): optional abscissa of target position.
            The default value is 0 (top of page).
        page (int): optional number of target page.
            -1 indicates the current page, which is the default value.
        zoom (float): optional new zoom level after following the link.
            Currently ignored by Sumatra PDF Reader, but observed by Adobe Acrobat reader.
    &#34;&#34;&#34;
    self.links[link] = DestinationXYZ(
        self.page if page == -1 else page, x=x, y=y, zoom=zoom
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_margin"><code class="name flex">
<span>def <span class="ident">set_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the document right, left, top &amp; bottom margins to the same value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>margin</code></strong> :&ensp;<code>float</code></dt>
<dd>margin in the unit specified to FPDF constructor</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_margin(self, margin):
    &#34;&#34;&#34;
    Sets the document right, left, top &amp; bottom margins to the same value.

    Args:
        margin (float): margin in the unit specified to FPDF constructor
    &#34;&#34;&#34;
    self.set_margins(margin, margin)
    self.set_auto_page_break(self.auto_page_break, margin)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_margins"><code class="name flex">
<span>def <span class="ident">set_margins</span></span>(<span>self, left, top, right=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the document left, top &amp; optionaly right margins to the same value.
By default, they equal 1 cm.
Also sets the current FPDF.y on the page to this minimum vertical position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>left</code></strong> :&ensp;<code>float</code></dt>
<dd>left margin in the unit specified to FPDF constructor</dd>
<dt><strong><code>top</code></strong> :&ensp;<code>float</code></dt>
<dd>top margin in the unit specified to FPDF constructor</dd>
<dt><strong><code>right</code></strong> :&ensp;<code>float</code></dt>
<dd>optional right margin in the unit specified to FPDF constructor</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_margins(self, left, top, right=-1):
    &#34;&#34;&#34;
    Sets the document left, top &amp; optionaly right margins to the same value.
    By default, they equal 1 cm.
    Also sets the current FPDF.y on the page to this minimum vertical position.

    Args:
        left (float): left margin in the unit specified to FPDF constructor
        top (float): top margin in the unit specified to FPDF constructor
        right (float): optional right margin in the unit specified to FPDF constructor
    &#34;&#34;&#34;
    self.set_left_margin(left)
    if self.y &lt; top or self.y == self.t_margin:
        self.y = top
    self.t_margin = top
    if right == -1:
        right = left
    self.r_margin = right</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_producer"><code class="name flex">
<span>def <span class="ident">set_producer</span></span>(<span>self, producer)</span>
</code></dt>
<dd>
<div class="desc"><p>Producer of document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_producer(self, producer):
    &#34;&#34;&#34;Producer of document&#34;&#34;&#34;
    self.producer = producer</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_right_margin"><code class="name flex">
<span>def <span class="ident">set_right_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the document right margin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>margin</code></strong> :&ensp;<code>float</code></dt>
<dd>margin in the unit specified to FPDF constructor</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_right_margin(self, margin):
    &#34;&#34;&#34;
    Sets the document right margin.

    Args:
        margin (float): margin in the unit specified to FPDF constructor
    &#34;&#34;&#34;
    self.r_margin = margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_section_title_styles"><code class="name flex">
<span>def <span class="ident">set_section_title_styles</span></span>(<span>self, level0, level1=None, level2=None, level3=None, level4=None, level5=None, level6=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a style for section titles.
After calling this method, calls to <code>start_section</code> will render section names visually.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>level0</code></strong> :&ensp;<code><a title="fpdf.TitleStyle" href="#fpdf.TitleStyle">TitleStyle</a></code></dt>
<dd>style for the top level section titles</dd>
<dt><strong><code>level1</code></strong> :&ensp;<code><a title="fpdf.TitleStyle" href="#fpdf.TitleStyle">TitleStyle</a></code></dt>
<dd>optional style for the level 1 section titles</dd>
<dt><strong><code>level2</code></strong> :&ensp;<code><a title="fpdf.TitleStyle" href="#fpdf.TitleStyle">TitleStyle</a></code></dt>
<dd>optional style for the level 2 section titles</dd>
<dt><strong><code>level3</code></strong> :&ensp;<code><a title="fpdf.TitleStyle" href="#fpdf.TitleStyle">TitleStyle</a></code></dt>
<dd>optional style for the level 3 section titles</dd>
<dt><strong><code>level4</code></strong> :&ensp;<code><a title="fpdf.TitleStyle" href="#fpdf.TitleStyle">TitleStyle</a></code></dt>
<dd>optional style for the level 4 section titles</dd>
<dt><strong><code>level5</code></strong> :&ensp;<code><a title="fpdf.TitleStyle" href="#fpdf.TitleStyle">TitleStyle</a></code></dt>
<dd>optional style for the level 5 section titles</dd>
<dt><strong><code>level6</code></strong> :&ensp;<code><a title="fpdf.TitleStyle" href="#fpdf.TitleStyle">TitleStyle</a></code></dt>
<dd>optional style for the level 6 section titles</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_section_title_styles(
    self,
    level0,
    level1=None,
    level2=None,
    level3=None,
    level4=None,
    level5=None,
    level6=None,
):
    &#34;&#34;&#34;
    Defines a style for section titles.
    After calling this method, calls to `start_section` will render section names visually.

    Args:
        level0 (TitleStyle): style for the top level section titles
        level1 (TitleStyle): optional style for the level 1 section titles
        level2 (TitleStyle): optional style for the level 2 section titles
        level3 (TitleStyle): optional style for the level 3 section titles
        level4 (TitleStyle): optional style for the level 4 section titles
        level5 (TitleStyle): optional style for the level 5 section titles
        level6 (TitleStyle): optional style for the level 6 section titles
    &#34;&#34;&#34;
    for level in (level0, level1, level2, level3, level4, level5, level6):
        if level and not isinstance(level, TitleStyle):
            raise TypeError(
                f&#34;Arguments must all be TitleStyle instances, got: {type(level)}&#34;
            )
    self.section_title_styles = {
        0: level0,
        1: level1,
        2: level2,
        3: level3,
        4: level4,
        5: level5,
        6: level6,
    }</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_stretching"><code class="name flex">
<span>def <span class="ident">set_stretching</span></span>(<span>self, stretching)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets horizontal font stretching.
By default, no stretching is set (which is equivalent to a value of 100).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stretching</code></strong> :&ensp;<code>float</code></dt>
<dd>horizontal stretching (scaling) in percents.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_stretching(self, stretching):
    &#34;&#34;&#34;
    Sets horizontal font stretching.
    By default, no stretching is set (which is equivalent to a value of 100).

    Args:
        stretching (float): horizontal stretching (scaling) in percents.
    &#34;&#34;&#34;
    if self.font_stretching == stretching:
        return
    self.font_stretching = stretching
    if self.page &gt; 0:
        self._out(f&#34;BT {self.font_stretching:.2f} Tz ET&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_subject"><code class="name flex">
<span>def <span class="ident">set_subject</span></span>(<span>self, subject)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the subject of the document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>subject</code></strong> :&ensp;<code>str</code></dt>
<dd>the document main subject</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_subject(self, subject):
    &#34;&#34;&#34;
    Defines the subject of the document.

    Args:
        subject (str): the document main subject
    &#34;&#34;&#34;
    self.subject = subject</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_text_color"><code class="name flex">
<span>def <span class="ident">set_text_color</span></span>(<span>self, r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the color used for text.
It can be expressed in RGB components or grey scale.
The method can be called before the first page is created and the value is retained from page to page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>int</code></dt>
<dd>if <code>g</code> and <code>b</code> are given, this indicates the red component.
Else, this indicates the grey level. The value must be between 0 and 255.</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>int</code></dt>
<dd>green component (between 0 and 255)</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>int</code></dt>
<dd>blue component (between 0 and 255)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_text_color(self, r, g=-1, b=-1):
    &#34;&#34;&#34;
    Defines the color used for text.
    It can be expressed in RGB components or grey scale.
    The method can be called before the first page is created and the value is retained from page to page.

    Args:
        r (int): if `g` and `b` are given, this indicates the red component.
            Else, this indicates the grey level. The value must be between 0 and 255.
        g (int): green component (between 0 and 255)
        b (int): blue component (between 0 and 255)
    &#34;&#34;&#34;
    if (r == 0 and g == 0 and b == 0) or g == -1:
        self.text_color = f&#34;{r / 255:.3f} g&#34;
    else:
        self.text_color = f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} rg&#34;</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_title"><code class="name flex">
<span>def <span class="ident">set_title</span></span>(<span>self, title)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the title of the document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>the title</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_title(self, title):
    &#34;&#34;&#34;
    Defines the title of the document.

    Args:
        title (str): the title
    &#34;&#34;&#34;
    self.title = title</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_top_margin"><code class="name flex">
<span>def <span class="ident">set_top_margin</span></span>(<span>self, margin)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the document top margin.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>margin</code></strong> :&ensp;<code>float</code></dt>
<dd>margin in the unit specified to FPDF constructor</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_top_margin(self, margin):
    &#34;&#34;&#34;
    Sets the document top margin.

    Args:
        margin (float): margin in the unit specified to FPDF constructor
    &#34;&#34;&#34;
    self.t_margin = margin</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_x"><code class="name flex">
<span>def <span class="ident">set_x</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the abscissa of the current position.
If the value provided is negative, it is relative to the right of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>the new current abscissa</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_x(self, x):
    &#34;&#34;&#34;
    Defines the abscissa of the current position.
    If the value provided is negative, it is relative to the right of the page.

    Args:
        x (float): the new current abscissa
    &#34;&#34;&#34;
    self.x = x if x &gt;= 0 else self.w + x</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_xmp_metadata"><code class="name flex">
<span>def <span class="ident">set_xmp_metadata</span></span>(<span>self, xmp_metadata)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_xmp_metadata(self, xmp_metadata):
    if &#34;&lt;?xpacket&#34; in xmp_metadata[:50]:
        raise ValueError(
            &#34;fpdf2 already performs XMP metadata wrapping in a &lt;?xpacket&gt; tag&#34;
        )
    self.xmp_metadata = xmp_metadata</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_xy"><code class="name flex">
<span>def <span class="ident">set_xy</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the abscissa and ordinate of the current position.
If the values provided are negative, they are relative respectively to the right and bottom of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>the new current abscissa</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>the new current ordinate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_xy(self, x, y):
    &#34;&#34;&#34;
    Defines the abscissa and ordinate of the current position.
    If the values provided are negative, they are relative respectively to the right and bottom of the page.

    Args:
        x (float): the new current abscissa
        y (float): the new current ordinate
    &#34;&#34;&#34;
    self.set_y(y)
    self.set_x(x)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.set_y"><code class="name flex">
<span>def <span class="ident">set_y</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves the current abscissa back to the left margin and sets the ordinate.
If the value provided is negative, it is relative to the bottom of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>the new current ordinate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_y(self, y):
    &#34;&#34;&#34;
    Moves the current abscissa back to the left margin and sets the ordinate.
    If the value provided is negative, it is relative to the bottom of the page.

    Args:
        y (float): the new current ordinate
    &#34;&#34;&#34;
    self.x = self.l_margin
    self.y = y if y &gt;= 0 else self.h + y</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.solid_arc"><code class="name flex">
<span>def <span class="ident">solid_arc</span></span>(<span>self, x, y, a, start_angle, end_angle, b=None, inclination=0, clockwise=False, style=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs a solid arc. A solid arc combines an arc and a triangle to form a pie slice
It can be drawn (border only), filled (with no border) or both.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Abscissa of upper-left bounging box.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>Ordinate of upper-left bounging box.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>float</code></dt>
<dd>Semi-major axis.</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>float</code></dt>
<dd>Semi-minor axis, if None, equals to a (default: None).</dd>
<dt><strong><code>start_angle</code></strong> :&ensp;<code>float</code></dt>
<dd>Start angle of the arc (in degrees).</dd>
<dt><strong><code>end_angle</code></strong> :&ensp;<code>float</code></dt>
<dd>End angle of the arc (in degrees).</dd>
<dt><strong><code>inclination</code></strong> :&ensp;<code>float</code></dt>
<dd>Inclination of the arc in respect of the x-axis (default: 0).</dd>
<dt><strong><code>clockwise</code></strong> :&ensp;<code>bool</code></dt>
<dd>Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).</dd>
<dt><strong><code>style</code></strong> :&ensp;<code>str</code></dt>
<dd>Style of rendering. Possible values are:
* <code>D</code> or None: draw border. This is the default value.
* <code>F</code>: fill
* <code>DF</code> or <code>FD</code>: draw and fill</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def solid_arc(
    self,
    x,
    y,
    a,
    start_angle,
    end_angle,
    b=None,
    inclination=0,
    clockwise=False,
    style=None,
):
    &#34;&#34;&#34;
    Outputs a solid arc. A solid arc combines an arc and a triangle to form a pie slice
    It can be drawn (border only), filled (with no border) or both.

    Args:
        x (float): Abscissa of upper-left bounging box.
        y (float): Ordinate of upper-left bounging box.
        a (float): Semi-major axis.
        b (float): Semi-minor axis, if None, equals to a (default: None).
        start_angle (float): Start angle of the arc (in degrees).
        end_angle (float): End angle of the arc (in degrees).
        inclination (float): Inclination of the arc in respect of the x-axis (default: 0).
        clockwise (bool): Way of drawing the arc (True: clockwise, False: counterclockwise) (default: False).
        style (str): Style of rendering. Possible values are:
            * `D` or None: draw border. This is the default value.
            * `F`: fill
            * `DF` or `FD`: draw and fill
    &#34;&#34;&#34;
    self.arc(
        x,
        y,
        a,
        start_angle,
        end_angle,
        b,
        inclination,
        clockwise,
        True,
        True,
        style,
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.start_section"><code class="name flex">
<span>def <span class="ident">start_section</span></span>(<span>self, name, level=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a section in the document outline.
If section_title_styles have been configured,
render the section name visually as a title.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>section name</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code></dt>
<dd>section level in the document outline. 0 means top-level.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def start_section(self, name, level=0):
    &#34;&#34;&#34;
    Start a section in the document outline.
    If section_title_styles have been configured,
    render the section name visually as a title.

    Args:
        name (str): section name
        level (int): section level in the document outline. 0 means top-level.
    &#34;&#34;&#34;
    if level &lt; 0:
        raise ValueError(&#39;&#34;level&#34; mut be equal or greater than zero&#39;)
    if self._outline and level &gt; self._outline[-1].level + 1:
        raise ValueError(
            f&#34;Incoherent hierarchy: cannot start a level {level} section after a level {self._outline[-1].level} one&#34;
        )
    dest = DestinationXYZ(self.page, y=self.y)
    struct_elem = None
    if self.section_title_styles:
        with self._marked_sequence(title=name) as marked_content:
            struct_elem = self.struct_builder.struct_elem_per_mc[marked_content]
            with self._apply_style(self.section_title_styles[level]):
                self.multi_cell(w=self.epw, h=self.font_size, txt=name, ln=1)
    self._outline.append(OutlineSection(name, level, self.page, dest, struct_elem))</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self, x, y, txt='')</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a character string. The origin is on the left of the first character,
on the baseline. This method allows placing a string precisely on the page,
but it is usually easier to use the <code>cell()</code>, <code>multi_cell() or </code>write()` methods.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>abscissa of the origin</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>ordinate of the origin</dd>
<dt><strong><code>txt</code></strong> :&ensp;<code>str</code></dt>
<dd>string to print</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def text(self, x, y, txt=&#34;&#34;):
    &#34;&#34;&#34;
    Prints a character string. The origin is on the left of the first character,
    on the baseline. This method allows placing a string precisely on the page,
    but it is usually easier to use the `cell()`, `multi_cell() or `write()` methods.

    Args:
        x (float): abscissa of the origin
        y (float): ordinate of the origin
        txt (str): string to print
    &#34;&#34;&#34;
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    txt = self.normalize_text(txt)
    if self.unifontsubset:
        txt_mapped = &#34;&#34;
        for char in txt:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.current_font[&#34;subset&#34;].pick(uni))
        txt2 = escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))
    else:
        txt2 = escape_parens(txt)
    s = f&#34;BT {x * self.k:.2f} {(self.h - y) * self.k:.2f} Td ({txt2}) Tj ET&#34;
    if self.underline and txt != &#34;&#34;:
        s += &#34; &#34; + self._do_underline(x, y, txt)
    if self.fill_color != self.text_color:
        s = f&#34;q {self.text_color} {s} Q&#34;
    self._out(s)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.text_annotation"><code class="name flex">
<span>def <span class="ident">text_annotation</span></span>(<span>self, x, y, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Puts a text annotation on a rectangular area of the page.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>horizontal position (from the left) to the left side of the link rectangle</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>vertical position (from the top) to the bottom side of the link rectangle</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>float</code></dt>
<dd>width of the link rectangle</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>width of the link rectangle</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>text to display</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def text_annotation(self, x, y, text):
    &#34;&#34;&#34;
    Puts a text annotation on a rectangular area of the page.

    Args:
        x (float): horizontal position (from the left) to the left side of the link rectangle
        y (float): vertical position (from the top) to the bottom side of the link rectangle
        w (float): width of the link rectangle
        h (float): width of the link rectangle
        text (str): text to display
    &#34;&#34;&#34;
    self.annots[self.page].append(
        Annotation(
            &#34;Text&#34;,
            x * self.k,
            self.h_pt - y * self.k,
            self.k,
            self.k,
            contents=text,
        )
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.unbreakable"><code class="name flex">
<span>def <span class="ident">unbreakable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensures that all rendering performed in this context appear on a single page
by performing page break beforehand if need be.</p>
<h2 id="notes">Notes</h2>
<p>Using this method means to duplicate the FPDF <code>bytearray</code> buffer:
when generating large PDFs, doubling memory usage may be troublesome.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def unbreakable(self):
    &#34;&#34;&#34;
    Ensures that all rendering performed in this context appear on a single page
    by performing page break beforehand if need be.

    Notes
    -----

    Using this method means to duplicate the FPDF `bytearray` buffer:
    when generating large PDFs, doubling memory usage may be troublesome.
    &#34;&#34;&#34;
    prev_page, prev_y = self.page, self.y
    recorder = FPDFRecorder(self, accept_page_break=False)
    LOGGER.debug(&#34;Starting unbreakable block&#34;)
    yield recorder
    y_scroll = recorder.y - prev_y + (recorder.page - prev_page) * self.eph
    if prev_y + y_scroll &gt; self.page_break_trigger or recorder.page &gt; prev_page:
        LOGGER.debug(&#34;Performing page jump due to unbreakable height&#34;)
        recorder.rewind()
        # pylint: disable=protected-access
        # Performing this call through .pdf so that it does not get recorded &amp; replayed:
        recorder.pdf._perform_page_break()
        recorder.replay()
    LOGGER.debug(&#34;Ending unbreakable block&#34;)</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.will_page_break"><code class="name flex">
<span>def <span class="ident">will_page_break</span></span>(<span>self, height)</span>
</code></dt>
<dd>
<div class="desc"><p>Let you know if adding an element will trigger a page break,
based on its height and the current ordinate (<code>y</code> position).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>height</code></strong> :&ensp;<code>float</code></dt>
<dd>height of the section that would be added, e.g. a cell</dd>
</dl>
<p>Returns: a boolean indicating if a page break would occur</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def will_page_break(self, height):
    &#34;&#34;&#34;
    Let you know if adding an element will trigger a page break,
    based on its height and the current ordinate (`y` position).

    Args:
        height (float): height of the section that would be added, e.g. a cell

    Returns: a boolean indicating if a page break would occur
    &#34;&#34;&#34;
    return (
        self.y + height &gt; self.page_break_trigger
        and not self.in_footer
        and self.accept_page_break
    )</code></pre>
</details>
</dd>
<dt id="fpdf.FPDF.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, h: float = None, txt: str = '', link: str = '', print_sh: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints text from the current position.
When the right margin is reached, a line break occurs at the most recent
space or soft-hyphen character, and text continues from the left margin.
A manual break happens any time the \n character is met,
Upon method exit, the current position is left just at the end of the text.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>line height. Default value: None, meaning to use the current font size.</dd>
<dt><strong><code>txt</code></strong> :&ensp;<code>str</code></dt>
<dd>text content</dd>
<dt><strong><code>link</code></strong> :&ensp;<code>str</code></dt>
<dd>optional link to add on the text, internal
(identifier returned by <code>add_link</code>) or external URL.</dd>
<dt><strong><code>print_sh</code></strong> :&ensp;<code>bool</code></dt>
<dd>Treat a soft-hyphen (\u00ad) as a normal printable
character, instead of a line breaking opportunity. Default value: False</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@check_page
def write(
    self, h: float = None, txt: str = &#34;&#34;, link: str = &#34;&#34;, print_sh: bool = False
):
    &#34;&#34;&#34;
    Prints text from the current position.
    When the right margin is reached, a line break occurs at the most recent
    space or soft-hyphen character, and text continues from the left margin.
    A manual break happens any time the \\n character is met,
    Upon method exit, the current position is left just at the end of the text.

    Args:
        h (float): line height. Default value: None, meaning to use the current font size.
        txt (str): text content
        link (str): optional link to add on the text, internal
            (identifier returned by `add_link`) or external URL.
        print_sh (bool): Treat a soft-hyphen (\\u00ad) as a normal printable
            character, instead of a line breaking opportunity. Default value: False
    &#34;&#34;&#34;
    if not self.font_family:
        raise FPDFException(&#34;No font set, you need to call set_font() beforehand&#34;)
    if isinstance(h, str):
        raise ValueError(
            &#34;Parameter &#39;h&#39; must be a number, not a string.&#34;
            &#34; You can omit it by passing string content with txt=&#34;
        )
    if h is None:
        h = self.font_size

    page_break_triggered = False
    normalized_string = self.normalize_text(txt).replace(&#34;\r&#34;, &#34;&#34;)
    styled_text_fragments = self._preload_font_styles(normalized_string, False)

    text_lines = []
    multi_line_break = MultiLineBreak(
        styled_text_fragments,
        self.get_normalized_string_width_with_style,
        print_sh=print_sh,
    )
    prev_x = self.x
    # first line from current x position to right margin
    first_width = self.w - prev_x - self.r_margin
    first_emwidth = (first_width - 2 * self.c_margin) * 1000 / self.font_size
    text_line = multi_line_break.get_line_of_given_width(
        first_emwidth, wordsplit=False
    )
    # remaining lines fill between margins
    full_width = self.w - self.l_margin - self.r_margin
    full_emwidth = (full_width - 2 * self.c_margin) * 1000 / self.font_size
    while (text_line) is not None:
        text_lines.append(text_line)
        text_line = multi_line_break.get_line_of_given_width(full_emwidth)
    if text_line:
        text_lines.append(text_line)
    if not text_lines:
        return False

    self.ws = 0  # currently only left aligned, so no word spacing
    for text_line_index, text_line in enumerate(text_lines):
        if text_line_index == 0:
            line_width = first_width
        else:
            line_width = full_width
            self.ln()
        new_page = self._render_styled_cell_text(
            text_line,
            line_width,
            h=h,
            border=0,
            new_x=XPos.WCONT,
            new_y=YPos.TOP,
            align=&#34;L&#34;,
            fill=False,
            link=link,
        )
        page_break_triggered = page_break_triggered or new_page

    return page_break_triggered</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.FlexTemplate"><code class="flex name class">
<span>class <span class="ident">FlexTemplate</span></span>
<span>(</span><span>pdf, elements=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A flexible templating class.</p>
<p>Allows to apply one or several template definitions to any page of
a document in any combination.</p>
<h2 id="arguments">Arguments</h2>
<p>pdf (fpdf.FPDF() instance):
All content will be added to this object.</p>
<p>elements (list of dicts):
A template definition in a list of dicts.
If you omit this, then you need to call either load_elements()
or parse_csv() before doing anything else.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlexTemplate:
    &#34;&#34;&#34;
    A flexible templating class.

    Allows to apply one or several template definitions to any page of
    a document in any combination.
    &#34;&#34;&#34;

    def __init__(self, pdf, elements=None):
        &#34;&#34;&#34;
        Arguments:

            pdf (fpdf.FPDF() instance):
                All content will be added to this object.

            elements (list of dicts):
                A template definition in a list of dicts.
                If you omit this, then you need to call either load_elements()
                or parse_csv() before doing anything else.
        &#34;&#34;&#34;
        if not isinstance(pdf, FPDF):
            raise TypeError(&#34;&#39;pdf&#39; must be an instance of fpdf.FPDF()&#34;)
        self.pdf = pdf
        self.splitting_pdf = None  # for split_multicell()
        if elements:
            self.load_elements(elements)
        self.handlers = {
            &#34;T&#34;: self._text,
            &#34;L&#34;: self._line,
            &#34;I&#34;: self._image,
            &#34;B&#34;: self._rect,
            &#34;E&#34;: self._ellipse,
            &#34;BC&#34;: self._barcode,
            &#34;C39&#34;: self._code39,
            &#34;W&#34;: self._write,
        }
        self.texts = {}

    def load_elements(self, elements):
        &#34;&#34;&#34;
        Load a template definition.

        Arguments:

            elements (list of dicts):
                A template definition in a list of dicts
        &#34;&#34;&#34;
        key_config = {
            # key: type
            &#34;name&#34;: (str, type(None)),
            &#34;type&#34;: (str, type(None)),
            &#34;x1&#34;: (int, float),
            &#34;y1&#34;: (int, float),
            &#34;x2&#34;: (int, float),
            &#34;y2&#34;: (int, float),
            &#34;font&#34;: (str, type(None)),
            &#34;size&#34;: (int, float),
            &#34;bold&#34;: object,  # &#34;bool or equivalent&#34;
            &#34;italic&#34;: object,
            &#34;underline&#34;: object,
            &#34;foreground&#34;: int,
            &#34;background&#34;: int,
            &#34;align&#34;: (str, type(None)),
            &#34;text&#34;: (str, type(None)),
            &#34;priority&#34;: int,
            &#34;multiline&#34;: (bool, type(None)),
            &#34;rotate&#34;: (int, float),
        }

        self.elements = elements
        self.keys = []
        for e in elements:
            # priority is optional, but we need a default for sorting.
            if not &#34;priority&#34; in e:
                e[&#34;priority&#34;] = 0
            for k in (&#34;name&#34;, &#34;type&#34;, &#34;x1&#34;, &#34;y1&#34;, &#34;y2&#34;):
                if k not in e:
                    if e[&#34;type&#34;] == &#34;C39&#34;:
                        # lots of legacy special casing.
                        # We need to do that here, so that rotation and scaling
                        # still work.
                        if k == &#34;x1&#34; and &#34;x&#34; in e:
                            e[&#34;x1&#34;] = e[&#34;x&#34;]
                            continue
                        if k == &#34;y1&#34; and &#34;y&#34; in e:
                            e[&#34;y1&#34;] = e[&#34;y&#34;]
                            continue
                        if k == &#34;y2&#34; and &#34;h&#34; in e:
                            e[&#34;y2&#34;] = e[&#34;y1&#34;] + e[&#34;h&#34;]
                            continue
                    raise KeyError(f&#34;Mandatory key &#39;{k}&#39; missing in input data&#34;)
            # x2 is optional for barcode types, but needed for offset rendering
            if &#34;x2&#34; not in e:
                if e[&#34;type&#34;] in [&#34;BC&#34;, &#34;C39&#34;]:
                    e[&#34;x2&#34;] = 0
                else:
                    raise KeyError(&#34;Mandatory key &#39;x2&#39; missing in input data&#34;)
            if not &#34;size&#34; in e and e[&#34;type&#34;] == &#34;C39&#34;:
                if &#34;w&#34; in e:
                    e[&#34;size&#34;] = e[&#34;w&#34;]
            for k, t in key_config.items():
                if k in e and not isinstance(e[k], t):
                    # pylint: disable=no-member
                    ttype = (
                        t.__name__
                        if isinstance(t, type)
                        else &#34; or &#34;.join([f&#34;&#39;{x.__name__}&#39;&#34; for x in t])
                    )
                    raise TypeError(
                        f&#34;Value of element item &#39;{k}&#39; must be {ttype}, not &#39;{type(e[k]).__name__}&#39;.&#34;
                    )
            self.keys.append(e[&#34;name&#34;].lower())

    @staticmethod
    def _parse_colorcode(s):
        &#34;&#34;&#34;Allow hex and oct values for colors&#34;&#34;&#34;
        if s[:2] in [&#34;0x&#34;, &#34;0X&#34;]:
            return int(s, 16)
        if s[0] == &#34;0&#34;:
            return int(s, 8)
        return int(s)

    @staticmethod
    def _parse_multiline(s):
        i = int(s)
        if i &gt; 0:
            return True
        if i &lt; 0:
            return False
        return None

    def parse_csv(self, infile, delimiter=&#34;,&#34;, decimal_sep=&#34;.&#34;, encoding=None):
        &#34;&#34;&#34;
        Load the template definition from a CSV file.

        Arguments:

            infile (string):
                The filename of the CSV file.

            delimiter (single character):
                The character that seperates the fields in the CSV file:
                Usually a comma, semicolon, or tab.

            decimal_sep (single character):
                The decimal separator used in the file.
                Usually either a point or a comma.

            encoding (string):
                The character encoding of the file.
                Default is the system default encoding.

        &#34;&#34;&#34;

        def _varsep_float(s, default=&#34;0&#34;):
            &#34;&#34;&#34;Convert to float with given decimal seperator&#34;&#34;&#34;
            # glad to have nonlocal scoping...
            return float((s.strip() or default).replace(decimal_sep, &#34;.&#34;))

        key_config = (
            # key, converter, mandatory
            (&#34;name&#34;, str, True),
            (&#34;type&#34;, str, True),
            (&#34;x1&#34;, _varsep_float, True),
            (&#34;y1&#34;, _varsep_float, True),
            (&#34;x2&#34;, _varsep_float, True),
            (&#34;y2&#34;, _varsep_float, True),
            (&#34;font&#34;, str, False),
            (&#34;size&#34;, _varsep_float, False),
            (&#34;bold&#34;, int, False),
            (&#34;italic&#34;, int, False),
            (&#34;underline&#34;, int, False),
            (&#34;foreground&#34;, self._parse_colorcode, False),
            (&#34;background&#34;, self._parse_colorcode, False),
            (&#34;align&#34;, str, False),
            (&#34;text&#34;, str, False),
            (&#34;priority&#34;, int, False),
            (&#34;multiline&#34;, self._parse_multiline, False),
            (&#34;rotate&#34;, _varsep_float, False),
        )
        self.elements = []
        if encoding is None:
            encoding = locale.getpreferredencoding()
        with open(infile, encoding=encoding) as f:
            for row in csv.reader(f, delimiter=delimiter):
                # fill in blanks for any missing items
                row.extend([&#34;&#34;] * (len(key_config) - len(row)))
                kargs = {}
                for val, cfg in zip(row, key_config):
                    vs = val.strip()
                    if not vs:
                        if cfg[2]:  # mandatory
                            if cfg[0] == &#34;x2&#34; and row[1] in [&#34;BC&#34;, &#34;C39&#34;]:
                                # two types don&#39;t need x2, but offset rendering does
                                pass
                            else:
                                raise FPDFException(
                                    f&#34;Mandatory value &#39;{cfg[0]}&#39; missing in csv data&#34;
                                )
                        elif cfg[0] == &#34;priority&#34;:
                            # formally optional, but we need some value for sorting
                            kargs[&#34;priority&#34;] = 0
                        # otherwise, let the type handlers use their own defaults
                    else:
                        kargs[cfg[0]] = cfg[1](vs)
                self.elements.append(kargs)
        self.keys = [val[&#34;name&#34;].lower() for val in self.elements]

    def __setitem__(self, name, value):
        assert isinstance(
            name, str
        ), f&#34;name must be of type &#39;str&#39;, not &#39;{type(name).__name__}&#39;.&#34;
        # value has too many valid types to reasonably check here
        if name.lower() not in self.keys:
            raise FPDFException(f&#34;Element not loaded, cannot set item: {name}&#34;)
        self.texts[name.lower()] = value

    # setitem shortcut (may be further extended)
    set = __setitem__

    def __contains__(self, name):
        assert isinstance(
            name, str
        ), f&#34;name must be of type &#39;str&#39;, not &#39;{type(name).__name__}&#39;.&#34;
        return name.lower() in self.keys

    def __getitem__(self, name):
        assert isinstance(
            name, str
        ), f&#34;name must be of type &#39;str&#39;, not &#39;{type(name).__name__}&#39;.&#34;
        if name not in self.keys:
            raise KeyError(name)
        key = name.lower()
        if key in self.texts:
            # text for this page:
            return self.texts[key]
        # find first element for default text:
        return next(
            (x[&#34;text&#34;] for x in self.elements if x[&#34;name&#34;].lower() == key), None
        )

    def split_multicell(self, text, element_name):
        &#34;&#34;&#34;
        Split a string between words, for the parts to fit into a given element
        width. Additional splits will be made replacing any &#39;\\n&#39; characters.

        Arguments:

            text (string):
                The input text string.

            element_name (string):
                The name of the template element to fit the text inside.

        Returns:
            A list of substrings, each of which will fit into the element width
            when rendered in the element font style and size.
        &#34;&#34;&#34;
        element = next(
            element
            for element in self.elements
            if element[&#34;name&#34;].lower() == element_name.lower()
        )
        if not self.splitting_pdf:
            self.splitting_pdf = FPDF()
            self.splitting_pdf.add_page()
        style = &#34;&#34;
        if element[&#34;bold&#34;]:
            style += &#34;B&#34;
        if element[&#34;italic&#34;]:
            style += &#34;I&#34;
        if element[&#34;underline&#34;]:
            style += &#34;U&#34;
        self.splitting_pdf.set_font(element[&#34;font&#34;], style, element[&#34;size&#34;])
        return self.splitting_pdf.multi_cell(
            w=element[&#34;x2&#34;] - element[&#34;x1&#34;],
            h=element[&#34;y2&#34;] - element[&#34;y1&#34;],
            txt=str(text),
            align=element[&#34;align&#34;],
            split_only=True,
        )

    def _text(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;helvetica&#34;,
        size=10,
        scale=1.0,
        bold=False,
        italic=False,
        underline=False,
        align=&#34;&#34;,
        foreground=0,
        background=None,
        multiline=None,
        **__,
    ):
        if not text:
            return
        pdf = self.pdf
        if pdf.text_color != _rgb_as_str(foreground):
            pdf.set_text_color(*_rgb(foreground))
        if background is None:
            fill = False
        else:
            fill = True
            if pdf.fill_color != _rgb_as_str(background):
                pdf.set_fill_color(*_rgb(background))

        font = font.strip().lower()
        style = &#34;&#34;
        for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
            if text.startswith(f&#34;&lt;{tag}&gt;&#34;) and text.endswith(f&#34;&lt;/{tag}&gt;&#34;):
                text = text[3:-4]
                style += tag
        if bold:
            style += &#34;B&#34;
        if italic:
            style += &#34;I&#34;
        if underline:
            style += &#34;U&#34;
        pdf.set_font(font, style, size * scale)
        pdf.set_xy(x1, y1)
        width, height = x2 - x1, y2 - y1
        if multiline is None:  # write without wrapping/trimming (default)
            pdf.cell(
                w=width, h=height, txt=text, border=0, ln=0, align=align, fill=fill
            )
        elif multiline:  # automatic word - warp
            pdf.multi_cell(
                w=width, h=height, txt=text, border=0, align=align, fill=fill
            )
        else:  # trim to fit exactly the space defined
            text = pdf.multi_cell(
                w=width, h=height, txt=text, align=align, split_only=True
            )[0]
            pdf.cell(
                w=width, h=height, txt=text, border=0, ln=0, align=align, fill=fill
            )

    def _line(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        size=0,
        scale=1.0,
        foreground=0,
        **__,
    ):
        if self.pdf.draw_color.lower() != _rgb_as_str(foreground):
            self.pdf.set_draw_color(*_rgb(foreground))
        self.pdf.set_line_width(size * scale)
        self.pdf.line(x1, y1, x2, y2)

    def _rect(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        size=0,
        scale=1.0,
        foreground=0,
        background=None,
        **__,
    ):
        pdf = self.pdf
        if pdf.draw_color.lower() != _rgb_as_str(foreground):
            pdf.set_draw_color(*_rgb(foreground))
        if background is None:
            style = &#34;D&#34;
        else:
            style = &#34;FD&#34;
            if pdf.fill_color != _rgb_as_str(background):
                pdf.set_fill_color(*_rgb(background))
        pdf.set_line_width(size * scale)
        pdf.rect(x1, y1, x2 - x1, y2 - y1, style=style)

    def _ellipse(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        size=0,
        scale=1.0,
        foreground=0,
        background=None,
        **__,
    ):
        pdf = self.pdf
        if pdf.draw_color.lower() != _rgb_as_str(foreground):
            pdf.set_draw_color(*_rgb(foreground))
        if background is None:
            style = &#34;D&#34;
        else:
            style = &#34;FD&#34;
            if pdf.fill_color != _rgb_as_str(background):
                pdf.set_fill_color(*_rgb(background))
        pdf.set_line_width(size * scale)
        pdf.ellipse(x1, y1, x2 - x1, y2 - y1, style=style)

    def _image(self, *_, x1=0, y1=0, x2=0, y2=0, text=&#34;&#34;, **__):
        if text:
            self.pdf.image(text, x1, y1, w=x2 - x1, h=y2 - y1, link=&#34;&#34;)

    def _barcode(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;interleaved 2of5 nt&#34;,
        size=1,
        scale=1.0,
        foreground=0,
        **__,
    ):
        # pylint: disable=unused-argument
        pdf = self.pdf
        if pdf.fill_color.lower() != _rgb_as_str(foreground):
            pdf.set_fill_color(*_rgb(foreground))
        font = font.lower().strip()
        if font == &#34;interleaved 2of5 nt&#34;:
            pdf.interleaved2of5(text, x1, y1, w=size * scale, h=y2 - y1)

    def _code39(
        self,
        *_,
        x1=0,
        y1=0,
        y2=0,
        text=&#34;&#34;,
        size=1.5,
        scale=1.0,
        foreground=0,
        x=None,
        y=None,
        w=None,
        h=None,
        **__,
    ):
        if x is not None or y is not None or w is not None or h is not None:
            warnings.warn(
                &#34;code39 arguments x/y/w/h are deprecated, please use x1/y1/y2/size instead&#34;,
                DeprecationWarning,
            )
        pdf = self.pdf
        if pdf.fill_color.lower() != _rgb_as_str(foreground):
            pdf.set_fill_color(*_rgb(foreground))
        h = y2 - y1
        if h &lt;= 0:
            h = 5
        pdf.code39(text, x1, y1, size * scale, h)

    # Added by Derek Schwalenberg Schwalenberg1013@gmail.com to allow (url) links in
    # templates (using write method) 2014-02-22
    def _write(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;helvetica&#34;,
        size=10,
        scale=1.0,
        bold=False,
        italic=False,
        underline=False,
        link=&#34;&#34;,
        foreground=0,
        **__,
    ):
        # pylint: disable=unused-argument
        if not text:
            return
        pdf = self.pdf
        if pdf.text_color != _rgb_as_str(foreground):
            pdf.set_text_color(*_rgb(foreground))
        font = font.strip().lower()
        style = &#34;&#34;
        for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
            if text.startswith(f&#34;&lt;{tag}&gt;&#34;) and text.endswith(f&#34;&lt;/{tag}&gt;&#34;):
                text = text[3:-4]
                style += tag
        if bold:
            style += &#34;B&#34;
        if italic:
            style += &#34;I&#34;
        if underline:
            style += &#34;U&#34;
        pdf.set_font(font, style, size * scale)
        pdf.set_xy(x1, y1)
        pdf.write(5, text, link)

    def render(self, offsetx=0.0, offsety=0.0, rotate=0.0, scale=1.0):
        &#34;&#34;&#34;
        Add the contents of the template to the PDF document.

        Arguments:

            offsetx, offsety (float):
                Place the template to move its origin to the given coordinates.

            rotate (float):
                Rotate the inserted template around its (offset) origin.

            scale (float):
                Scale the inserted template by this factor.
        &#34;&#34;&#34;
        sorted_elements = sorted(self.elements, key=lambda x: x[&#34;priority&#34;])
        for element in sorted_elements:
            ele = element.copy()  # don&#39;t want to modify the callers original
            ele[&#34;text&#34;] = self.texts.get(ele[&#34;name&#34;].lower(), ele.get(&#34;text&#34;, &#34;&#34;))
            if scale != 1.0:
                ele[&#34;x1&#34;] = ele[&#34;x1&#34;] * scale
                ele[&#34;y1&#34;] = ele[&#34;y1&#34;] * scale
                ele[&#34;x2&#34;] = ele[&#34;x1&#34;] + ((ele[&#34;x2&#34;] - element[&#34;x1&#34;]) * scale)
                ele[&#34;y2&#34;] = ele[&#34;y1&#34;] + ((ele[&#34;y2&#34;] - element[&#34;y1&#34;]) * scale)
            if offsetx:
                ele[&#34;x1&#34;] = ele[&#34;x1&#34;] + offsetx
                ele[&#34;x2&#34;] = ele[&#34;x2&#34;] + offsetx
            if offsety:
                ele[&#34;y1&#34;] = ele[&#34;y1&#34;] + offsety
                ele[&#34;y2&#34;] = ele[&#34;y2&#34;] + offsety
            ele[&#34;scale&#34;] = scale
            handler_name = ele[&#34;type&#34;].upper()
            if rotate:  # don&#39;t rotate by 0.0 degrees
                with self.pdf.rotation(rotate, offsetx, offsety):
                    if &#34;rotate&#34; in ele and ele[&#34;rotate&#34;]:
                        with self.pdf.rotation(ele[&#34;rotate&#34;], ele[&#34;x1&#34;], ele[&#34;y1&#34;]):
                            self.handlers[handler_name](**ele)
                    else:
                        self.handlers[handler_name](**ele)
            else:
                if &#34;rotate&#34; in ele and ele[&#34;rotate&#34;]:
                    with self.pdf.rotation(ele[&#34;rotate&#34;], ele[&#34;x1&#34;], ele[&#34;y1&#34;]):
                        self.handlers[handler_name](**ele)
                else:
                    self.handlers[handler_name](**ele)
        self.texts = {}  # reset modified entries for the next page</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fpdf.template.Template" href="template.html#fpdf.template.Template">Template</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.FlexTemplate.load_elements"><code class="name flex">
<span>def <span class="ident">load_elements</span></span>(<span>self, elements)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a template definition.</p>
<h2 id="arguments">Arguments</h2>
<p>elements (list of dicts):
A template definition in a list of dicts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_elements(self, elements):
    &#34;&#34;&#34;
    Load a template definition.

    Arguments:

        elements (list of dicts):
            A template definition in a list of dicts
    &#34;&#34;&#34;
    key_config = {
        # key: type
        &#34;name&#34;: (str, type(None)),
        &#34;type&#34;: (str, type(None)),
        &#34;x1&#34;: (int, float),
        &#34;y1&#34;: (int, float),
        &#34;x2&#34;: (int, float),
        &#34;y2&#34;: (int, float),
        &#34;font&#34;: (str, type(None)),
        &#34;size&#34;: (int, float),
        &#34;bold&#34;: object,  # &#34;bool or equivalent&#34;
        &#34;italic&#34;: object,
        &#34;underline&#34;: object,
        &#34;foreground&#34;: int,
        &#34;background&#34;: int,
        &#34;align&#34;: (str, type(None)),
        &#34;text&#34;: (str, type(None)),
        &#34;priority&#34;: int,
        &#34;multiline&#34;: (bool, type(None)),
        &#34;rotate&#34;: (int, float),
    }

    self.elements = elements
    self.keys = []
    for e in elements:
        # priority is optional, but we need a default for sorting.
        if not &#34;priority&#34; in e:
            e[&#34;priority&#34;] = 0
        for k in (&#34;name&#34;, &#34;type&#34;, &#34;x1&#34;, &#34;y1&#34;, &#34;y2&#34;):
            if k not in e:
                if e[&#34;type&#34;] == &#34;C39&#34;:
                    # lots of legacy special casing.
                    # We need to do that here, so that rotation and scaling
                    # still work.
                    if k == &#34;x1&#34; and &#34;x&#34; in e:
                        e[&#34;x1&#34;] = e[&#34;x&#34;]
                        continue
                    if k == &#34;y1&#34; and &#34;y&#34; in e:
                        e[&#34;y1&#34;] = e[&#34;y&#34;]
                        continue
                    if k == &#34;y2&#34; and &#34;h&#34; in e:
                        e[&#34;y2&#34;] = e[&#34;y1&#34;] + e[&#34;h&#34;]
                        continue
                raise KeyError(f&#34;Mandatory key &#39;{k}&#39; missing in input data&#34;)
        # x2 is optional for barcode types, but needed for offset rendering
        if &#34;x2&#34; not in e:
            if e[&#34;type&#34;] in [&#34;BC&#34;, &#34;C39&#34;]:
                e[&#34;x2&#34;] = 0
            else:
                raise KeyError(&#34;Mandatory key &#39;x2&#39; missing in input data&#34;)
        if not &#34;size&#34; in e and e[&#34;type&#34;] == &#34;C39&#34;:
            if &#34;w&#34; in e:
                e[&#34;size&#34;] = e[&#34;w&#34;]
        for k, t in key_config.items():
            if k in e and not isinstance(e[k], t):
                # pylint: disable=no-member
                ttype = (
                    t.__name__
                    if isinstance(t, type)
                    else &#34; or &#34;.join([f&#34;&#39;{x.__name__}&#39;&#34; for x in t])
                )
                raise TypeError(
                    f&#34;Value of element item &#39;{k}&#39; must be {ttype}, not &#39;{type(e[k]).__name__}&#39;.&#34;
                )
        self.keys.append(e[&#34;name&#34;].lower())</code></pre>
</details>
</dd>
<dt id="fpdf.FlexTemplate.parse_csv"><code class="name flex">
<span>def <span class="ident">parse_csv</span></span>(<span>self, infile, delimiter=',', decimal_sep='.', encoding=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the template definition from a CSV file.</p>
<h2 id="arguments">Arguments</h2>
<p>infile (string):
The filename of the CSV file.</p>
<p>delimiter (single character):
The character that seperates the fields in the CSV file:
Usually a comma, semicolon, or tab.</p>
<p>decimal_sep (single character):
The decimal separator used in the file.
Usually either a point or a comma.</p>
<p>encoding (string):
The character encoding of the file.
Default is the system default encoding.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_csv(self, infile, delimiter=&#34;,&#34;, decimal_sep=&#34;.&#34;, encoding=None):
    &#34;&#34;&#34;
    Load the template definition from a CSV file.

    Arguments:

        infile (string):
            The filename of the CSV file.

        delimiter (single character):
            The character that seperates the fields in the CSV file:
            Usually a comma, semicolon, or tab.

        decimal_sep (single character):
            The decimal separator used in the file.
            Usually either a point or a comma.

        encoding (string):
            The character encoding of the file.
            Default is the system default encoding.

    &#34;&#34;&#34;

    def _varsep_float(s, default=&#34;0&#34;):
        &#34;&#34;&#34;Convert to float with given decimal seperator&#34;&#34;&#34;
        # glad to have nonlocal scoping...
        return float((s.strip() or default).replace(decimal_sep, &#34;.&#34;))

    key_config = (
        # key, converter, mandatory
        (&#34;name&#34;, str, True),
        (&#34;type&#34;, str, True),
        (&#34;x1&#34;, _varsep_float, True),
        (&#34;y1&#34;, _varsep_float, True),
        (&#34;x2&#34;, _varsep_float, True),
        (&#34;y2&#34;, _varsep_float, True),
        (&#34;font&#34;, str, False),
        (&#34;size&#34;, _varsep_float, False),
        (&#34;bold&#34;, int, False),
        (&#34;italic&#34;, int, False),
        (&#34;underline&#34;, int, False),
        (&#34;foreground&#34;, self._parse_colorcode, False),
        (&#34;background&#34;, self._parse_colorcode, False),
        (&#34;align&#34;, str, False),
        (&#34;text&#34;, str, False),
        (&#34;priority&#34;, int, False),
        (&#34;multiline&#34;, self._parse_multiline, False),
        (&#34;rotate&#34;, _varsep_float, False),
    )
    self.elements = []
    if encoding is None:
        encoding = locale.getpreferredencoding()
    with open(infile, encoding=encoding) as f:
        for row in csv.reader(f, delimiter=delimiter):
            # fill in blanks for any missing items
            row.extend([&#34;&#34;] * (len(key_config) - len(row)))
            kargs = {}
            for val, cfg in zip(row, key_config):
                vs = val.strip()
                if not vs:
                    if cfg[2]:  # mandatory
                        if cfg[0] == &#34;x2&#34; and row[1] in [&#34;BC&#34;, &#34;C39&#34;]:
                            # two types don&#39;t need x2, but offset rendering does
                            pass
                        else:
                            raise FPDFException(
                                f&#34;Mandatory value &#39;{cfg[0]}&#39; missing in csv data&#34;
                            )
                    elif cfg[0] == &#34;priority&#34;:
                        # formally optional, but we need some value for sorting
                        kargs[&#34;priority&#34;] = 0
                    # otherwise, let the type handlers use their own defaults
                else:
                    kargs[cfg[0]] = cfg[1](vs)
            self.elements.append(kargs)
    self.keys = [val[&#34;name&#34;].lower() for val in self.elements]</code></pre>
</details>
</dd>
<dt id="fpdf.FlexTemplate.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, offsetx=0.0, offsety=0.0, rotate=0.0, scale=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the contents of the template to the PDF document.</p>
<h2 id="arguments">Arguments</h2>
<p>offsetx, offsety (float):
Place the template to move its origin to the given coordinates.</p>
<p>rotate (float):
Rotate the inserted template around its (offset) origin.</p>
<p>scale (float):
Scale the inserted template by this factor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, offsetx=0.0, offsety=0.0, rotate=0.0, scale=1.0):
    &#34;&#34;&#34;
    Add the contents of the template to the PDF document.

    Arguments:

        offsetx, offsety (float):
            Place the template to move its origin to the given coordinates.

        rotate (float):
            Rotate the inserted template around its (offset) origin.

        scale (float):
            Scale the inserted template by this factor.
    &#34;&#34;&#34;
    sorted_elements = sorted(self.elements, key=lambda x: x[&#34;priority&#34;])
    for element in sorted_elements:
        ele = element.copy()  # don&#39;t want to modify the callers original
        ele[&#34;text&#34;] = self.texts.get(ele[&#34;name&#34;].lower(), ele.get(&#34;text&#34;, &#34;&#34;))
        if scale != 1.0:
            ele[&#34;x1&#34;] = ele[&#34;x1&#34;] * scale
            ele[&#34;y1&#34;] = ele[&#34;y1&#34;] * scale
            ele[&#34;x2&#34;] = ele[&#34;x1&#34;] + ((ele[&#34;x2&#34;] - element[&#34;x1&#34;]) * scale)
            ele[&#34;y2&#34;] = ele[&#34;y1&#34;] + ((ele[&#34;y2&#34;] - element[&#34;y1&#34;]) * scale)
        if offsetx:
            ele[&#34;x1&#34;] = ele[&#34;x1&#34;] + offsetx
            ele[&#34;x2&#34;] = ele[&#34;x2&#34;] + offsetx
        if offsety:
            ele[&#34;y1&#34;] = ele[&#34;y1&#34;] + offsety
            ele[&#34;y2&#34;] = ele[&#34;y2&#34;] + offsety
        ele[&#34;scale&#34;] = scale
        handler_name = ele[&#34;type&#34;].upper()
        if rotate:  # don&#39;t rotate by 0.0 degrees
            with self.pdf.rotation(rotate, offsetx, offsety):
                if &#34;rotate&#34; in ele and ele[&#34;rotate&#34;]:
                    with self.pdf.rotation(ele[&#34;rotate&#34;], ele[&#34;x1&#34;], ele[&#34;y1&#34;]):
                        self.handlers[handler_name](**ele)
                else:
                    self.handlers[handler_name](**ele)
        else:
            if &#34;rotate&#34; in ele and ele[&#34;rotate&#34;]:
                with self.pdf.rotation(ele[&#34;rotate&#34;], ele[&#34;x1&#34;], ele[&#34;y1&#34;]):
                    self.handlers[handler_name](**ele)
            else:
                self.handlers[handler_name](**ele)
    self.texts = {}  # reset modified entries for the next page</code></pre>
</details>
</dd>
<dt id="fpdf.FlexTemplate.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __setitem__(self, name, value):
    assert isinstance(
        name, str
    ), f&#34;name must be of type &#39;str&#39;, not &#39;{type(name).__name__}&#39;.&#34;
    # value has too many valid types to reasonably check here
    if name.lower() not in self.keys:
        raise FPDFException(f&#34;Element not loaded, cannot set item: {name}&#34;)
    self.texts[name.lower()] = value</code></pre>
</details>
</dd>
<dt id="fpdf.FlexTemplate.split_multicell"><code class="name flex">
<span>def <span class="ident">split_multicell</span></span>(<span>self, text, element_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Split a string between words, for the parts to fit into a given element
width. Additional splits will be made replacing any '\n' characters.</p>
<h2 id="arguments">Arguments</h2>
<p>text (string):
The input text string.</p>
<p>element_name (string):
The name of the template element to fit the text inside.</p>
<h2 id="returns">Returns</h2>
<p>A list of substrings, each of which will fit into the element width
when rendered in the element font style and size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_multicell(self, text, element_name):
    &#34;&#34;&#34;
    Split a string between words, for the parts to fit into a given element
    width. Additional splits will be made replacing any &#39;\\n&#39; characters.

    Arguments:

        text (string):
            The input text string.

        element_name (string):
            The name of the template element to fit the text inside.

    Returns:
        A list of substrings, each of which will fit into the element width
        when rendered in the element font style and size.
    &#34;&#34;&#34;
    element = next(
        element
        for element in self.elements
        if element[&#34;name&#34;].lower() == element_name.lower()
    )
    if not self.splitting_pdf:
        self.splitting_pdf = FPDF()
        self.splitting_pdf.add_page()
    style = &#34;&#34;
    if element[&#34;bold&#34;]:
        style += &#34;B&#34;
    if element[&#34;italic&#34;]:
        style += &#34;I&#34;
    if element[&#34;underline&#34;]:
        style += &#34;U&#34;
    self.splitting_pdf.set_font(element[&#34;font&#34;], style, element[&#34;size&#34;])
    return self.splitting_pdf.multi_cell(
        w=element[&#34;x2&#34;] - element[&#34;x1&#34;],
        h=element[&#34;y2&#34;] - element[&#34;y1&#34;],
        txt=str(text),
        align=element[&#34;align&#34;],
        split_only=True,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.HTML2FPDF"><code class="flex name class">
<span>class <span class="ident">HTML2FPDF</span></span>
<span>(</span><span>pdf, image_map=None, li_tag_indent=5, table_line_separators=False, ul_bullet_char='\x95', heading_sizes=None, **_)</span>
</code></dt>
<dd>
<div class="desc"><p>Render basic HTML to FPDF</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pdf</code></strong> :&ensp;<code><a title="fpdf.FPDF" href="#fpdf.FPDF">FPDF</a></code></dt>
<dd>an instance of <code><a title="fpdf.FPDF" href="#fpdf.FPDF">FPDF</a></code></dd>
<dt><strong><code>image_map</code></strong> :&ensp;<code>function</code></dt>
<dd>an optional one-argument function that map <img> "src"
to new image URLs</dd>
<dt><strong><code>li_tag_indent</code></strong> :&ensp;<code>int</code></dt>
<dd>numeric indentation of <li> elements</dd>
<dt><strong><code>table_line_separators</code></strong> :&ensp;<code>bool</code></dt>
<dd>enable horizontal line separators in <table></dd>
<dt><strong><code>ul_bullet_char</code></strong> :&ensp;<code>str</code></dt>
<dd>bullet character for <ul> elements</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HTML2FPDF(HTMLParser):
    &#34;&#34;&#34;Render basic HTML to FPDF&#34;&#34;&#34;

    def __init__(
        self,
        pdf,
        image_map=None,
        li_tag_indent=5,
        table_line_separators=False,
        ul_bullet_char=BULLET_WIN1252,
        heading_sizes=None,
        **_,
    ):
        &#34;&#34;&#34;
        Args:
            pdf (FPDF): an instance of `fpdf.FPDF`
            image_map (function): an optional one-argument function that map &lt;img&gt; &#34;src&#34;
                to new image URLs
            li_tag_indent (int): numeric indentation of &lt;li&gt; elements
            table_line_separators (bool): enable horizontal line separators in &lt;table&gt;
            ul_bullet_char (str): bullet character for &lt;ul&gt; elements
        &#34;&#34;&#34;
        super().__init__()
        self.pdf = pdf
        self.image_map = image_map or (lambda src: src)
        self.li_tag_indent = li_tag_indent
        self.table_line_separators = table_line_separators
        self.ul_bullet_char = ul_bullet_char
        self.style = dict(b=False, i=False, u=False)
        self.href = &#34;&#34;
        self.align = &#34;&#34;
        self.page_links = {}
        self.font_stack = []
        self.indent = 0
        self.bullet = []
        self.font_size = pdf.font_size_pt
        self.set_font(pdf.font_family or &#34;times&#34;, size=self.font_size)
        self.font_color = 0, 0, 0  # initialize font color, r,g,b format
        self.table = None  # table attributes
        self.table_col_width = None  # column (header) widths
        self.table_col_index = None  # current column index
        self.td = None  # inside a &lt;td&gt;, attributes dict
        self.th = None  # inside a &lt;th&gt;, attributes dict
        self.tr = None  # inside a &lt;tr&gt;, attributes dict
        self.thead = None  # inside a &lt;thead&gt;, attributes dict
        self.tfoot = None  # inside a &lt;tfoot&gt;, attributes dict
        self.tr_index = None  # row index
        self.theader = None  # table header cells
        self.tfooter = None  # table footer cells
        self.theader_out = self.tfooter_out = False
        self.table_row_height = 0
        self.heading_level = None
        self.heading_sizes = dict(**DEFAULT_HEADING_SIZES)
        if heading_sizes:
            self.heading_sizes.update(heading_sizes)
        self._only_imgs_in_td = False

    def width2unit(self, length):
        &#34;Handle conversion of % measures into the measurement unit used&#34;
        if length[-1] == &#34;%&#34;:
            total = self.pdf.w - self.pdf.r_margin - self.pdf.l_margin
            if self.table[&#34;width&#34;][-1] == &#34;%&#34;:
                total *= int(self.table[&#34;width&#34;][:-1]) / 100
            return int(length[:-1]) * total / 100
        return int(length)

    def handle_data(self, data):
        if self.td is not None:  # drawing a table?
            self._insert_td(data)
        elif self.table is not None:
            # ignore anything else than td inside a table
            pass
        elif self.align:
            LOGGER.debug(&#34;align &#39;%s&#39;&#34;, data.replace(&#34;\n&#34;, &#34;\\n&#34;))
            self.pdf.multi_cell(
                0,
                self.h,
                data,
                border=0,
                ln=1,
                align=self.align[0].upper(),
                link=self.href,
            )
        else:
            data = data.replace(&#34;\n&#34;, &#34; &#34;)
            if self.href:
                self.put_link(data)
            else:
                if self.heading_level:
                    self.pdf.start_section(data, self.heading_level - 1)
                LOGGER.debug(&#34;write &#39;%s&#39; h=%d&#34;, data.replace(&#34;\n&#34;, &#34;\\n&#34;), self.h)
                self.pdf.write(self.h, data)

    def _insert_td(self, data=&#34;&#34;):
        self._only_imgs_in_td = False
        width = self._td_width()
        height = int(self.td.get(&#34;height&#34;, 0)) // 4 or self.h * 1.30
        if not self.table_row_height:
            self.table_row_height = height
        elif self.table_row_height &gt; height:
            height = self.table_row_height
        border = int(self.table.get(&#34;border&#34;, 0))
        if self.th:
            self.set_style(&#34;B&#34;, True)
            border = border or &#34;B&#34;
            align = self.td.get(&#34;align&#34;, &#34;C&#34;)[0].upper()
        else:
            align = self.td.get(&#34;align&#34;, &#34;L&#34;)[0].upper()
            border = border and &#34;LR&#34;
        bgcolor = color_as_decimal(self.td.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, &#34;&#34;)))
        # parsing table header/footer (drawn later):
        if self.thead is not None:
            self.theader.append(((width, height, data, border, 0, align), bgcolor))
        if self.tfoot is not None:
            self.tfooter.append(((width, height, data, border, 0, align), bgcolor))
        # check if reached end of page, add table footer and header:
        if self.tfooter:
            height += self.tfooter[0][0][1]
        if self.pdf.y + height &gt; self.pdf.page_break_trigger and not self.th:
            self.output_table_footer()
            self.pdf.add_page(same=True)
            self.theader_out = self.tfooter_out = False
        if self.tfoot is None and self.thead is None:
            if not self.theader_out:
                self.output_table_header()
            self.box_shadow(width, height, bgcolor)
            # self.pdf.x may have shifted due to &lt;img&gt; inside &lt;td&gt;:
            self.pdf.set_x(self._td_x())
            LOGGER.debug(
                &#34;td cell x=%d width=%d height=%d border=%s align=%s &#39;%s&#39;&#34;,
                self.pdf.x,
                width,
                height,
                border,
                align,
                data.replace(&#34;\n&#34;, &#34;\\n&#34;),
            )
            self.pdf.cell(width, height, data, border=border, ln=0, align=align)

    def _td_x(self):
        &#34;Return the current table cell left side horizontal position&#34;
        prev_cells_total_width = sum(
            self.width2unit(width)
            for width in self.table_col_width[: self.table_col_index]
        )
        return self.table_offset + prev_cells_total_width

    def _td_width(self):
        &#34;Return the current table cell width&#34;
        # pylint: disable=raise-missing-from
        if &#34;width&#34; in self.td:
            column_widths = [self.td[&#34;width&#34;]]
        elif &#34;colspan&#34; in self.td:
            i = self.table_col_index
            colspan = int(self.td[&#34;colspan&#34;])
            column_widths = self.table_col_width[i : i + colspan]
        else:
            try:
                column_widths = [self.table_col_width[self.table_col_index]]
            except IndexError:
                raise ValueError(
                    f&#34;Width not specified for table column {self.table_col_index},&#34;
                    &#34; unable to continue&#34;
                )
        return sum(self.width2unit(width) for width in column_widths)

    def box_shadow(self, w, h, bgcolor):
        LOGGER.debug(&#34;box_shadow w=%d h=%d bgcolor=%s&#34;, w, h, bgcolor)
        if bgcolor:
            fill_color = self.pdf.fill_color
            self.pdf.set_fill_color(*bgcolor)
            self.pdf.rect(self.pdf.x, self.pdf.y, w, h, &#34;F&#34;)
            self.pdf.fill_color = fill_color

    def output_table_header(self):
        if self.theader:
            b = self.style.get(&#34;b&#34;)
            self.pdf.set_x(self.table_offset)
            self.set_style(&#34;b&#34;, True)
            for cell, bgcolor in self.theader:
                self.box_shadow(cell[0], cell[1], bgcolor)
                self.pdf.cell(*cell)  # includes the border
            self.set_style(&#34;b&#34;, b)
            self.pdf.ln(self.theader[0][0][1])
            self.pdf.set_x(self.table_offset)
            # self.pdf.set_x(prev_x)
        self.theader_out = True

    def output_table_footer(self):
        if self.tfooter:
            x = self.pdf.x
            self.pdf.set_x(self.table_offset)
            for cell, bgcolor in self.tfooter:
                self.box_shadow(cell[0], cell[1], bgcolor)
                self.pdf.cell(*cell)
            self.pdf.ln(self.tfooter[0][0][1])
            self.pdf.set_x(x)
        if self.table.get(&#34;border&#34;):
            self.output_table_sep()
        self.tfooter_out = True

    def output_table_sep(self):
        x1 = self.pdf.x
        y1 = self.pdf.y
        width = sum(self.width2unit(length) for length in self.table_col_width)
        self.pdf.line(x1, y1, x1 + width, y1)

    def handle_starttag(self, tag, attrs):
        attrs = dict(attrs)
        LOGGER.debug(&#34;STARTTAG %s %s&#34;, tag, attrs)
        if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
            self.set_style(tag, True)
        if tag == &#34;a&#34;:
            self.href = attrs[&#34;href&#34;]
        if tag == &#34;br&#34;:
            self.pdf.ln(self.h)
        if tag == &#34;p&#34;:
            self.pdf.ln(self.h)
            if attrs:
                self.align = attrs.get(&#34;align&#34;)
        if tag in self.heading_sizes:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.heading_level = int(tag[1:])
            hsize = self.heading_sizes[tag]
            self.pdf.set_text_color(150, 0, 0)
            self.set_font(size=hsize)
            self.pdf.ln(self.h)
            if attrs:
                self.align = attrs.get(&#34;align&#34;)
        if tag == &#34;hr&#34;:
            self.pdf.add_page(same=True)
        if tag == &#34;pre&#34;:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.set_font(&#34;courier&#34;, 11)
        if tag == &#34;blockquote&#34;:
            self.pdf.set_text_color(100, 0, 45)
            self.indent += 1
            self.pdf.ln(3)
        if tag == &#34;ul&#34;:
            self.indent += 1
            self.bullet.append(self.ul_bullet_char)
        if tag == &#34;ol&#34;:
            self.indent += 1
            self.bullet.append(0)
        if tag == &#34;li&#34;:
            self.pdf.ln(self.h + 2)
            self.pdf.set_text_color(190, 0, 0)
            bullet = self.bullet[self.indent - 1]
            if not isinstance(bullet, str):
                bullet += 1
                self.bullet[self.indent - 1] = bullet
                bullet = f&#34;{bullet}. &#34;
            self.pdf.write(self.h, f&#34;{&#39; &#39; * self.li_tag_indent * self.indent}{bullet} &#34;)
            self.set_text_color(*self.font_color)
        if tag == &#34;font&#34;:
            # save previous font state:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            if &#34;color&#34; in attrs:
                color = color_as_decimal(attrs[&#34;color&#34;])
                self.font_color = color
            if &#34;face&#34; in attrs:
                face = attrs.get(&#34;face&#34;).lower()
                try:
                    self.pdf.set_font(face)
                    self.font_face = face
                except RuntimeError:
                    pass  # font not found, ignore
            if &#34;size&#34; in attrs:
                self.font_size = int(attrs.get(&#34;size&#34;))
            self.set_font()
            self.set_text_color(*self.font_color)
        if tag == &#34;table&#34;:
            self.table = {k.lower(): v for k, v in attrs.items()}
            if &#34;width&#34; not in self.table:
                self.table[&#34;width&#34;] = &#34;100%&#34;
            if self.table[&#34;width&#34;][-1] == &#34;%&#34;:
                w = self.pdf.w - self.pdf.r_margin - self.pdf.l_margin
                w *= int(self.table[&#34;width&#34;][:-1]) / 100
                self.table_offset = (self.pdf.w - w) / 2
            self.table_col_width = []
            self.theader_out = self.tfooter_out = False
            self.theader = []
            self.tfooter = []
            self.thead = None
            self.tfoot = None
            self.pdf.ln()
        if tag == &#34;tr&#34;:
            self.tr_index = 0 if self.tr_index is None else (self.tr_index + 1)
            self.tr = {k.lower(): v for k, v in attrs.items()}
            self.table_col_index = 0
            self.table_row_height = 0
            self.pdf.set_x(self.table_offset)
            # Adding an horizontal line separator between rows:
            if self.table_line_separators and self.tr_index &gt; 0:
                self.output_table_sep()
        if tag == &#34;td&#34;:
            self.td = {k.lower(): v for k, v in attrs.items()}
            if &#34;width&#34; in self.td and self.table_col_index &gt;= len(self.table_col_width):
                assert self.table_col_index == len(
                    self.table_col_width
                ), f&#34;table_col_index={self.table_col_index} #table_col_width={len(self.table_col_width)}&#34;
                self.table_col_width.append(self.td[&#34;width&#34;])
            if attrs:
                self.align = attrs.get(&#34;align&#34;)
            self._only_imgs_in_td = False
        if tag == &#34;th&#34;:
            self.td = {k.lower(): v for k, v in attrs.items()}
            self.th = True
            if &#34;width&#34; in self.td and self.table_col_index &gt;= len(self.table_col_width):
                assert self.table_col_index == len(
                    self.table_col_width
                ), f&#34;table_col_index={self.table_col_index} #table_col_width={len(self.table_col_width)}&#34;
                self.table_col_width.append(self.td[&#34;width&#34;])
        if tag == &#34;thead&#34;:
            self.thead = {}
        if tag == &#34;tfoot&#34;:
            self.tfoot = {}
        if tag == &#34;img&#34; and &#34;src&#34; in attrs:
            width = px2mm(attrs.get(&#34;width&#34;, 0))
            height = px2mm(attrs.get(&#34;height&#34;, 0))
            if self.pdf.y + height &gt; self.pdf.page_break_trigger:
                self.pdf.add_page(same=True)
            y = self.pdf.get_y()
            if self.table_col_index is not None:
                self._only_imgs_in_td = True
                # &lt;img&gt; in a &lt;td&gt;: its width must not exceed the cell width:
                td_width = self._td_width()
                if not width or width &gt; td_width:
                    if width:  # Preserving image aspect ratio:
                        height *= td_width / width
                    width = td_width
                x = self._td_x()
                if self.align and self.align[0].upper() == &#34;C&#34;:
                    x += (td_width - width) / 2
            else:
                x = self.pdf.get_x()
                if self.align and self.align[0].upper() == &#34;C&#34;:
                    x = self.pdf.w / 2 - width / 2
            LOGGER.debug(
                &#39;image &#34;%s&#34; x=%d y=%d width=%d height=%d&#39;,
                attrs[&#34;src&#34;],
                x,
                y,
                width,
                height,
            )
            self.pdf.image(
                self.image_map(attrs[&#34;src&#34;]), x, y, width, height, link=self.href
            )
            self.pdf.set_x(x + width)
            if self.table_col_index is not None:
                # &lt;img&gt; in a &lt;td&gt;: we grow the cell height according to the image height:
                if height &gt; self.table_row_height:
                    self.table_row_height = height
            else:
                self.pdf.set_y(y + height)
        if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
            self.set_style(tag, True)
        if tag == &#34;center&#34;:
            self.align = &#34;Center&#34;
        if tag == &#34;toc&#34;:
            self.pdf.insert_toc_placeholder(
                self.render_toc, pages=int(attrs.get(&#34;pages&#34;, 1))
            )

    def handle_endtag(self, tag):
        # Closing tag
        LOGGER.debug(&#34;ENDTAG %s&#34;, tag)
        if tag in self.heading_sizes:
            self.heading_level = None
            face, size, color = self.font_stack.pop()
            self.set_font(face, size)
            self.set_text_color(*color)
            self.pdf.ln(self.h)
            self.align = None
        if tag == &#34;pre&#34;:
            face, size, color = self.font_stack.pop()
            self.set_font(face, size)
            self.set_text_color(*color)
        if tag == &#34;blockquote&#34;:
            self.set_text_color(*self.font_color)
            self.indent -= 1
            self.pdf.ln(3)
        if tag == &#34;strong&#34;:
            tag = &#34;b&#34;
        if tag == &#34;em&#34;:
            tag = &#34;i&#34;
        if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
            self.set_style(tag, False)
        if tag == &#34;a&#34;:
            self.href = &#34;&#34;
        if tag == &#34;p&#34;:
            self.pdf.ln(self.h)
            self.align = &#34;&#34;
        if tag in (&#34;ul&#34;, &#34;ol&#34;):
            self.indent -= 1
            self.bullet.pop()
        if tag == &#34;table&#34;:
            if not self.tfooter_out:
                self.output_table_footer()
            self.table = None
            self.th = False
            self.theader = None
            self.tfooter = None
            self.pdf.ln(self.h)
            self.tr_index = None
        if tag == &#34;thead&#34;:
            self.thead = None
            self.tr_index = None
        if tag == &#34;tfoot&#34;:
            self.tfoot = None
            self.tr_index = None
        if tag == &#34;tbody&#34;:
            self.tbody = None
            self.tr_index = None
        if tag == &#34;tr&#34;:
            if self.tfoot is None:
                self.pdf.ln(self.table_row_height)
            self.table_col_index = None
            self.tr = None
        if tag in (&#34;td&#34;, &#34;th&#34;):
            if self.th:
                LOGGER.debug(&#34;revert style&#34;)
                self.set_style(&#34;b&#34;, False)  # revert style
            elif self._only_imgs_in_td:
                self._insert_td()
            self.table_col_index += int(self.td.get(&#34;colspan&#34;, &#34;1&#34;))
            self.td = None
            self.th = False
        if tag == &#34;font&#34;:
            # recover last font state
            face, size, color = self.font_stack.pop()
            self.font_color = color
            self.set_font(face, size)
            self.set_text_color(*self.font_color)
        if tag == &#34;center&#34;:
            self.align = None

    def set_font(self, face=None, size=None):
        if face:
            self.font_face = face
        if size:
            self.font_size = size
            self.h = size / 72 * 25.4
            LOGGER.debug(&#34;H %s&#34;, self.h)
        style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s)).upper()
        if (self.font_face, style) != (self.pdf.font_family, self.pdf.font_style):
            self.pdf.set_font(self.font_face, style, self.font_size)
        if self.font_size != self.pdf.font_size:
            self.pdf.set_font_size(self.font_size)

    def set_style(self, tag=None, enable=False):
        # Modify style and select corresponding font
        if tag:
            self.style[tag.lower()] = enable
        style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s))
        LOGGER.debug(&#34;SET_FONT_STYLE %s&#34;, style)
        self.pdf.set_font(style=style)

    def set_text_color(self, r=None, g=0, b=0):
        self.pdf.set_text_color(r, g, b)

    def put_link(self, txt):
        # Put a hyperlink
        self.set_text_color(0, 0, 255)
        self.set_style(&#34;u&#34;, True)
        self.pdf.write(self.h, txt, self.href)
        self.set_style(&#34;u&#34;, False)
        self.set_text_color(*self.font_color)

    # pylint: disable=no-self-use
    def render_toc(self, pdf, outline):
        &#34;This method can be overriden by subclasses to customize the Table of Contents style.&#34;
        pdf.ln()
        for section in outline:
            link = pdf.add_link()
            pdf.set_link(link, page=section.page_number)
            text = f&#39;{&#34; &#34; * section.level * 2} {section.name}&#39;
            text += f&#39; {&#34;.&#34; * (60 - section.level*2 - len(section.name))} {section.page_number}&#39;
            pdf.multi_cell(w=pdf.epw, h=pdf.font_size, txt=text, ln=1, link=link)

    # Subclasses of _markupbase.ParserBase must implement this:
    def error(self, message):
        raise RuntimeError(message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>html.parser.HTMLParser</li>
<li>_markupbase.ParserBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.HTML2FPDF.box_shadow"><code class="name flex">
<span>def <span class="ident">box_shadow</span></span>(<span>self, w, h, bgcolor)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def box_shadow(self, w, h, bgcolor):
    LOGGER.debug(&#34;box_shadow w=%d h=%d bgcolor=%s&#34;, w, h, bgcolor)
    if bgcolor:
        fill_color = self.pdf.fill_color
        self.pdf.set_fill_color(*bgcolor)
        self.pdf.rect(self.pdf.x, self.pdf.y, w, h, &#34;F&#34;)
        self.pdf.fill_color = fill_color</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error(self, message):
    raise RuntimeError(message)</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.handle_data"><code class="name flex">
<span>def <span class="ident">handle_data</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_data(self, data):
    if self.td is not None:  # drawing a table?
        self._insert_td(data)
    elif self.table is not None:
        # ignore anything else than td inside a table
        pass
    elif self.align:
        LOGGER.debug(&#34;align &#39;%s&#39;&#34;, data.replace(&#34;\n&#34;, &#34;\\n&#34;))
        self.pdf.multi_cell(
            0,
            self.h,
            data,
            border=0,
            ln=1,
            align=self.align[0].upper(),
            link=self.href,
        )
    else:
        data = data.replace(&#34;\n&#34;, &#34; &#34;)
        if self.href:
            self.put_link(data)
        else:
            if self.heading_level:
                self.pdf.start_section(data, self.heading_level - 1)
            LOGGER.debug(&#34;write &#39;%s&#39; h=%d&#34;, data.replace(&#34;\n&#34;, &#34;\\n&#34;), self.h)
            self.pdf.write(self.h, data)</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.handle_endtag"><code class="name flex">
<span>def <span class="ident">handle_endtag</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_endtag(self, tag):
    # Closing tag
    LOGGER.debug(&#34;ENDTAG %s&#34;, tag)
    if tag in self.heading_sizes:
        self.heading_level = None
        face, size, color = self.font_stack.pop()
        self.set_font(face, size)
        self.set_text_color(*color)
        self.pdf.ln(self.h)
        self.align = None
    if tag == &#34;pre&#34;:
        face, size, color = self.font_stack.pop()
        self.set_font(face, size)
        self.set_text_color(*color)
    if tag == &#34;blockquote&#34;:
        self.set_text_color(*self.font_color)
        self.indent -= 1
        self.pdf.ln(3)
    if tag == &#34;strong&#34;:
        tag = &#34;b&#34;
    if tag == &#34;em&#34;:
        tag = &#34;i&#34;
    if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
        self.set_style(tag, False)
    if tag == &#34;a&#34;:
        self.href = &#34;&#34;
    if tag == &#34;p&#34;:
        self.pdf.ln(self.h)
        self.align = &#34;&#34;
    if tag in (&#34;ul&#34;, &#34;ol&#34;):
        self.indent -= 1
        self.bullet.pop()
    if tag == &#34;table&#34;:
        if not self.tfooter_out:
            self.output_table_footer()
        self.table = None
        self.th = False
        self.theader = None
        self.tfooter = None
        self.pdf.ln(self.h)
        self.tr_index = None
    if tag == &#34;thead&#34;:
        self.thead = None
        self.tr_index = None
    if tag == &#34;tfoot&#34;:
        self.tfoot = None
        self.tr_index = None
    if tag == &#34;tbody&#34;:
        self.tbody = None
        self.tr_index = None
    if tag == &#34;tr&#34;:
        if self.tfoot is None:
            self.pdf.ln(self.table_row_height)
        self.table_col_index = None
        self.tr = None
    if tag in (&#34;td&#34;, &#34;th&#34;):
        if self.th:
            LOGGER.debug(&#34;revert style&#34;)
            self.set_style(&#34;b&#34;, False)  # revert style
        elif self._only_imgs_in_td:
            self._insert_td()
        self.table_col_index += int(self.td.get(&#34;colspan&#34;, &#34;1&#34;))
        self.td = None
        self.th = False
    if tag == &#34;font&#34;:
        # recover last font state
        face, size, color = self.font_stack.pop()
        self.font_color = color
        self.set_font(face, size)
        self.set_text_color(*self.font_color)
    if tag == &#34;center&#34;:
        self.align = None</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.handle_starttag"><code class="name flex">
<span>def <span class="ident">handle_starttag</span></span>(<span>self, tag, attrs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_starttag(self, tag, attrs):
    attrs = dict(attrs)
    LOGGER.debug(&#34;STARTTAG %s %s&#34;, tag, attrs)
    if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
        self.set_style(tag, True)
    if tag == &#34;a&#34;:
        self.href = attrs[&#34;href&#34;]
    if tag == &#34;br&#34;:
        self.pdf.ln(self.h)
    if tag == &#34;p&#34;:
        self.pdf.ln(self.h)
        if attrs:
            self.align = attrs.get(&#34;align&#34;)
    if tag in self.heading_sizes:
        self.font_stack.append((self.font_face, self.font_size, self.font_color))
        self.heading_level = int(tag[1:])
        hsize = self.heading_sizes[tag]
        self.pdf.set_text_color(150, 0, 0)
        self.set_font(size=hsize)
        self.pdf.ln(self.h)
        if attrs:
            self.align = attrs.get(&#34;align&#34;)
    if tag == &#34;hr&#34;:
        self.pdf.add_page(same=True)
    if tag == &#34;pre&#34;:
        self.font_stack.append((self.font_face, self.font_size, self.font_color))
        self.set_font(&#34;courier&#34;, 11)
    if tag == &#34;blockquote&#34;:
        self.pdf.set_text_color(100, 0, 45)
        self.indent += 1
        self.pdf.ln(3)
    if tag == &#34;ul&#34;:
        self.indent += 1
        self.bullet.append(self.ul_bullet_char)
    if tag == &#34;ol&#34;:
        self.indent += 1
        self.bullet.append(0)
    if tag == &#34;li&#34;:
        self.pdf.ln(self.h + 2)
        self.pdf.set_text_color(190, 0, 0)
        bullet = self.bullet[self.indent - 1]
        if not isinstance(bullet, str):
            bullet += 1
            self.bullet[self.indent - 1] = bullet
            bullet = f&#34;{bullet}. &#34;
        self.pdf.write(self.h, f&#34;{&#39; &#39; * self.li_tag_indent * self.indent}{bullet} &#34;)
        self.set_text_color(*self.font_color)
    if tag == &#34;font&#34;:
        # save previous font state:
        self.font_stack.append((self.font_face, self.font_size, self.font_color))
        if &#34;color&#34; in attrs:
            color = color_as_decimal(attrs[&#34;color&#34;])
            self.font_color = color
        if &#34;face&#34; in attrs:
            face = attrs.get(&#34;face&#34;).lower()
            try:
                self.pdf.set_font(face)
                self.font_face = face
            except RuntimeError:
                pass  # font not found, ignore
        if &#34;size&#34; in attrs:
            self.font_size = int(attrs.get(&#34;size&#34;))
        self.set_font()
        self.set_text_color(*self.font_color)
    if tag == &#34;table&#34;:
        self.table = {k.lower(): v for k, v in attrs.items()}
        if &#34;width&#34; not in self.table:
            self.table[&#34;width&#34;] = &#34;100%&#34;
        if self.table[&#34;width&#34;][-1] == &#34;%&#34;:
            w = self.pdf.w - self.pdf.r_margin - self.pdf.l_margin
            w *= int(self.table[&#34;width&#34;][:-1]) / 100
            self.table_offset = (self.pdf.w - w) / 2
        self.table_col_width = []
        self.theader_out = self.tfooter_out = False
        self.theader = []
        self.tfooter = []
        self.thead = None
        self.tfoot = None
        self.pdf.ln()
    if tag == &#34;tr&#34;:
        self.tr_index = 0 if self.tr_index is None else (self.tr_index + 1)
        self.tr = {k.lower(): v for k, v in attrs.items()}
        self.table_col_index = 0
        self.table_row_height = 0
        self.pdf.set_x(self.table_offset)
        # Adding an horizontal line separator between rows:
        if self.table_line_separators and self.tr_index &gt; 0:
            self.output_table_sep()
    if tag == &#34;td&#34;:
        self.td = {k.lower(): v for k, v in attrs.items()}
        if &#34;width&#34; in self.td and self.table_col_index &gt;= len(self.table_col_width):
            assert self.table_col_index == len(
                self.table_col_width
            ), f&#34;table_col_index={self.table_col_index} #table_col_width={len(self.table_col_width)}&#34;
            self.table_col_width.append(self.td[&#34;width&#34;])
        if attrs:
            self.align = attrs.get(&#34;align&#34;)
        self._only_imgs_in_td = False
    if tag == &#34;th&#34;:
        self.td = {k.lower(): v for k, v in attrs.items()}
        self.th = True
        if &#34;width&#34; in self.td and self.table_col_index &gt;= len(self.table_col_width):
            assert self.table_col_index == len(
                self.table_col_width
            ), f&#34;table_col_index={self.table_col_index} #table_col_width={len(self.table_col_width)}&#34;
            self.table_col_width.append(self.td[&#34;width&#34;])
    if tag == &#34;thead&#34;:
        self.thead = {}
    if tag == &#34;tfoot&#34;:
        self.tfoot = {}
    if tag == &#34;img&#34; and &#34;src&#34; in attrs:
        width = px2mm(attrs.get(&#34;width&#34;, 0))
        height = px2mm(attrs.get(&#34;height&#34;, 0))
        if self.pdf.y + height &gt; self.pdf.page_break_trigger:
            self.pdf.add_page(same=True)
        y = self.pdf.get_y()
        if self.table_col_index is not None:
            self._only_imgs_in_td = True
            # &lt;img&gt; in a &lt;td&gt;: its width must not exceed the cell width:
            td_width = self._td_width()
            if not width or width &gt; td_width:
                if width:  # Preserving image aspect ratio:
                    height *= td_width / width
                width = td_width
            x = self._td_x()
            if self.align and self.align[0].upper() == &#34;C&#34;:
                x += (td_width - width) / 2
        else:
            x = self.pdf.get_x()
            if self.align and self.align[0].upper() == &#34;C&#34;:
                x = self.pdf.w / 2 - width / 2
        LOGGER.debug(
            &#39;image &#34;%s&#34; x=%d y=%d width=%d height=%d&#39;,
            attrs[&#34;src&#34;],
            x,
            y,
            width,
            height,
        )
        self.pdf.image(
            self.image_map(attrs[&#34;src&#34;]), x, y, width, height, link=self.href
        )
        self.pdf.set_x(x + width)
        if self.table_col_index is not None:
            # &lt;img&gt; in a &lt;td&gt;: we grow the cell height according to the image height:
            if height &gt; self.table_row_height:
                self.table_row_height = height
        else:
            self.pdf.set_y(y + height)
    if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
        self.set_style(tag, True)
    if tag == &#34;center&#34;:
        self.align = &#34;Center&#34;
    if tag == &#34;toc&#34;:
        self.pdf.insert_toc_placeholder(
            self.render_toc, pages=int(attrs.get(&#34;pages&#34;, 1))
        )</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.output_table_footer"><code class="name flex">
<span>def <span class="ident">output_table_footer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_table_footer(self):
    if self.tfooter:
        x = self.pdf.x
        self.pdf.set_x(self.table_offset)
        for cell, bgcolor in self.tfooter:
            self.box_shadow(cell[0], cell[1], bgcolor)
            self.pdf.cell(*cell)
        self.pdf.ln(self.tfooter[0][0][1])
        self.pdf.set_x(x)
    if self.table.get(&#34;border&#34;):
        self.output_table_sep()
    self.tfooter_out = True</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.output_table_header"><code class="name flex">
<span>def <span class="ident">output_table_header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_table_header(self):
    if self.theader:
        b = self.style.get(&#34;b&#34;)
        self.pdf.set_x(self.table_offset)
        self.set_style(&#34;b&#34;, True)
        for cell, bgcolor in self.theader:
            self.box_shadow(cell[0], cell[1], bgcolor)
            self.pdf.cell(*cell)  # includes the border
        self.set_style(&#34;b&#34;, b)
        self.pdf.ln(self.theader[0][0][1])
        self.pdf.set_x(self.table_offset)
        # self.pdf.set_x(prev_x)
    self.theader_out = True</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.output_table_sep"><code class="name flex">
<span>def <span class="ident">output_table_sep</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_table_sep(self):
    x1 = self.pdf.x
    y1 = self.pdf.y
    width = sum(self.width2unit(length) for length in self.table_col_width)
    self.pdf.line(x1, y1, x1 + width, y1)</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.put_link"><code class="name flex">
<span>def <span class="ident">put_link</span></span>(<span>self, txt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_link(self, txt):
    # Put a hyperlink
    self.set_text_color(0, 0, 255)
    self.set_style(&#34;u&#34;, True)
    self.pdf.write(self.h, txt, self.href)
    self.set_style(&#34;u&#34;, False)
    self.set_text_color(*self.font_color)</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.render_toc"><code class="name flex">
<span>def <span class="ident">render_toc</span></span>(<span>self, pdf, outline)</span>
</code></dt>
<dd>
<div class="desc"><p>This method can be overriden by subclasses to customize the Table of Contents style.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_toc(self, pdf, outline):
    &#34;This method can be overriden by subclasses to customize the Table of Contents style.&#34;
    pdf.ln()
    for section in outline:
        link = pdf.add_link()
        pdf.set_link(link, page=section.page_number)
        text = f&#39;{&#34; &#34; * section.level * 2} {section.name}&#39;
        text += f&#39; {&#34;.&#34; * (60 - section.level*2 - len(section.name))} {section.page_number}&#39;
        pdf.multi_cell(w=pdf.epw, h=pdf.font_size, txt=text, ln=1, link=link)</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.set_font"><code class="name flex">
<span>def <span class="ident">set_font</span></span>(<span>self, face=None, size=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_font(self, face=None, size=None):
    if face:
        self.font_face = face
    if size:
        self.font_size = size
        self.h = size / 72 * 25.4
        LOGGER.debug(&#34;H %s&#34;, self.h)
    style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s)).upper()
    if (self.font_face, style) != (self.pdf.font_family, self.pdf.font_style):
        self.pdf.set_font(self.font_face, style, self.font_size)
    if self.font_size != self.pdf.font_size:
        self.pdf.set_font_size(self.font_size)</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.set_style"><code class="name flex">
<span>def <span class="ident">set_style</span></span>(<span>self, tag=None, enable=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_style(self, tag=None, enable=False):
    # Modify style and select corresponding font
    if tag:
        self.style[tag.lower()] = enable
    style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s))
    LOGGER.debug(&#34;SET_FONT_STYLE %s&#34;, style)
    self.pdf.set_font(style=style)</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.set_text_color"><code class="name flex">
<span>def <span class="ident">set_text_color</span></span>(<span>self, r=None, g=0, b=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_text_color(self, r=None, g=0, b=0):
    self.pdf.set_text_color(r, g, b)</code></pre>
</details>
</dd>
<dt id="fpdf.HTML2FPDF.width2unit"><code class="name flex">
<span>def <span class="ident">width2unit</span></span>(<span>self, length)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle conversion of % measures into the measurement unit used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def width2unit(self, length):
    &#34;Handle conversion of % measures into the measurement unit used&#34;
    if length[-1] == &#34;%&#34;:
        total = self.pdf.w - self.pdf.r_margin - self.pdf.l_margin
        if self.table[&#34;width&#34;][-1] == &#34;%&#34;:
            total *= int(self.table[&#34;width&#34;][:-1]) / 100
        return int(length[:-1]) * total / 100
    return int(length)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.HTMLMixin"><code class="flex name class">
<span>class <span class="ident">HTMLMixin</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HTMLMixin:
    HTML2FPDF_CLASS = HTML2FPDF

    def write_html(self, text, *args, **kwargs):
        &#34;&#34;&#34;Parse HTML and convert it to PDF&#34;&#34;&#34;
        kwargs2 = vars(self)
        # Method arguments must override class &amp; instance attributes:
        kwargs2.update(kwargs)
        h2p = self.HTML2FPDF_CLASS(self, *args, **kwargs2)
        text = html.unescape(text)  # To deal with HTML entities
        h2p.feed(text)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.HTMLMixin.HTML2FPDF_CLASS"><code class="name">var <span class="ident">HTML2FPDF_CLASS</span></code></dt>
<dd>
<div class="desc"><p>Render basic HTML to FPDF</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.HTMLMixin.write_html"><code class="name flex">
<span>def <span class="ident">write_html</span></span>(<span>self, text, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse HTML and convert it to PDF</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_html(self, text, *args, **kwargs):
    &#34;&#34;&#34;Parse HTML and convert it to PDF&#34;&#34;&#34;
    kwargs2 = vars(self)
    # Method arguments must override class &amp; instance attributes:
    kwargs2.update(kwargs)
    h2p = self.HTML2FPDF_CLASS(self, *args, **kwargs2)
    text = html.unescape(text)  # To deal with HTML entities
    h2p.feed(text)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.Template"><code class="flex name class">
<span>class <span class="ident">Template</span></span>
<span>(</span><span>infile=None, elements=None, format='A4', orientation='portrait', unit='mm', title='', author='', subject='', creator='', keywords='')</span>
</code></dt>
<dd>
<div class="desc"><p>A simple templating class.</p>
<p>Allows to apply a single template definition to all pages of a document.</p>
<h2 id="arguments">Arguments</h2>
<p>infile (str):
[<strong>DEPRECATED</strong>] unused, will be removed in a later version</p>
<p>elements (list of dicts):
A template definition in a list of dicts.
If you omit this, then you need to call either load_elements()
or parse_csv() before doing anything else.</p>
<p>format (str):
The page format of the document (eg. "A4" or "letter").</p>
<p>orientation (str):
The orientation of the document.
Possible values are "portrait"/"P" or "landscape"/"L"</p>
<p>unit (str):
The units used in the template definition.
One of "mm", "cm", "in", "pt", or a number for points per unit.</p>
<p>title (str): The title of the document.</p>
<p>author (str): The author of the document.</p>
<p>subject (str): The subject matter of the document.</p>
<p>creator (str): The creator of the document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Template(FlexTemplate):
    &#34;&#34;&#34;
    A simple templating class.

    Allows to apply a single template definition to all pages of a document.
    &#34;&#34;&#34;

    # Disabling this check due to the &#34;format&#34; parameter below:
    # pylint: disable=redefined-builtin
    # pylint: disable=unused-argument
    def __init__(
        self,
        infile=None,
        elements=None,
        format=&#34;A4&#34;,
        orientation=&#34;portrait&#34;,
        unit=&#34;mm&#34;,
        title=&#34;&#34;,
        author=&#34;&#34;,
        subject=&#34;&#34;,
        creator=&#34;&#34;,
        keywords=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Arguments:

            infile (str):
                [**DEPRECATED**] unused, will be removed in a later version

            elements (list of dicts):
                A template definition in a list of dicts.
                If you omit this, then you need to call either load_elements()
                or parse_csv() before doing anything else.

            format (str):
                The page format of the document (eg. &#34;A4&#34; or &#34;letter&#34;).

            orientation (str):
                The orientation of the document.
                Possible values are &#34;portrait&#34;/&#34;P&#34; or &#34;landscape&#34;/&#34;L&#34;

            unit (str):
                The units used in the template definition.
                One of &#34;mm&#34;, &#34;cm&#34;, &#34;in&#34;, &#34;pt&#34;, or a number for points per unit.

            title (str): The title of the document.

            author (str): The author of the document.

            subject (str): The subject matter of the document.

            creator (str): The creator of the document.
        &#34;&#34;&#34;
        if infile:
            warnings.warn(
                &#39;&#34;infile&#34; is unused and will soon be deprecated&#39;,
                DeprecationWarning,
            )
        for arg in (
            &#34;format&#34;,
            &#34;orientation&#34;,
            &#34;unit&#34;,
            &#34;title&#34;,
            &#34;author&#34;,
            &#34;subject&#34;,
            &#34;creator&#34;,
            &#34;keywords&#34;,
        ):
            if not isinstance(locals()[arg], str):
                raise TypeError(f&#39;Argument &#34;{arg}&#34; must be of type str.&#39;)
        pdf = FPDF(format=format, orientation=orientation, unit=unit)
        pdf.set_title(title)
        pdf.set_author(author)
        pdf.set_creator(creator)
        pdf.set_subject(subject)
        pdf.set_keywords(keywords)
        super().__init__(pdf=pdf, elements=elements)

    def add_page(self):
        &#34;&#34;&#34;Finish the current page, and proceed to the next one.&#34;&#34;&#34;
        if self.pdf.page:
            self.render()
        self.pdf.add_page()

    # pylint: disable=arguments-differ
    def render(self, outfile=None, dest=None):
        &#34;&#34;&#34;
        Finish the document and process all pending data.

        Arguments:

            outfile (str):
                If given, the PDF file will be written to this file name.
                Alternatively, the `.pdf.output()` method can be manually called.

            dest (str):
                [**DEPRECATED**] unused, will be removed in a later version.
        &#34;&#34;&#34;
        if dest:
            warnings.warn(
                &#39;&#34;dest&#34; is unused and will soon be deprecated&#39;,
                DeprecationWarning,
            )
        self.pdf.set_font(&#34;helvetica&#34;, &#34;B&#34;, 16)
        self.pdf.set_auto_page_break(False, margin=0)
        super().render()
        if outfile:
            self.pdf.output(outfile)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.template.FlexTemplate" href="template.html#fpdf.template.FlexTemplate">FlexTemplate</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.Template.add_page"><code class="name flex">
<span>def <span class="ident">add_page</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finish the current page, and proceed to the next one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_page(self):
    &#34;&#34;&#34;Finish the current page, and proceed to the next one.&#34;&#34;&#34;
    if self.pdf.page:
        self.render()
    self.pdf.add_page()</code></pre>
</details>
</dd>
<dt id="fpdf.Template.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, outfile=None, dest=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Finish the document and process all pending data.</p>
<h2 id="arguments">Arguments</h2>
<p>outfile (str):
If given, the PDF file will be written to this file name.
Alternatively, the <code>.pdf.output()</code> method can be manually called.</p>
<p>dest (str):
[<strong>DEPRECATED</strong>] unused, will be removed in a later version.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, outfile=None, dest=None):
    &#34;&#34;&#34;
    Finish the document and process all pending data.

    Arguments:

        outfile (str):
            If given, the PDF file will be written to this file name.
            Alternatively, the `.pdf.output()` method can be manually called.

        dest (str):
            [**DEPRECATED**] unused, will be removed in a later version.
    &#34;&#34;&#34;
    if dest:
        warnings.warn(
            &#39;&#34;dest&#34; is unused and will soon be deprecated&#39;,
            DeprecationWarning,
        )
    self.pdf.set_font(&#34;helvetica&#34;, &#34;B&#34;, 16)
    self.pdf.set_auto_page_break(False, margin=0)
    super().render()
    if outfile:
        self.pdf.output(outfile)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fpdf.template.FlexTemplate" href="template.html#fpdf.template.FlexTemplate">FlexTemplate</a></b></code>:
<ul class="hlist">
<li><code><a title="fpdf.template.FlexTemplate.load_elements" href="template.html#fpdf.template.FlexTemplate.load_elements">load_elements</a></code></li>
<li><code><a title="fpdf.template.FlexTemplate.parse_csv" href="template.html#fpdf.template.FlexTemplate.parse_csv">parse_csv</a></code></li>
<li><code><a title="fpdf.template.FlexTemplate.split_multicell" href="template.html#fpdf.template.FlexTemplate.split_multicell">split_multicell</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fpdf.TitleStyle"><code class="flex name class">
<span>class <span class="ident">TitleStyle</span></span>
<span>(</span><span>font_family: Optional[str] = None, font_style: Optional[str] = None, font_size_pt: Optional[int] = None, color: Union[int, tuple] = None, underline: bool = False, t_margin: Optional[int] = None, l_margin: Optional[int] = None, b_margin: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>TitleStyle(font_family, font_style, font_size_pt, color, underline, t_margin, l_margin, b_margin)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TitleStyle(NamedTuple):
    font_family: Optional[str] = None
    font_style: Optional[str] = None
    font_size_pt: Optional[int] = None
    color: Union[int, tuple] = None  # grey scale or (red, green, blue)
    underline: bool = False
    t_margin: Optional[int] = None
    l_margin: Optional[int] = None
    b_margin: Optional[int] = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.TitleStyle.b_margin"><code class="name">var <span class="ident">b_margin</span> : Optional[int]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 7</p></div>
</dd>
<dt id="fpdf.TitleStyle.color"><code class="name">var <span class="ident">color</span> : Union[int, tuple]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="fpdf.TitleStyle.font_family"><code class="name">var <span class="ident">font_family</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="fpdf.TitleStyle.font_size_pt"><code class="name">var <span class="ident">font_size_pt</span> : Optional[int]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
<dt id="fpdf.TitleStyle.font_style"><code class="name">var <span class="ident">font_style</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="fpdf.TitleStyle.l_margin"><code class="name">var <span class="ident">l_margin</span> : Optional[int]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 6</p></div>
</dd>
<dt id="fpdf.TitleStyle.t_margin"><code class="name">var <span class="ident">t_margin</span> : Optional[int]</code></dt>
<dd>
<div class="desc"><p>Alias for field number 5</p></div>
</dd>
<dt id="fpdf.TitleStyle.underline"><code class="name">var <span class="ident">underline</span> : bool</code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.XPos"><code class="flex name class">
<span>class <span class="ident">XPos</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Positional values in horizontal direction for use after printing text.
LEFT
- left end of the cell
RIGHT
- right end of the cell (default)
START
- start of actual text
END
- end of actual text
WCONT
- for write() to continue next (slightly left of END)
CENTER
- center of actual text
LMARGIN - left page margin (start of printable area)
RMARGIN - right page margin (end of printable area)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XPos(IntEnum):
    &#34;&#34;&#34;
    Positional values in horizontal direction for use after printing text.
        LEFT    - left end of the cell
        RIGHT   - right end of the cell (default)
        START   - start of actual text
        END     - end of actual text
        WCONT   - for write() to continue next (slightly left of END)
        CENTER  - center of actual text
        LMARGIN - left page margin (start of printable area)
        RMARGIN - right page margin (end of printable area)
    &#34;&#34;&#34;

    LEFT = 1  # self.x
    RIGHT = 2  # self.x + w
    START = 3  # left end of actual text
    END = 4  # right end of actual text
    WCONT = 5  # continuation point for write()
    CENTER = 6  # center of actual text
    LMARGIN = 7  # self.l_margin
    RMARGIN = 8  # self.w - self.r_margin</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.XPos.CENTER"><code class="name">var <span class="ident">CENTER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.XPos.END"><code class="name">var <span class="ident">END</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.XPos.LEFT"><code class="name">var <span class="ident">LEFT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.XPos.LMARGIN"><code class="name">var <span class="ident">LMARGIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.XPos.RIGHT"><code class="name">var <span class="ident">RIGHT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.XPos.RMARGIN"><code class="name">var <span class="ident">RMARGIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.XPos.START"><code class="name">var <span class="ident">START</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.XPos.WCONT"><code class="name">var <span class="ident">WCONT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.YPos"><code class="flex name class">
<span>class <span class="ident">YPos</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Positional values in vertical direction for use after printing text.
TOP
- top of the first line (default)
LAST
- top of the last line (same as TOP for single-line text)
NEXT
- top of next line (bottom of current text)
TMARGIN - top page margin (start of printable area)
BMARGIN - bottom page margin (end of printable area)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class YPos(IntEnum):
    &#34;&#34;&#34;
    Positional values in vertical direction for use after printing text.
        TOP     - top of the first line (default)
        LAST    - top of the last line (same as TOP for single-line text)
        NEXT    - top of next line (bottom of current text)
        TMARGIN - top page margin (start of printable area)
        BMARGIN - bottom page margin (end of printable area)
    &#34;&#34;&#34;

    TOP = 1  # self.y
    LAST = 2  # top of last line (TOP for single lines)
    NEXT = 3  # LAST + h
    TMARGIN = 4  # self.t_margin
    BMARGIN = 5  # self.h - self.b_margin</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.YPos.BMARGIN"><code class="name">var <span class="ident">BMARGIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.YPos.LAST"><code class="name">var <span class="ident">LAST</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.YPos.NEXT"><code class="name">var <span class="ident">NEXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.YPos.TMARGIN"><code class="name">var <span class="ident">TMARGIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.YPos.TOP"><code class="name">var <span class="ident">TOP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="fpdf.actions" href="actions.html">fpdf.actions</a></code></li>
<li><code><a title="fpdf.deprecation" href="deprecation.html">fpdf.deprecation</a></code></li>
<li><code><a title="fpdf.drawing" href="drawing.html">fpdf.drawing</a></code></li>
<li><code><a title="fpdf.errors" href="errors.html">fpdf.errors</a></code></li>
<li><code><a title="fpdf.fonts" href="fonts.html">fpdf.fonts</a></code></li>
<li><code><a title="fpdf.fpdf" href="fpdf.html">fpdf.fpdf</a></code></li>
<li><code><a title="fpdf.graphics_state" href="graphics_state.html">fpdf.graphics_state</a></code></li>
<li><code><a title="fpdf.html" href="html.html">fpdf.html</a></code></li>
<li><code><a title="fpdf.image_parsing" href="image_parsing.html">fpdf.image_parsing</a></code></li>
<li><code><a title="fpdf.line_break" href="line_break.html">fpdf.line_break</a></code></li>
<li><code><a title="fpdf.outline" href="outline.html">fpdf.outline</a></code></li>
<li><code><a title="fpdf.recorder" href="recorder.html">fpdf.recorder</a></code></li>
<li><code><a title="fpdf.structure_tree" href="structure_tree.html">fpdf.structure_tree</a></code></li>
<li><code><a title="fpdf.svg" href="svg.html">fpdf.svg</a></code></li>
<li><code><a title="fpdf.syntax" href="syntax.html">fpdf.syntax</a></code></li>
<li><code><a title="fpdf.template" href="template.html">fpdf.template</a></code></li>
<li><code><a title="fpdf.transitions" href="transitions.html">fpdf.transitions</a></code></li>
<li><code><a title="fpdf.ttfonts" href="ttfonts.html">fpdf.ttfonts</a></code></li>
<li><code><a title="fpdf.util" href="util.html">fpdf.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="fpdf.FPDF_FONT_DIR" href="#fpdf.FPDF_FONT_DIR">FPDF_FONT_DIR</a></code></li>
<li><code><a title="fpdf.FPDF_VERSION" href="#fpdf.FPDF_VERSION">FPDF_VERSION</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.FPDF" href="#fpdf.FPDF">FPDF</a></code></h4>
<ul class="">
<li><code><a title="fpdf.FPDF.MARKDOWN_BOLD_MARKER" href="#fpdf.FPDF.MARKDOWN_BOLD_MARKER">MARKDOWN_BOLD_MARKER</a></code></li>
<li><code><a title="fpdf.FPDF.MARKDOWN_ITALICS_MARKER" href="#fpdf.FPDF.MARKDOWN_ITALICS_MARKER">MARKDOWN_ITALICS_MARKER</a></code></li>
<li><code><a title="fpdf.FPDF.MARKDOWN_UNDERLINE_MARKER" href="#fpdf.FPDF.MARKDOWN_UNDERLINE_MARKER">MARKDOWN_UNDERLINE_MARKER</a></code></li>
<li><code><a title="fpdf.FPDF.accept_page_break" href="#fpdf.FPDF.accept_page_break">accept_page_break</a></code></li>
<li><code><a title="fpdf.FPDF.add_action" href="#fpdf.FPDF.add_action">add_action</a></code></li>
<li><code><a title="fpdf.FPDF.add_font" href="#fpdf.FPDF.add_font">add_font</a></code></li>
<li><code><a title="fpdf.FPDF.add_link" href="#fpdf.FPDF.add_link">add_link</a></code></li>
<li><code><a title="fpdf.FPDF.add_page" href="#fpdf.FPDF.add_page">add_page</a></code></li>
<li><code><a title="fpdf.FPDF.alias_nb_pages" href="#fpdf.FPDF.alias_nb_pages">alias_nb_pages</a></code></li>
<li><code><a title="fpdf.FPDF.arc" href="#fpdf.FPDF.arc">arc</a></code></li>
<li><code><a title="fpdf.FPDF.cell" href="#fpdf.FPDF.cell">cell</a></code></li>
<li><code><a title="fpdf.FPDF.circle" href="#fpdf.FPDF.circle">circle</a></code></li>
<li><code><a title="fpdf.FPDF.close" href="#fpdf.FPDF.close">close</a></code></li>
<li><code><a title="fpdf.FPDF.code39" href="#fpdf.FPDF.code39">code39</a></code></li>
<li><code><a title="fpdf.FPDF.dashed_line" href="#fpdf.FPDF.dashed_line">dashed_line</a></code></li>
<li><code><a title="fpdf.FPDF.draw_path" href="#fpdf.FPDF.draw_path">draw_path</a></code></li>
<li><code><a title="fpdf.FPDF.drawing_context" href="#fpdf.FPDF.drawing_context">drawing_context</a></code></li>
<li><code><a title="fpdf.FPDF.ellipse" href="#fpdf.FPDF.ellipse">ellipse</a></code></li>
<li><code><a title="fpdf.FPDF.eph" href="#fpdf.FPDF.eph">eph</a></code></li>
<li><code><a title="fpdf.FPDF.epw" href="#fpdf.FPDF.epw">epw</a></code></li>
<li><code><a title="fpdf.FPDF.footer" href="#fpdf.FPDF.footer">footer</a></code></li>
<li><code><a title="fpdf.FPDF.get_normalized_string_width_with_style" href="#fpdf.FPDF.get_normalized_string_width_with_style">get_normalized_string_width_with_style</a></code></li>
<li><code><a title="fpdf.FPDF.get_string_width" href="#fpdf.FPDF.get_string_width">get_string_width</a></code></li>
<li><code><a title="fpdf.FPDF.get_x" href="#fpdf.FPDF.get_x">get_x</a></code></li>
<li><code><a title="fpdf.FPDF.get_y" href="#fpdf.FPDF.get_y">get_y</a></code></li>
<li><code><a title="fpdf.FPDF.header" href="#fpdf.FPDF.header">header</a></code></li>
<li><code><a title="fpdf.FPDF.image" href="#fpdf.FPDF.image">image</a></code></li>
<li><code><a title="fpdf.FPDF.insert_toc_placeholder" href="#fpdf.FPDF.insert_toc_placeholder">insert_toc_placeholder</a></code></li>
<li><code><a title="fpdf.FPDF.interleaved2of5" href="#fpdf.FPDF.interleaved2of5">interleaved2of5</a></code></li>
<li><code><a title="fpdf.FPDF.line" href="#fpdf.FPDF.line">line</a></code></li>
<li><code><a title="fpdf.FPDF.link" href="#fpdf.FPDF.link">link</a></code></li>
<li><code><a title="fpdf.FPDF.ln" href="#fpdf.FPDF.ln">ln</a></code></li>
<li><code><a title="fpdf.FPDF.local_context" href="#fpdf.FPDF.local_context">local_context</a></code></li>
<li><code><a title="fpdf.FPDF.multi_cell" href="#fpdf.FPDF.multi_cell">multi_cell</a></code></li>
<li><code><a title="fpdf.FPDF.new_path" href="#fpdf.FPDF.new_path">new_path</a></code></li>
<li><code><a title="fpdf.FPDF.normalize_text" href="#fpdf.FPDF.normalize_text">normalize_text</a></code></li>
<li><code><a title="fpdf.FPDF.open" href="#fpdf.FPDF.open">open</a></code></li>
<li><code><a title="fpdf.FPDF.output" href="#fpdf.FPDF.output">output</a></code></li>
<li><code><a title="fpdf.FPDF.page_no" href="#fpdf.FPDF.page_no">page_no</a></code></li>
<li><code><a title="fpdf.FPDF.pages_count" href="#fpdf.FPDF.pages_count">pages_count</a></code></li>
<li><code><a title="fpdf.FPDF.polygon" href="#fpdf.FPDF.polygon">polygon</a></code></li>
<li><code><a title="fpdf.FPDF.polyline" href="#fpdf.FPDF.polyline">polyline</a></code></li>
<li><code><a title="fpdf.FPDF.rect" href="#fpdf.FPDF.rect">rect</a></code></li>
<li><code><a title="fpdf.FPDF.rect_clip" href="#fpdf.FPDF.rect_clip">rect_clip</a></code></li>
<li><code><a title="fpdf.FPDF.regular_polygon" href="#fpdf.FPDF.regular_polygon">regular_polygon</a></code></li>
<li><code><a title="fpdf.FPDF.rotate" href="#fpdf.FPDF.rotate">rotate</a></code></li>
<li><code><a title="fpdf.FPDF.rotation" href="#fpdf.FPDF.rotation">rotation</a></code></li>
<li><code><a title="fpdf.FPDF.set_author" href="#fpdf.FPDF.set_author">set_author</a></code></li>
<li><code><a title="fpdf.FPDF.set_auto_page_break" href="#fpdf.FPDF.set_auto_page_break">set_auto_page_break</a></code></li>
<li><code><a title="fpdf.FPDF.set_compression" href="#fpdf.FPDF.set_compression">set_compression</a></code></li>
<li><code><a title="fpdf.FPDF.set_creation_date" href="#fpdf.FPDF.set_creation_date">set_creation_date</a></code></li>
<li><code><a title="fpdf.FPDF.set_creator" href="#fpdf.FPDF.set_creator">set_creator</a></code></li>
<li><code><a title="fpdf.FPDF.set_dash_pattern" href="#fpdf.FPDF.set_dash_pattern">set_dash_pattern</a></code></li>
<li><code><a title="fpdf.FPDF.set_display_mode" href="#fpdf.FPDF.set_display_mode">set_display_mode</a></code></li>
<li><code><a title="fpdf.FPDF.set_doc_option" href="#fpdf.FPDF.set_doc_option">set_doc_option</a></code></li>
<li><code><a title="fpdf.FPDF.set_draw_color" href="#fpdf.FPDF.set_draw_color">set_draw_color</a></code></li>
<li><code><a title="fpdf.FPDF.set_fill_color" href="#fpdf.FPDF.set_fill_color">set_fill_color</a></code></li>
<li><code><a title="fpdf.FPDF.set_font" href="#fpdf.FPDF.set_font">set_font</a></code></li>
<li><code><a title="fpdf.FPDF.set_font_size" href="#fpdf.FPDF.set_font_size">set_font_size</a></code></li>
<li><code><a title="fpdf.FPDF.set_image_filter" href="#fpdf.FPDF.set_image_filter">set_image_filter</a></code></li>
<li><code><a title="fpdf.FPDF.set_keywords" href="#fpdf.FPDF.set_keywords">set_keywords</a></code></li>
<li><code><a title="fpdf.FPDF.set_lang" href="#fpdf.FPDF.set_lang">set_lang</a></code></li>
<li><code><a title="fpdf.FPDF.set_left_margin" href="#fpdf.FPDF.set_left_margin">set_left_margin</a></code></li>
<li><code><a title="fpdf.FPDF.set_line_width" href="#fpdf.FPDF.set_line_width">set_line_width</a></code></li>
<li><code><a title="fpdf.FPDF.set_link" href="#fpdf.FPDF.set_link">set_link</a></code></li>
<li><code><a title="fpdf.FPDF.set_margin" href="#fpdf.FPDF.set_margin">set_margin</a></code></li>
<li><code><a title="fpdf.FPDF.set_margins" href="#fpdf.FPDF.set_margins">set_margins</a></code></li>
<li><code><a title="fpdf.FPDF.set_producer" href="#fpdf.FPDF.set_producer">set_producer</a></code></li>
<li><code><a title="fpdf.FPDF.set_right_margin" href="#fpdf.FPDF.set_right_margin">set_right_margin</a></code></li>
<li><code><a title="fpdf.FPDF.set_section_title_styles" href="#fpdf.FPDF.set_section_title_styles">set_section_title_styles</a></code></li>
<li><code><a title="fpdf.FPDF.set_stretching" href="#fpdf.FPDF.set_stretching">set_stretching</a></code></li>
<li><code><a title="fpdf.FPDF.set_subject" href="#fpdf.FPDF.set_subject">set_subject</a></code></li>
<li><code><a title="fpdf.FPDF.set_text_color" href="#fpdf.FPDF.set_text_color">set_text_color</a></code></li>
<li><code><a title="fpdf.FPDF.set_title" href="#fpdf.FPDF.set_title">set_title</a></code></li>
<li><code><a title="fpdf.FPDF.set_top_margin" href="#fpdf.FPDF.set_top_margin">set_top_margin</a></code></li>
<li><code><a title="fpdf.FPDF.set_x" href="#fpdf.FPDF.set_x">set_x</a></code></li>
<li><code><a title="fpdf.FPDF.set_xmp_metadata" href="#fpdf.FPDF.set_xmp_metadata">set_xmp_metadata</a></code></li>
<li><code><a title="fpdf.FPDF.set_xy" href="#fpdf.FPDF.set_xy">set_xy</a></code></li>
<li><code><a title="fpdf.FPDF.set_y" href="#fpdf.FPDF.set_y">set_y</a></code></li>
<li><code><a title="fpdf.FPDF.solid_arc" href="#fpdf.FPDF.solid_arc">solid_arc</a></code></li>
<li><code><a title="fpdf.FPDF.start_section" href="#fpdf.FPDF.start_section">start_section</a></code></li>
<li><code><a title="fpdf.FPDF.text" href="#fpdf.FPDF.text">text</a></code></li>
<li><code><a title="fpdf.FPDF.text_annotation" href="#fpdf.FPDF.text_annotation">text_annotation</a></code></li>
<li><code><a title="fpdf.FPDF.unbreakable" href="#fpdf.FPDF.unbreakable">unbreakable</a></code></li>
<li><code><a title="fpdf.FPDF.unifontsubset" href="#fpdf.FPDF.unifontsubset">unifontsubset</a></code></li>
<li><code><a title="fpdf.FPDF.will_page_break" href="#fpdf.FPDF.will_page_break">will_page_break</a></code></li>
<li><code><a title="fpdf.FPDF.write" href="#fpdf.FPDF.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.FlexTemplate" href="#fpdf.FlexTemplate">FlexTemplate</a></code></h4>
<ul class="">
<li><code><a title="fpdf.FlexTemplate.load_elements" href="#fpdf.FlexTemplate.load_elements">load_elements</a></code></li>
<li><code><a title="fpdf.FlexTemplate.parse_csv" href="#fpdf.FlexTemplate.parse_csv">parse_csv</a></code></li>
<li><code><a title="fpdf.FlexTemplate.render" href="#fpdf.FlexTemplate.render">render</a></code></li>
<li><code><a title="fpdf.FlexTemplate.set" href="#fpdf.FlexTemplate.set">set</a></code></li>
<li><code><a title="fpdf.FlexTemplate.split_multicell" href="#fpdf.FlexTemplate.split_multicell">split_multicell</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.HTML2FPDF" href="#fpdf.HTML2FPDF">HTML2FPDF</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.HTML2FPDF.box_shadow" href="#fpdf.HTML2FPDF.box_shadow">box_shadow</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.error" href="#fpdf.HTML2FPDF.error">error</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.handle_data" href="#fpdf.HTML2FPDF.handle_data">handle_data</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.handle_endtag" href="#fpdf.HTML2FPDF.handle_endtag">handle_endtag</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.handle_starttag" href="#fpdf.HTML2FPDF.handle_starttag">handle_starttag</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.output_table_footer" href="#fpdf.HTML2FPDF.output_table_footer">output_table_footer</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.output_table_header" href="#fpdf.HTML2FPDF.output_table_header">output_table_header</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.output_table_sep" href="#fpdf.HTML2FPDF.output_table_sep">output_table_sep</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.put_link" href="#fpdf.HTML2FPDF.put_link">put_link</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.render_toc" href="#fpdf.HTML2FPDF.render_toc">render_toc</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.set_font" href="#fpdf.HTML2FPDF.set_font">set_font</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.set_style" href="#fpdf.HTML2FPDF.set_style">set_style</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.set_text_color" href="#fpdf.HTML2FPDF.set_text_color">set_text_color</a></code></li>
<li><code><a title="fpdf.HTML2FPDF.width2unit" href="#fpdf.HTML2FPDF.width2unit">width2unit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.HTMLMixin" href="#fpdf.HTMLMixin">HTMLMixin</a></code></h4>
<ul class="">
<li><code><a title="fpdf.HTMLMixin.HTML2FPDF_CLASS" href="#fpdf.HTMLMixin.HTML2FPDF_CLASS">HTML2FPDF_CLASS</a></code></li>
<li><code><a title="fpdf.HTMLMixin.write_html" href="#fpdf.HTMLMixin.write_html">write_html</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.Template" href="#fpdf.Template">Template</a></code></h4>
<ul class="">
<li><code><a title="fpdf.Template.add_page" href="#fpdf.Template.add_page">add_page</a></code></li>
<li><code><a title="fpdf.Template.render" href="#fpdf.Template.render">render</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.TitleStyle" href="#fpdf.TitleStyle">TitleStyle</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.TitleStyle.b_margin" href="#fpdf.TitleStyle.b_margin">b_margin</a></code></li>
<li><code><a title="fpdf.TitleStyle.color" href="#fpdf.TitleStyle.color">color</a></code></li>
<li><code><a title="fpdf.TitleStyle.font_family" href="#fpdf.TitleStyle.font_family">font_family</a></code></li>
<li><code><a title="fpdf.TitleStyle.font_size_pt" href="#fpdf.TitleStyle.font_size_pt">font_size_pt</a></code></li>
<li><code><a title="fpdf.TitleStyle.font_style" href="#fpdf.TitleStyle.font_style">font_style</a></code></li>
<li><code><a title="fpdf.TitleStyle.l_margin" href="#fpdf.TitleStyle.l_margin">l_margin</a></code></li>
<li><code><a title="fpdf.TitleStyle.t_margin" href="#fpdf.TitleStyle.t_margin">t_margin</a></code></li>
<li><code><a title="fpdf.TitleStyle.underline" href="#fpdf.TitleStyle.underline">underline</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.XPos" href="#fpdf.XPos">XPos</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.XPos.CENTER" href="#fpdf.XPos.CENTER">CENTER</a></code></li>
<li><code><a title="fpdf.XPos.END" href="#fpdf.XPos.END">END</a></code></li>
<li><code><a title="fpdf.XPos.LEFT" href="#fpdf.XPos.LEFT">LEFT</a></code></li>
<li><code><a title="fpdf.XPos.LMARGIN" href="#fpdf.XPos.LMARGIN">LMARGIN</a></code></li>
<li><code><a title="fpdf.XPos.RIGHT" href="#fpdf.XPos.RIGHT">RIGHT</a></code></li>
<li><code><a title="fpdf.XPos.RMARGIN" href="#fpdf.XPos.RMARGIN">RMARGIN</a></code></li>
<li><code><a title="fpdf.XPos.START" href="#fpdf.XPos.START">START</a></code></li>
<li><code><a title="fpdf.XPos.WCONT" href="#fpdf.XPos.WCONT">WCONT</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.YPos" href="#fpdf.YPos">YPos</a></code></h4>
<ul class="">
<li><code><a title="fpdf.YPos.BMARGIN" href="#fpdf.YPos.BMARGIN">BMARGIN</a></code></li>
<li><code><a title="fpdf.YPos.LAST" href="#fpdf.YPos.LAST">LAST</a></code></li>
<li><code><a title="fpdf.YPos.NEXT" href="#fpdf.YPos.NEXT">NEXT</a></code></li>
<li><code><a title="fpdf.YPos.TMARGIN" href="#fpdf.YPos.TMARGIN">TMARGIN</a></code></li>
<li><code><a title="fpdf.YPos.TOP" href="#fpdf.YPos.TOP">TOP</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>