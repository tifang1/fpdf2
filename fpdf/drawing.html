<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>fpdf.drawing API documentation</title>
<meta name="description" content="Vector drawing: managing colors, graphics states, paths, transforms …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.drawing</code></h1>
</header>
<section id="section-intro">
<p>Vector drawing: managing colors, graphics states, paths, transforms&hellip;</p>
<p>The contents of this module are internal to fpdf2, and not part of the public API.
They may change at any time without prior warning or any deprecation period,
in non-backward-compatible ways.</p>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="fpdf.drawing.DELIMITERS"><code class="name">var <span class="ident">DELIMITERS</span></code></dt>
<dd>
<div class="desc"><p>Special delimiter characters</p></div>
</dd>
<dt id="fpdf.drawing.EOL_CHARS"><code class="name">var <span class="ident">EOL_CHARS</span></code></dt>
<dd>
<div class="desc"><p>Characters PDF considers to mark the end of a line.</p></div>
</dd>
<dt id="fpdf.drawing.WHITESPACE"><code class="name">var <span class="ident">WHITESPACE</span></code></dt>
<dd>
<div class="desc"><p>Characters PDF considers to be whitespace.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fpdf.drawing.cmyk8"><code class="name flex">
<span>def <span class="ident">cmyk8</span></span>(<span>c, m, y, k, a=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a DeviceCMYK color from the given 8-bit CMYK values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Number</code></dt>
<dd>red color component. Must be in the interval [0, 255].</dd>
<dt><strong><code>m</code></strong> :&ensp;<code>Number</code></dt>
<dd>green color component. Must be in the interval [0, 255].</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>blue color component. Must be in the interval [0, 255].</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>Number</code></dt>
<dd>blue color component. Must be in the interval [0, 255].</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>Optional[Number]</code></dt>
<dd>alpha component. Must be <code>None</code> or in the interval
[0, 255]. 0 is fully transparent, 255 is fully opaque</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DeviceCMYK color representation.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if any components are not in their valid interval.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.color_from_hex_string"><code class="name flex">
<span>def <span class="ident">color_from_hex_string</span></span>(<span>hexstr)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse an RGB color from a css-style 8-bit hexadecimal color string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hexstr</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>of the form <code>#RGB</code>, <code>#RGBA</code>, <code>#RRGGBB</code>, or <code>#RRGGBBAA</code> (case
insensitive). Must include the leading octothorp. Forms omitting the alpha
field are interpreted as not specifying the opacity, so it will not be
explicitly set.</p>
<p>An alpha value of <code>00</code> is fully transparent and <code>FF</code> is fully opaque.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DeviceRGB representation of the color.</p></div>
</dd>
<dt id="fpdf.drawing.color_from_rgb_string"><code class="name flex">
<span>def <span class="ident">color_from_rgb_string</span></span>(<span>rgbstr)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse an RGB color from a css-style rgb(R, G, B, A) color string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rgbstr</code></strong> :&ensp;<code>str</code></dt>
<dd>of the form <code>rgb(R, G, B)</code> or <code>rgb(R, G, B, A)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DeviceRGB representation of the color.</p></div>
</dd>
<dt id="fpdf.drawing.convert_to_device_color"><code class="name flex">
<span>def <span class="ident">convert_to_device_color</span></span>(<span>r, g=-1, b=-1)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.gray8"><code class="name flex">
<span>def <span class="ident">gray8</span></span>(<span>g, a=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a DeviceGray color from the given 8-bit gray value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>g</code></strong> :&ensp;<code>Number</code></dt>
<dd>gray color component. Must be in the interval [0, 255]. 0 is black,
255 is white.</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>Optional[Number]</code></dt>
<dd>alpha component. Must be <code>None</code> or in the interval
[0, 255]. 0 is fully transparent, 255 is fully opaque</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DeviceGray color representation.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if any components are not in their valid interval.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.number_to_str"><code class="name flex">
<span>def <span class="ident">number_to_str</span></span>(<span>number)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a decimal number to a minimal string representation (no trailing 0 or .).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code>Number</code></dt>
<dd>the number to be converted to a string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number's string representation.</p></div>
</dd>
<dt id="fpdf.drawing.render_pdf_primitive"><code class="name flex">
<span>def <span class="ident">render_pdf_primitive</span></span>(<span>primitive)</span>
</code></dt>
<dd>
<div class="desc"><p>Render a Python value as a PDF primitive type.</p>
<p>Container types (tuples/lists and dicts) are rendered recursively. This supports
values of the type Name, str, bytes, numbers, booleans, list/tuple, and dict.</p>
<p>Any custom type can be passed in as long as it provides a <code>serialize</code> method that
takes no arguments and returns a string. The primitive object is returned directly
if it is an instance of the <code>Raw</code> class. Otherwise, The existence of the <code>serialize</code>
method is checked before any other type checking is performed, so, for example, a
<code>dict</code> subclass with a <code>serialize</code> method would be converted using its <code>pdf_repr</code>
method rather than the built-in <code>dict</code> conversion process.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>primitive</code></strong></dt>
<dd>the primitive value to convert to its PDF representation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Raw-wrapped str of the PDF representation.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if a dictionary key is not a Name.</dd>
<dt><code>TypeError</code></dt>
<dd>if <code>primitive</code> does not have a known conversion to a PDF
representation.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.rgb8"><code class="name flex">
<span>def <span class="ident">rgb8</span></span>(<span>r, g, b, a=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a DeviceRGB color from the given 8-bit RGB values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>Number</code></dt>
<dd>red color component. Must be in the interval [0, 255].</dd>
<dt><strong><code>g</code></strong> :&ensp;<code>Number</code></dt>
<dd>green color component. Must be in the interval [0, 255].</dd>
<dt><strong><code>b</code></strong> :&ensp;<code>Number</code></dt>
<dd>blue color component. Must be in the interval [0, 255].</dd>
<dt><strong><code>a</code></strong> :&ensp;<code>Optional[Number]</code></dt>
<dd>alpha component. Must be <code>None</code> or in the interval
[0, 255]. 0 is fully transparent, 255 is fully opaque</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>DeviceRGB color representation.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if any components are not in their valid interval.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.drawing.Arc"><code class="flex name class">
<span>class <span class="ident">Arc</span></span>
<span>(</span><span>radii: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>, rotation: Union[int, float, decimal.Decimal], large: bool, sweep: bool, end: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>An elliptical arc path element.</p>
<p>The arc is drawn from the end of the current path element to its specified end point
using a number of parameters to determine how it is constructed.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.arc_to" href="#fpdf.drawing.PaintedPath.arc_to">PaintedPath.arc_to()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L2364-L2580" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Arc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_to`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc.&#34;&#34;&#34;

    @staticmethod
    @force_nodocument
    def subdivde_sweep(sweep_angle):
        &#34;&#34;&#34;
        A generator that subdivides a swept angle into segments no larger than a quarter
        turn.

        Any sweep that is larger than a quarter turn is subdivided into as many equally
        sized segments as necessary to prevent any individual segment from being larger
        than a quarter turn.

        This is used for approximating a circular curve segment using cubic Bézier
        curves. This computes the parameters used for the Bézier approximation up
        front, as well as the transform necessary to place the segment in the correct
        position.

        Args:
            sweep_angle (Number): the angle to subdivide.

        Yields:
            A tuple of (ctrl1, ctrl2, end) representing the control and end points of
            the cubic Bézier curve approximating the segment as a unit circle centered
            at the origin.
        &#34;&#34;&#34;
        sweep_angle = abs(sweep_angle)
        sweep_left = sweep_angle

        quarterturn = math.pi / 2
        chunks = math.ceil(sweep_angle / quarterturn)

        sweep_segment = sweep_angle / chunks
        cos_t = math.cos(sweep_segment)
        sin_t = math.sin(sweep_segment)
        kappa = 4 / 3 * math.tan(sweep_segment / 4)

        ctrl1 = Point(1, kappa)
        ctrl2 = Point(cos_t + kappa * sin_t, sin_t - kappa * cos_t)
        end = Point(cos_t, sin_t)

        for _ in range(chunks):
            offset = sweep_angle - sweep_left

            transform = Transform.rotation(offset)
            yield ctrl1 @ transform, ctrl2 @ transform, end @ transform

            sweep_left -= sweep_segment

    def _approximate_arc(self, last_item):
        &#34;&#34;&#34;
        Approximate this arc with a sequence of `BezierCurve`.

        Args:
            last_item: the previous path element (used for its end point)

        Returns:
            a list of `BezierCurve`.
        &#34;&#34;&#34;
        radii = self.radii

        reverse = Transform.rotation(-self.rotation)
        forward = Transform.rotation(self.rotation)

        prime = ((last_item.end_point - self.end) * 0.5) @ reverse

        lam_da = (prime.x / radii.x) ** 2 + (prime.y / radii.y) ** 2

        if lam_da &gt; 1:
            radii = Point(x=(lam_da**0.5) * radii.x, y=(lam_da**0.5) * radii.y)

        sign = (self.large != self.sweep) - (self.large == self.sweep)
        rxry2 = (radii.x * radii.y) ** 2
        rxpy2 = (radii.x * prime.y) ** 2
        rypx2 = (radii.y * prime.x) ** 2

        centerprime = (
            sign
            * math.sqrt(round(rxry2 - rxpy2 - rypx2, 8) / (rxpy2 + rypx2))
            * Point(
                x=radii.x * prime.y / radii.y,
                y=-radii.y * prime.x / radii.x,
            )
        )

        center = (centerprime @ forward) + ((last_item.end_point + self.end) * 0.5)

        arcstart = Point(
            x=(prime.x - centerprime.x) / radii.x,
            y=(prime.y - centerprime.y) / radii.y,
        )
        arcend = Point(
            x=(-prime.x - centerprime.x) / radii.x,
            y=(-prime.y - centerprime.y) / radii.y,
        )

        theta = Point(1, 0).angle(arcstart)
        deltatheta = arcstart.angle(arcend)

        if (self.sweep is False) and (deltatheta &gt; 0):
            deltatheta -= math.tau
        elif (self.sweep is True) and (deltatheta &lt; 0):
            deltatheta += math.tau

        sweep_sign = (deltatheta &gt;= 0) - (deltatheta &lt; 0)
        final_tf = (
            Transform.scaling(x=1, y=sweep_sign)  # flip negative sweeps
            .rotate(theta)  # rotate start of arc to correct position
            .scale(radii.x, radii.y)  # scale unit circle into the final ellipse shape
            .rotate(self.rotation)  # rotate the ellipse the specified angle
            .translate(center.x, center.y)  # translate to the final coordinates
        )

        curves = []

        for ctrl1, ctrl2, end in self.subdivde_sweep(deltatheta):
            curves.append(
                BezierCurve(ctrl1 @ final_tf, ctrl2 @ final_tf, end @ final_tf)
            )

        return curves

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        if not curves:
            return &#34;&#34;, last_item

        return (
            &#34; &#34;.join(
                curve.render(gsd_registry, style, prev, initial_point)[0]
                for prev, curve in zip([last_item, *curves[:-1]], curves)
            ),
            curves[-1],
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Arc.render`.
        &#34;&#34;&#34;
        curves = self._approximate_arc(last_item)

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not curves:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item

        previous = [last_item]
        for curve in curves[:-1]:
            previous.append(curve)
            debug_stream.write(pfx + f&#34; ├─ {curve}\n&#34;)
        debug_stream.write(pfx + f&#34; └─ {curves[-1]}\n&#34;)

        return (
            &#34; &#34;.join(
                curve.render(gsd_registry, style, prev, initial_point)[0]
                for prev, curve in zip(previous, curves)
            ),
            curves[-1],
            initial_point,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.Arc.end"><code class="name">var <span class="ident">end</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The end point of the arc.</p></div>
</dd>
<dt id="fpdf.drawing.Arc.large"><code class="name">var <span class="ident">large</span> : bool</code></dt>
<dd>
<div class="desc"><p>If True, sweep the arc over an angle greater than or equal to 180 degrees.</p></div>
</dd>
<dt id="fpdf.drawing.Arc.radii"><code class="name">var <span class="ident">radii</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The x- and y-radii of the arc. If <code>radii.x == radii.y</code> the arc will be circular.</p></div>
</dd>
<dt id="fpdf.drawing.Arc.rotation"><code class="name">var <span class="ident">rotation</span> : Union[int, float, decimal.Decimal]</code></dt>
<dd>
<div class="desc"><p>The rotation of the arc's major/minor axes relative to the coordinate frame.</p></div>
</dd>
<dt id="fpdf.drawing.Arc.sweep"><code class="name">var <span class="ident">sweep</span> : bool</code></dt>
<dd>
<div class="desc"><p>If True, the arc is swept in the positive angular direction.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.BezierCurve"><code class="flex name class">
<span>class <span class="ident">BezierCurve</span></span>
<span>(</span><span>c1: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>, c2: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>, end: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A cubic Bézier curve path element.</p>
<p>This draws a Bézier curve parameterized by the end point of the previous path
element, two off-curve control points, and an end point.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.curve_to" href="#fpdf.drawing.PaintedPath.curve_to">PaintedPath.curve_to()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L2048-L2117" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A cubic Bézier curve path element.

    This draws a Bézier curve parameterized by the end point of the previous path
    element, two off-curve control points, and an end point.

    See: `PaintedPath.curve_to`
    &#34;&#34;&#34;

    c1: Point
    &#34;&#34;&#34;The curve&#39;s first control point.&#34;&#34;&#34;
    c2: Point
    &#34;&#34;&#34;The curve&#39;s second control point.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point.&#34;&#34;&#34;

    @property
    def end_point(self):
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.end

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        return _render_curve(self.c1, self.c2, self.end), self, initial_point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `BezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.BezierCurve.c1"><code class="name">var <span class="ident">c1</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The curve's first control point.</p></div>
</dd>
<dt id="fpdf.drawing.BezierCurve.c2"><code class="name">var <span class="ident">c2</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The curve's second control point.</p></div>
</dd>
<dt id="fpdf.drawing.BezierCurve.end"><code class="name">var <span class="ident">end</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The curve's end point.</p></div>
</dd>
<dt id="fpdf.drawing.BezierCurve.end_point"><code class="name">prop <span class="ident">end_point</span></code></dt>
<dd>
<div class="desc"><p>The end point of this path element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end_point(self):
    &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
    return self.end</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.ClippingPath"><code class="flex name class">
<span>class <span class="ident">ClippingPath</span></span>
<span>(</span><span>x=0, y=0)</span>
</code></dt>
<dd>
<div class="desc"><p>The PaintedPath API but to be used to create clipping paths.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Unless you really know what you're doing, changing attributes of the clipping
path style is likely to produce unexpected results. This is because the
clipping path styles override implicit style inheritance of the <code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>
it applies to.</p>
<p>For example, <code>clippath.style.stroke_width = 2</code> can unexpectedly override
<code>paintpath.style.stroke_width = GraphicsStyle.INHERIT</code> and cause the painted
path to be rendered with a stroke of 2 instead of what it would have normally
inherited. Because a <code><a title="fpdf.drawing.ClippingPath" href="#fpdf.drawing.ClippingPath">ClippingPath</a></code> can be painted like a normal <code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>,
it would be overly restrictive to remove the ability to style it, so instead
this warning is here.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L3835-L3934" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ClippingPath(PaintedPath):
    &#34;&#34;&#34;
    The PaintedPath API but to be used to create clipping paths.

    .. warning::
        Unless you really know what you&#39;re doing, changing attributes of the clipping
        path style is likely to produce unexpected results. This is because the
        clipping path styles override implicit style inheritance of the `PaintedPath`
        it applies to.

        For example, `clippath.style.stroke_width = 2` can unexpectedly override
        `paintpath.style.stroke_width = GraphicsStyle.INHERIT` and cause the painted
        path to be rendered with a stroke of 2 instead of what it would have normally
        inherited. Because a `ClippingPath` can be painted like a normal `PaintedPath`,
        it would be overly restrictive to remove the ability to style it, so instead
        this warning is here.
    &#34;&#34;&#34;

    # because clipping paths can be painted, we inherit from PaintedPath. However, when
    # setting the styling on the clipping path, those values will also be applied to
    # the PaintedPath the ClippingPath is applied to unless they are explicitly set for
    # that painted path. This is not ideal, but there&#39;s no way to really fix it from
    # the PDF rendering model, and trying to track the appropriate state/defaults seems
    # similarly error prone.

    # In general, the expectation is that painted clipping paths are likely to be very
    # uncommon, so it&#39;s an edge case that isn&#39;t worth worrying too much about.

    def __init__(self, x=0, y=0):
        super().__init__(x=x, y=y)
        self.paint_rule = PathPaintRule.DONT_PAINT

    def render(
        self, gsd_registry, style, last_item, initial_point, debug_stream=None, pfx=None
    ):
        # painting the clipping path outside of its root graphics context allows it to
        # be transformed without affecting the transform of the graphics context of the
        # path it is being used to clip. This is because, unlike all of the other style
        # settings, transformations immediately affect the points following them,
        # rather than only affecting them at painting time. stroke settings and color
        # settings are applied only at paint time.

        if debug_stream:
            debug_stream.write(&#34;&lt;ClippingPath&gt; &#34;)

        (
            render_list,
            last_item,
            initial_point,
        ) = self._root_graphics_context.build_render_list(
            gsd_registry,
            style,
            last_item,
            initial_point,
            debug_stream,
            pfx,
            _push_stack=False,
        )

        merged_style = GraphicsStyle.merge(style, self.style)
        # we should never get a collision error here
        intersection_rule = merged_style.intersection_rule
        if intersection_rule is merged_style.INHERIT:
            intersection_rule = ClippingPathIntersectionRule.NONZERO
        else:
            intersection_rule = ClippingPathIntersectionRule[
                intersection_rule.name  # pylint: disable=no-member, useless-suppression
            ]

        paint_rule = merged_style.resolve_paint_rule()

        render_list.append(intersection_rule.value)
        render_list.append(paint_rule.value)

        return &#34; &#34;.join(render_list), last_item, initial_point

    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `ClippingPath.render`.
        &#34;&#34;&#34;
        return self.render(
            gsd_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.ClippingPath.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, gsd_registry, style, last_item, initial_point, debug_stream=None, pfx=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.ClippingPath.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, gsd_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gsd_registry</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStateDictRegistry" href="#fpdf.drawing.GraphicsStateDictRegistry">GraphicsStateDictRegistry</a></code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.ClippingPath.render" href="#fpdf.drawing.ClippingPath.render">ClippingPath.render()</a></code>.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></b></code>:
<ul class="hlist">
<li><code><a title="fpdf.drawing.PaintedPath.add_path_element" href="#fpdf.drawing.PaintedPath.add_path_element">add_path_element</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.arc_relative" href="#fpdf.drawing.PaintedPath.arc_relative">arc_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.arc_to" href="#fpdf.drawing.PaintedPath.arc_to">arc_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.auto_close" href="#fpdf.drawing.PaintedPath.auto_close">auto_close</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.circle" href="#fpdf.drawing.PaintedPath.circle">circle</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.clipping_path" href="#fpdf.drawing.PaintedPath.clipping_path">clipping_path</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.close" href="#fpdf.drawing.PaintedPath.close">close</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.curve_relative" href="#fpdf.drawing.PaintedPath.curve_relative">curve_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.curve_to" href="#fpdf.drawing.PaintedPath.curve_to">curve_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.ellipse" href="#fpdf.drawing.PaintedPath.ellipse">ellipse</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.horizontal_line_relative" href="#fpdf.drawing.PaintedPath.horizontal_line_relative">horizontal_line_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.horizontal_line_to" href="#fpdf.drawing.PaintedPath.horizontal_line_to">horizontal_line_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.line_relative" href="#fpdf.drawing.PaintedPath.line_relative">line_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.line_to" href="#fpdf.drawing.PaintedPath.line_to">line_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.move_relative" href="#fpdf.drawing.PaintedPath.move_relative">move_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.move_to" href="#fpdf.drawing.PaintedPath.move_to">move_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.paint_rule" href="#fpdf.drawing.PaintedPath.paint_rule">paint_rule</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.quadratic_curve_relative" href="#fpdf.drawing.PaintedPath.quadratic_curve_relative">quadratic_curve_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.quadratic_curve_to" href="#fpdf.drawing.PaintedPath.quadratic_curve_to">quadratic_curve_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.rectangle" href="#fpdf.drawing.PaintedPath.rectangle">rectangle</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.style" href="#fpdf.drawing.PaintedPath.style">style</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.transform" href="#fpdf.drawing.PaintedPath.transform">transform</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.transform_group" href="#fpdf.drawing.PaintedPath.transform_group">transform_group</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.vertical_line_relative" href="#fpdf.drawing.PaintedPath.vertical_line_relative">vertical_line_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.vertical_line_to" href="#fpdf.drawing.PaintedPath.vertical_line_to">vertical_line_to</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fpdf.drawing.Close"><code class="flex name class">
<span>class <span class="ident">Close</span></span>
</code></dt>
<dd>
<div class="desc"><p>A path close element.</p>
<p>Instructs the renderer to draw a straight line from the end of the last path element
to the start of the current path.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.close" href="#fpdf.drawing.PaintedPath.close">PaintedPath.close()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L3032-L3091" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Close(NamedTuple):
    &#34;&#34;&#34;
    A path close element.

    Instructs the renderer to draw a straight line from the end of the last path element
    to the start of the current path.

    See: `PaintedPath.close`
    &#34;&#34;&#34;

    # pylint: disable=no-self-use
    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is whatever the old
            last_item was.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        return &#34;h&#34;, Move(initial_point), initial_point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Close.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
</dd>
<dt id="fpdf.drawing.DeviceCMYK"><code class="flex name class">
<span>class <span class="ident">DeviceCMYK</span></span>
<span>(</span><span>c, m, y, k, a=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class representing a PDF DeviceCMYK color.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L298-L329" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DeviceCMYK(
    NamedTuple(
        &#34;DeviceCMYK&#34;,
        [
            (&#34;c&#34;, Number),
            (&#34;m&#34;, Number),
            (&#34;y&#34;, Number),
            (&#34;k&#34;, Number),
            (&#34;a&#34;, Optional[Number]),
        ],
    )
):
    &#34;&#34;&#34;A class representing a PDF DeviceCMYK color.&#34;&#34;&#34;

    OPERATOR = &#34;k&#34;
    &#34;&#34;&#34;The PDF drawing operator used to specify this type of color.&#34;&#34;&#34;

    def __new__(cls, c, m, y, k, a=None):
        if a is not None:
            _check_range(a)

        return super().__new__(
            cls, _check_range(c), _check_range(m), _check_range(y), _check_range(k), a
        )

    @property
    def colors(self):
        &#34;The color components as a tuple in order (c, m, y, k) with alpha omitted, in range 0-1.&#34;
        return self[:-1]

    def serialize(self) -&gt; str:
        return &#34; &#34;.join(number_to_str(val) for val in self.colors) + f&#34; {self.OPERATOR}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.DeviceCMYK.colors"><code class="name">prop <span class="ident">colors</span></code></dt>
<dd>
<div class="desc"><p>The color components as a tuple in order (c, m, y, k) with alpha omitted, in range 0-1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def colors(self):
    &#34;The color components as a tuple in order (c, m, y, k) with alpha omitted, in range 0-1.&#34;
    return self[:-1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.DeviceCMYK.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.DeviceGray"><code class="flex name class">
<span>class <span class="ident">DeviceGray</span></span>
<span>(</span><span>g, a=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class representing a PDF DeviceGray color.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L246-L274" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DeviceGray(
    NamedTuple(
        &#34;DeviceGray&#34;,
        [(&#34;g&#34;, Number), (&#34;a&#34;, Optional[Number])],
    )
):
    &#34;&#34;&#34;A class representing a PDF DeviceGray color.&#34;&#34;&#34;

    OPERATOR = &#34;g&#34;
    &#34;&#34;&#34;The PDF drawing operator used to specify this type of color.&#34;&#34;&#34;

    def __new__(cls, g, a=None):
        if a is not None:
            _check_range(a)

        return super().__new__(cls, _check_range(g), a)

    @property
    def colors(self):
        &#34;The color components as a tuple in order (r, g, b) with alpha omitted, in range 0-1.&#34;
        return self.g, self.g, self.g

    @property
    def colors255(self):
        &#34;The color components as a tuple in order `(r, g, b)` with alpha omitted, in range 0-255.&#34;
        return tuple(255 * v for v in self.colors)

    def serialize(self) -&gt; str:
        return f&#34;{number_to_str(self.g)} {self.OPERATOR}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.DeviceGray.colors"><code class="name">prop <span class="ident">colors</span></code></dt>
<dd>
<div class="desc"><p>The color components as a tuple in order (r, g, b) with alpha omitted, in range 0-1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def colors(self):
    &#34;The color components as a tuple in order (r, g, b) with alpha omitted, in range 0-1.&#34;
    return self.g, self.g, self.g</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.DeviceGray.colors255"><code class="name">prop <span class="ident">colors255</span></code></dt>
<dd>
<div class="desc"><p>The color components as a tuple in order <code>(r, g, b)</code> with alpha omitted, in range 0-255.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def colors255(self):
    &#34;The color components as a tuple in order `(r, g, b)` with alpha omitted, in range 0-255.&#34;
    return tuple(255 * v for v in self.colors)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.DeviceGray.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.DeviceRGB"><code class="flex name class">
<span>class <span class="ident">DeviceRGB</span></span>
<span>(</span><span>r, g, b, a=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class representing a PDF DeviceRGB color.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L182-L226" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DeviceRGB(
    NamedTuple(
        &#34;DeviceRGB&#34;,
        [(&#34;r&#34;, Number), (&#34;g&#34;, Number), (&#34;b&#34;, Number), (&#34;a&#34;, Optional[Number])],
    )
):
    &#34;&#34;&#34;A class representing a PDF DeviceRGB color.&#34;&#34;&#34;

    # This follows a common PDF drawing operator convention where the operand is upcased
    # to apply to stroke and downcased to apply to fill.

    # This could be more manually specified by  `CS`/`cs` to set the color space(e.g. to
    # `/DeviceRGB`) and `SC`/`sc` to set the color parameters. The documentation isn&#39;t
    # perfectly clear on this front, but it appears that these cannot be set in the
    # current graphics state dictionary and instead is set in the current page resource
    # dictionary. fpdf appears to only generate a single resource dictionary for the
    # entire document, and even if it created one per page, it would still be a lot
    # clunkier to try to use that.

    # Because PDF hates me, personally, the opacity of the drawing HAS to be specified
    # in the current graphics state dictionary and does not exist as a standalone
    # directive.
    OPERATOR = &#34;rg&#34;
    &#34;&#34;&#34;The PDF drawing operator used to specify this type of color.&#34;&#34;&#34;

    def __new__(cls, r, g, b, a=None):
        if a is not None:
            _check_range(a)

        return super().__new__(
            cls, _check_range(r), _check_range(g), _check_range(b), a
        )

    @property
    def colors(self):
        &#34;The color components as a tuple in order `(r, g, b)` with alpha omitted, in range 0-1.&#34;
        return self[:-1]

    @property
    def colors255(self):
        &#34;The color components as a tuple in order `(r, g, b)` with alpha omitted, in range 0-255.&#34;
        return tuple(255 * v for v in self.colors)

    def serialize(self) -&gt; str:
        return &#34; &#34;.join(number_to_str(val) for val in self.colors) + f&#34; {self.OPERATOR}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.DeviceRGB.colors"><code class="name">prop <span class="ident">colors</span></code></dt>
<dd>
<div class="desc"><p>The color components as a tuple in order <code>(r, g, b)</code> with alpha omitted, in range 0-1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def colors(self):
    &#34;The color components as a tuple in order `(r, g, b)` with alpha omitted, in range 0-1.&#34;
    return self[:-1]</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.DeviceRGB.colors255"><code class="name">prop <span class="ident">colors255</span></code></dt>
<dd>
<div class="desc"><p>The color components as a tuple in order <code>(r, g, b)</code> with alpha omitted, in range 0-255.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def colors255(self):
    &#34;The color components as a tuple in order `(r, g, b)` with alpha omitted, in range 0-255.&#34;
    return tuple(255 * v for v in self.colors)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.DeviceRGB.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.DrawingContext"><code class="flex name class">
<span>class <span class="ident">DrawingContext</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base context for a drawing in a PDF</p>
<p>This context is not stylable and is mainly responsible for transforming path
drawing coordinates into user coordinates (i.e. it ensures that the output drawing
is correctly scaled).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L3094-L3261" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class DrawingContext:
    &#34;&#34;&#34;
    Base context for a drawing in a PDF

    This context is not stylable and is mainly responsible for transforming path
    drawing coordinates into user coordinates (i.e. it ensures that the output drawing
    is correctly scaled).
    &#34;&#34;&#34;

    def __init__(self):
        self._subitems = []

    def add_item(self, item, _copy=True):
        &#34;&#34;&#34;
        Append an item to this drawing context

        Args:
            item (GraphicsContext, PaintedPath): the item to be appended.
            _copy (bool): if true (the default), the item will be copied before being
                appended. This prevents modifications to a referenced object from
                &#34;retroactively&#34; altering its style/shape and should be disabled with
                caution.
        &#34;&#34;&#34;

        if not isinstance(item, (GraphicsContext, PaintedPath)):
            raise TypeError(f&#34;{item} doesn&#39;t belong in a DrawingContext&#34;)

        if _copy:
            item = copy.deepcopy(item)

        self._subitems.append(item)

    @staticmethod
    def _setup_render_prereqs(style, first_point, scale, height):
        style.auto_close = True
        style.paint_rule = PathPaintRule.AUTO
        style.intersection_rule = IntersectionRule.NONZERO

        last_item = Move(first_point)
        scale, last_item = (
            Transform.scaling(x=1, y=-1)
            .about(x=0, y=height / 2)
            .scale(scale)
            .render(last_item)
        )

        render_list = [&#34;q&#34;, scale]

        return render_list, style, last_item

    def render(self, gsd_registry, first_point, scale, height, starting_style):
        &#34;&#34;&#34;
        Render the drawing context to PDF format.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the parent document&#39;s graphics
                state registry.
            first_point (Point): the starting point to use if the first path element is
                a relative element.
            scale (Number): the scale factor to convert from PDF pt units into the
                document&#39;s semantic units (e.g. mm or in).
            height (Number): the page height. This is used to remap the coordinates to
                be from the top-left corner of the page (matching fpdf&#39;s behavior)
                instead of the PDF native behavior of bottom-left.
            starting_style (GraphicsStyle): the base style for this drawing context,
                derived from the document&#39;s current style defaults.

        Returns:
            A string composed of the PDF representation of all the paths and groups in
            this context (an empty string is returned if there are no paths or groups)
        &#34;&#34;&#34;
        if not self._subitems:
            return &#34;&#34;

        render_list, style, last_item = self._setup_render_prereqs(
            starting_style, first_point, scale, height
        )

        for item in self._subitems:
            rendered, last_item, first_point = item.render(
                gsd_registry, style, last_item, first_point
            )
            if rendered:
                render_list.append(rendered)

        # there was nothing to render: the only items are the start group and scale
        # transform.
        if len(render_list) == 2:
            return &#34;&#34;

        style_dict_name = gsd_registry.register_style(style)
        if style_dict_name is not None:
            render_list.insert(2, f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)
            render_list.insert(
                3,
                render_pdf_primitive(style.stroke_dash_pattern)
                + f&#34; {number_to_str(style.stroke_dash_phase)} d&#34;,
            )

        render_list.append(&#34;Q&#34;)

        return &#34; &#34;.join(render_list)

    def render_debug(
        self, gsd_registry, first_point, scale, height, starting_style, debug_stream
    ):
        &#34;&#34;&#34;
        Render the drawing context to PDF format.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the parent document&#39;s graphics
                state registry.
            first_point (Point): the starting point to use if the first path element is
                a relative element.
            scale (Number): the scale factor to convert from PDF pt units into the
                document&#39;s semantic units (e.g. mm or in).
            height (Number): the page height. This is used to remap the coordinates to
                be from the top-left corner of the page (matching fpdf&#39;s behavior)
                instead of the PDF native behavior of bottom-left.
            starting_style (GraphicsStyle): the base style for this drawing context,
                derived from the document&#39;s current style defaults.
            debug_stream (TextIO): a text stream to which a debug representation of the
                drawing structure will be written.

        Returns:
            A string composed of the PDF representation of all the paths and groups in
            this context (an empty string is returned if there are no paths or groups)
        &#34;&#34;&#34;
        render_list, style, last_item = self._setup_render_prereqs(
            starting_style, first_point, scale, height
        )

        debug_stream.write(&#34;ROOT\n&#34;)
        for child in self._subitems[:-1]:
            debug_stream.write(&#34; ├─ &#34;)
            rendered, last_item = child.render_debug(
                gsd_registry, style, last_item, debug_stream, &#34; │  &#34;
            )
            if rendered:
                render_list.append(rendered)

        if self._subitems:
            debug_stream.write(&#34; └─ &#34;)
            rendered, last_item, first_point = self._subitems[-1].render_debug(
                gsd_registry, style, last_item, first_point, debug_stream, &#34;    &#34;
            )
            if rendered:
                render_list.append(rendered)

            # there was nothing to render: the only items are the start group and scale
            # transform.
            if len(render_list) == 2:
                return &#34;&#34;

            style_dict_name = gsd_registry.register_style(style)
            if style_dict_name is not None:
                render_list.insert(2, f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)
                render_list.insert(
                    3,
                    render_pdf_primitive(style.stroke_dash_pattern)
                    + f&#34; {number_to_str(style.stroke_dash_phase)} d&#34;,
                )

            render_list.append(&#34;Q&#34;)

            return &#34; &#34;.join(render_list)

        return &#34;&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.DrawingContext.add_item"><code class="name flex">
<span>def <span class="ident">add_item</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p>Append an item to this drawing context</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a>, <a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code></dt>
<dd>the item to be appended.</dd>
<dt><strong><code>_copy</code></strong> :&ensp;<code>bool</code></dt>
<dd>if true (the default), the item will be copied before being
appended. This prevents modifications to a referenced object from
"retroactively" altering its style/shape and should be disabled with
caution.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.DrawingContext.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, gsd_registry, first_point, scale, height, starting_style)</span>
</code></dt>
<dd>
<div class="desc"><p>Render the drawing context to PDF format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gsd_registry</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStateDictRegistry" href="#fpdf.drawing.GraphicsStateDictRegistry">GraphicsStateDictRegistry</a></code></dt>
<dd>the parent document's graphics
state registry.</dd>
<dt><strong><code>first_point</code></strong> :&ensp;<code><a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>the starting point to use if the first path element is
a relative element.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>Number</code></dt>
<dd>the scale factor to convert from PDF pt units into the
document's semantic units (e.g. mm or in).</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>Number</code></dt>
<dd>the page height. This is used to remap the coordinates to
be from the top-left corner of the page (matching fpdf's behavior)
instead of the PDF native behavior of bottom-left.</dd>
<dt><strong><code>starting_style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the base style for this drawing context,
derived from the document's current style defaults.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string composed of the PDF representation of all the paths and groups in
this context (an empty string is returned if there are no paths or groups)</p></div>
</dd>
<dt id="fpdf.drawing.DrawingContext.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, gsd_registry, first_point, scale, height, starting_style, debug_stream)</span>
</code></dt>
<dd>
<div class="desc"><p>Render the drawing context to PDF format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gsd_registry</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStateDictRegistry" href="#fpdf.drawing.GraphicsStateDictRegistry">GraphicsStateDictRegistry</a></code></dt>
<dd>the parent document's graphics
state registry.</dd>
<dt><strong><code>first_point</code></strong> :&ensp;<code><a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>the starting point to use if the first path element is
a relative element.</dd>
<dt><strong><code>scale</code></strong> :&ensp;<code>Number</code></dt>
<dd>the scale factor to convert from PDF pt units into the
document's semantic units (e.g. mm or in).</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>Number</code></dt>
<dd>the page height. This is used to remap the coordinates to
be from the top-left corner of the page (matching fpdf's behavior)
instead of the PDF native behavior of bottom-left.</dd>
<dt><strong><code>starting_style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the base style for this drawing context,
derived from the document's current style defaults.</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>TextIO</code></dt>
<dd>a text stream to which a debug representation of the
drawing structure will be written.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string composed of the PDF representation of all the paths and groups in
this context (an empty string is returned if there are no paths or groups)</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.Ellipse"><code class="flex name class">
<span>class <span class="ident">Ellipse</span></span>
<span>(</span><span>radii: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>, center: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>An ellipse.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.ellipse" href="#fpdf.drawing.PaintedPath.ellipse">PaintedPath.ellipse()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L2861-L2968" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Ellipse(NamedTuple):
    &#34;&#34;&#34;
    An ellipse.

    See: `PaintedPath.ellipse`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;The x- and y-radii of the ellipse&#34;&#34;&#34;
    center: Point
    &#34;&#34;&#34;The abscissa and ordinate of the center of the ellipse&#34;&#34;&#34;

    def _decompose(self):
        items = []

        rx = abs(self.radii.x)
        ry = abs(self.radii.y)
        cx, cy = self.center

        arc_rad = Point(rx, ry)

        # this isn&#39;t the most efficient way to do this, computationally, but it&#39;s
        # internally consistent.
        if (rx != 0) and (ry != 0):
            items.append(Move(Point(cx + rx, cy)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy + ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx - rx, cy)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx, cy - ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(cx + rx, cy)))
            items.append(Close())

        return items

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `Move` to the center of the ellipse.
        &#34;&#34;&#34;
        components = self._decompose()

        if not components:
            return &#34;&#34;, last_item

        render_list = []
        for item in components:
            rendered, last_item, initial_point = item.render(
                gsd_registry, style, last_item, initial_point
            )
            render_list.append(rendered)

        return &#34; &#34;.join(render_list), Move(self.center), initial_point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Ellipse.render`.
        &#34;&#34;&#34;
        components = self._decompose()

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not components:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item

        render_list = []
        for item in components[:-1]:
            rendered, last_item, initial_point = item.render(
                gsd_registry, style, last_item, initial_point
            )
            debug_stream.write(pfx + f&#34; ├─ {item}\n&#34;)
            render_list.append(rendered)

        rendered, last_item, initial_point = components[-1].render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(pfx + f&#34; └─ {components[-1]}\n&#34;)
        render_list.append(rendered)

        return &#34; &#34;.join(render_list), Move(self.center), initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.Ellipse.center"><code class="name">var <span class="ident">center</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The abscissa and ordinate of the center of the ellipse</p></div>
</dd>
<dt id="fpdf.drawing.Ellipse.radii"><code class="name">var <span class="ident">radii</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The x- and y-radii of the ellipse</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.GraphicsContext"><code class="flex name class">
<span>class <span class="ident">GraphicsContext</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L3937-L4221" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GraphicsContext:
    def __init__(self):
        self.style = GraphicsStyle()
        self.path_items = []

        self._transform = None
        self._clipping_path = None

    def __deepcopy__(self, memo):
        copied = self.__class__()
        copied.style = copy.deepcopy(self.style, memo)
        copied.path_items = copy.deepcopy(self.path_items, memo)

        copied._transform = copy.deepcopy(self.transform, memo)
        copied._clipping_path = copy.deepcopy(self.clipping_path, memo)

        return copied

    @property
    def transform(self):
        return self._transform

    @transform.setter
    def transform(self, tf):
        self._transform = tf

    @property
    def clipping_path(self):
        &#34;&#34;&#34;The `ClippingPath` for this graphics context.&#34;&#34;&#34;
        return self._clipping_path

    @clipping_path.setter
    def clipping_path(self, new_clipath):
        self._clipping_path = new_clipath

    def add_item(self, item, _copy=True):
        &#34;&#34;&#34;
        Add a path element to this graphics context.

        Args:
            item: the path element to add. May be a primitive element or another
                `GraphicsContext` or a `PaintedPath`.
            _copy (bool): if true (the default), the item will be copied before being
                appended. This prevents modifications to a referenced object from
                &#34;retroactively&#34; altering its style/shape and should be disabled with
                caution.
        &#34;&#34;&#34;
        if _copy:
            item = copy.deepcopy(item)

        self.path_items.append(item)

    def remove_last_item(self):
        del self.path_items[-1]

    def merge(self, other_context):
        &#34;&#34;&#34;Copy another `GraphicsContext`&#39;s path items into this one.&#34;&#34;&#34;
        self.path_items.extend(other_context.path_items)

    @force_nodocument
    def build_render_list(
        self,
        gsd_registry,
        style,
        last_item,
        initial_point,
        debug_stream=None,
        pfx=None,
        _push_stack=True,
    ):
        &#34;&#34;&#34;
        Build a list composed of all all the individual elements rendered.

        This is used by `PaintedPath` and `ClippingPath` to reuse the `GraphicsContext`
        rendering process while still being able to inject some path specific items
        (e.g. the painting directive) before the render is collapsed into a single
        string.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).
            _push_stack (bool): if True, wrap the resulting render list in a push/pop
                graphics stack directive pair.

        Returns:
            `tuple[list[str], last_item]` where `last_item` is the past path element in
            this `GraphicsContext`
        &#34;&#34;&#34;
        render_list = []

        if self.path_items:
            if debug_stream is not None:
                debug_stream.write(f&#34;{self.__class__.__name__}&#34;)

            merged_style = style.__class__.merge(style, self.style)

            if debug_stream is not None:
                if self._transform:
                    debug_stream.write(f&#34;({self._transform})&#34;)

                styles_dbg = []
                for attr in merged_style.MERGE_PROPERTIES:
                    val = getattr(merged_style, attr)
                    if val is not merged_style.INHERIT:
                        if getattr(self.style, attr) is merged_style.INHERIT:
                            inh = &#34; (inherited)&#34;
                        else:
                            inh = &#34;&#34;

                        styles_dbg.append(f&#34;{attr}: {val}{inh}&#34;)

                if styles_dbg:
                    debug_stream.write(&#34; {\n&#34;)
                    for style_dbg_line in styles_dbg:
                        debug_stream.write(pfx + &#34;    &#34;)
                        debug_stream.write(style_dbg_line)
                        debug_stream.write(&#34;\n&#34;)

                    debug_stream.write(pfx + &#34;}┐\n&#34;)
                else:
                    debug_stream.write(&#34;\n&#34;)

            NO_EMIT_SET = {None, merged_style.INHERIT}

            emit_style = self.style
            if merged_style.allow_transparency != self.style.allow_transparency:
                emit_style = copy.deepcopy(self.style)
                emit_style.allow_transparency = merged_style.allow_transparency

            # in order to decouple the dash pattern and the dash phase at the API layer,
            # we have to perform additional logic here to recombine them. We can rely
            # on these being serializable because we always get a sane style on the
            # drawing context.
            dash_pattern = merged_style.stroke_dash_pattern
            dash_phase = merged_style.stroke_dash_phase
            if (dash_pattern != style.stroke_dash_pattern) or (
                dash_phase != style.stroke_dash_phase
            ):
                if emit_style is self.style:
                    emit_style = copy.deepcopy(emit_style)
                emit_style.stroke_dash_pattern = dash_pattern
                emit_style.stroke_dash_phase = dash_phase

                emit_dash = (dash_pattern, dash_phase)
            else:
                emit_dash = None

            style_dict_name = gsd_registry.register_style(emit_style)

            if style_dict_name is not None:
                render_list.append(f&#34;{render_pdf_primitive(style_dict_name)} gs&#34;)

            # we can&#39;t set color in the graphics state context dictionary, so we have to
            # manually inherit it and emit it here.
            fill_color = self.style.fill_color
            stroke_color = self.style.stroke_color

            if fill_color not in NO_EMIT_SET:
                render_list.append(fill_color.serialize().lower())

            if stroke_color not in NO_EMIT_SET:
                render_list.append(stroke_color.serialize().upper())

            if emit_dash is not None:
                render_list.append(
                    render_pdf_primitive(emit_dash[0])
                    + f&#34; {number_to_str(emit_dash[1])} d&#34;
                )

            if debug_stream:
                if self.clipping_path is not None:
                    debug_stream.write(pfx + &#34; ├─ &#34;)
                    rendered_cpath, _, __ = self.clipping_path.render_debug(
                        gsd_registry,
                        merged_style,
                        last_item,
                        initial_point,
                        debug_stream,
                        pfx + &#34; │  &#34;,
                    )
                    if rendered_cpath:
                        render_list.append(rendered_cpath)

                for item in self.path_items[:-1]:
                    debug_stream.write(pfx + &#34; ├─ &#34;)
                    rendered, last_item, initial_point = item.render_debug(
                        gsd_registry,
                        merged_style,
                        last_item,
                        initial_point,
                        debug_stream,
                        pfx + &#34; │  &#34;,
                    )

                    if rendered:
                        render_list.append(rendered)

                debug_stream.write(pfx + &#34; └─ &#34;)
                rendered, last_item, initial_point = self.path_items[-1].render_debug(
                    gsd_registry,
                    merged_style,
                    last_item,
                    initial_point,
                    debug_stream,
                    pfx + &#34;    &#34;,
                )

                if rendered:
                    render_list.append(rendered)

            else:
                if self.clipping_path is not None:
                    rendered_cpath, _, __ = self.clipping_path.render(
                        gsd_registry, merged_style, last_item, initial_point
                    )
                    if rendered_cpath:
                        render_list.append(rendered_cpath)

                for item in self.path_items:
                    rendered, last_item, initial_point = item.render(
                        gsd_registry, merged_style, last_item, initial_point
                    )

                    if rendered:
                        render_list.append(rendered)

            # insert transform before points
            if self.transform is not None:
                render_list.insert(0, self.transform.render(last_item)[0])

            if _push_stack:
                render_list.insert(0, &#34;q&#34;)
                render_list.append(&#34;Q&#34;)

        return render_list, last_item, initial_point

    def render(
        self,
        gsd_registry,
        style: DrawingContext,
        last_item,
        initial_point,
        debug_stream=None,
        pfx=None,
        _push_stack=True,
    ):
        render_list, last_item, initial_point = self.build_render_list(
            gsd_registry,
            style,
            last_item,
            initial_point,
            debug_stream,
            pfx,
            _push_stack=_push_stack,
        )

        return &#34; &#34;.join(render_list), last_item, initial_point

    def render_debug(
        self,
        gsd_registry,
        style: DrawingContext,
        last_item,
        initial_point,
        debug_stream,
        pfx,
        _push_stack=True,
    ):
        return self.render(
            gsd_registry,
            style,
            last_item,
            initial_point,
            debug_stream,
            pfx,
            _push_stack=_push_stack,
        )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.GraphicsContext.clipping_path"><code class="name">prop <span class="ident">clipping_path</span></code></dt>
<dd>
<div class="desc"><p>The <code><a title="fpdf.drawing.ClippingPath" href="#fpdf.drawing.ClippingPath">ClippingPath</a></code> for this graphics context.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def clipping_path(self):
    &#34;&#34;&#34;The `ClippingPath` for this graphics context.&#34;&#34;&#34;
    return self._clipping_path</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsContext.transform"><code class="name">prop <span class="ident">transform</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transform(self):
    return self._transform</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.GraphicsContext.add_item"><code class="name flex">
<span>def <span class="ident">add_item</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a path element to this graphics context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>the path element to add. May be a primitive element or another
<code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code> or a <code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code>.</dd>
<dt><strong><code>_copy</code></strong> :&ensp;<code>bool</code></dt>
<dd>if true (the default), the item will be copied before being
appended. This prevents modifications to a referenced object from
"retroactively" altering its style/shape and should be disabled with
caution.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, other_context)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy another <code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code>'s path items into this one.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.remove_last_item"><code class="name flex">
<span>def <span class="ident">remove_last_item</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, gsd_registry, style: <a title="fpdf.drawing.DrawingContext" href="#fpdf.drawing.DrawingContext">DrawingContext</a>, last_item, initial_point, debug_stream=None, pfx=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.GraphicsContext.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, gsd_registry, style: <a title="fpdf.drawing.DrawingContext" href="#fpdf.drawing.DrawingContext">DrawingContext</a>, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.GraphicsStateDictRegistry"><code class="flex name class">
<span>class <span class="ident">GraphicsStateDictRegistry</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A container providing deduplication of graphics state dictionaries across a PDF.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L69-L89" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GraphicsStateDictRegistry(OrderedDict):
    &#34;&#34;&#34;
    A container providing deduplication of graphics state dictionaries across a PDF.
    &#34;&#34;&#34;

    def register_style(self, style: &#34;GraphicsStyle&#34;):
        sdict = style.serialize()

        # empty style does not need a dictionary
        if not sdict:
            return None

        try:
            return self[sdict]
        except KeyError:
            pass

        name = Name(f&#34;GS{len(self)}&#34;)
        self[sdict] = name

        return name</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.OrderedDict</li>
<li>builtins.dict</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.GraphicsStateDictRegistry.register_style"><code class="name flex">
<span>def <span class="ident">register_style</span></span>(<span>self, style: <a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.GraphicsStyle"><code class="flex name class">
<span>class <span class="ident">GraphicsStyle</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class representing various style attributes that determine drawing appearance.</p>
<p>This class uses the convention that the global Python singleton ellipsis (<code>&hellip;</code>) is
exclusively used to represent values that are inherited from the parent style. This
is to disambiguate the value None which is used for several values to signal an
explicitly disabled style. An example of this is the fill/stroke color styles,
which use None as hints to the auto paint style detection code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L1080-L1511" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GraphicsStyle:
    &#34;&#34;&#34;
    A class representing various style attributes that determine drawing appearance.

    This class uses the convention that the global Python singleton ellipsis (`...`) is
    exclusively used to represent values that are inherited from the parent style. This
    is to disambiguate the value None which is used for several values to signal an
    explicitly disabled style. An example of this is the fill/stroke color styles,
    which use None as hints to the auto paint style detection code.
    &#34;&#34;&#34;

    INHERIT = ...
    &#34;&#34;&#34;Singleton specifying a style parameter should be inherited from the parent context.&#34;&#34;&#34;

    # order is be important here because some of these properties are entangled, e.g.
    # fill_color and fill_opacity
    MERGE_PROPERTIES = (
        &#34;paint_rule&#34;,
        &#34;allow_transparency&#34;,
        &#34;auto_close&#34;,
        &#34;intersection_rule&#34;,
        &#34;fill_color&#34;,
        &#34;fill_opacity&#34;,
        &#34;stroke_color&#34;,
        &#34;stroke_opacity&#34;,
        &#34;blend_mode&#34;,
        &#34;stroke_width&#34;,
        &#34;stroke_cap_style&#34;,
        &#34;stroke_join_style&#34;,
        &#34;stroke_miter_limit&#34;,
        &#34;stroke_dash_pattern&#34;,
        &#34;stroke_dash_phase&#34;,
    )
    &#34;&#34;&#34;An ordered collection of properties to use when merging two GraphicsStyles.&#34;&#34;&#34;

    TRANSPARENCY_KEYS = (
        PDFStyleKeys.FILL_ALPHA.value,
        PDFStyleKeys.STROKE_ALPHA.value,
        PDFStyleKeys.BLEND_MODE.value,
    )
    &#34;&#34;&#34;An ordered collection of attributes not to emit in no transparency mode.&#34;&#34;&#34;

    PDF_STYLE_KEYS = (
        *(k.value for k in PDFStyleKeys if k is not PDFStyleKeys.STROKE_DASH_PATTERN),
    )
    &#34;&#34;&#34;An ordered collection of keys to directly emit when serializing the style.&#34;&#34;&#34;

    _PAINT_RULE_LOOKUP = {
        frozenset({}): PathPaintRule.DONT_PAINT,
        frozenset({&#34;stroke&#34;}): PathPaintRule.STROKE,
        frozenset({&#34;fill&#34;, IntersectionRule.NONZERO}): PathPaintRule.FILL_NONZERO,
        frozenset({&#34;fill&#34;, IntersectionRule.EVENODD}): PathPaintRule.FILL_EVENODD,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.NONZERO}
        ): PathPaintRule.STROKE_FILL_NONZERO,
        frozenset(
            {&#34;stroke&#34;, &#34;fill&#34;, IntersectionRule.EVENODD}
        ): PathPaintRule.STROKE_FILL_EVENODD,
    }
    &#34;&#34;&#34;A dictionary for resolving `PathPaintRule.AUTO`&#34;&#34;&#34;

    @classmethod
    def merge(cls, parent, child):
        &#34;&#34;&#34;
        Merge parent and child into a single GraphicsStyle.

        The result contains the properties of the parent as overridden by any properties
        explicitly set on the child. If both the parent and the child specify to
        inherit a given property, that property will preserve the inherit value.
        &#34;&#34;&#34;
        new = cls()
        for prop in cls.MERGE_PROPERTIES:
            cval = getattr(child, prop)
            if cval is cls.INHERIT:
                setattr(new, prop, getattr(parent, prop))
            else:
                setattr(new, prop, cval)

        return new

    def __init__(self):
        self.allow_transparency = self.INHERIT
        self.paint_rule = self.INHERIT
        self.auto_close = self.INHERIT
        self.intersection_rule = self.INHERIT
        self.fill_color = self.INHERIT
        self.fill_opacity = self.INHERIT
        self.stroke_color = self.INHERIT
        self.stroke_opacity = self.INHERIT
        self.blend_mode = self.INHERIT
        self.stroke_width = self.INHERIT
        self.stroke_cap_style = self.INHERIT
        self.stroke_join_style = self.INHERIT
        self.stroke_miter_limit = self.INHERIT
        self.stroke_dash_pattern = self.INHERIT
        self.stroke_dash_phase = self.INHERIT

    def __deepcopy__(self, memo):
        copied = self.__class__()
        for prop in self.MERGE_PROPERTIES:
            setattr(copied, prop, getattr(self, prop))

        return copied

    def __setattr__(self, name, value):
        if not hasattr(self.__class__, name):
            raise AttributeError(
                f&#39;{self.__class__} does not have style &#34;{name}&#34; (a typo?)&#39;
            )

        super().__setattr__(name, value)

    # at some point it probably makes sense to turn this into a general compliance
    # property, but for now this is the simple approach.
    @property
    def allow_transparency(self):
        return self._allow_transparency  # pylint: disable=no-member

    @allow_transparency.setter
    def allow_transparency(self, new):
        return super().__setattr__(&#34;_allow_transparency&#34;, new)

    # If these are used in a nested graphics context inside of a painting path
    # operation, they are no-ops. However, they can be used for outer GraphicsContexts
    # that painting paths inherit from.
    @property
    def paint_rule(self):
        &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
        return self._paint_rule  # pylint: disable=no-member

    @paint_rule.setter
    def paint_rule(self, new):
        if new is None:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.DONT_PAINT)
        elif new is self.INHERIT:
            super().__setattr__(&#34;_paint_rule&#34;, new)
        else:
            super().__setattr__(&#34;_paint_rule&#34;, PathPaintRule.coerce(new))

    @property
    def auto_close(self):
        &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
        return self._auto_close  # pylint: disable=no-member

    @auto_close.setter
    def auto_close(self, new):
        if new not in {True, False, self.INHERIT}:
            raise TypeError(f&#34;auto_close must be a bool or self.INHERIT, not {new}&#34;)

        super().__setattr__(&#34;_auto_close&#34;, new)

    @property
    def intersection_rule(self):
        &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
        return self._intersection_rule  # pylint: disable=no-member

    @intersection_rule.setter
    def intersection_rule(self, new):
        # don&#39;t allow None for this one.
        if new is self.INHERIT:
            super().__setattr__(&#34;_intersection_rule&#34;, new)
        else:
            super().__setattr__(&#34;_intersection_rule&#34;, IntersectionRule.coerce(new))

    @property
    def fill_color(self):
        &#34;&#34;&#34;
        The desired fill color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._fill_color  # pylint: disable=no-member

    @fill_color.setter
    def fill_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK)):
            super().__setattr__(&#34;_fill_color&#34;, color)
            if color.a is not None:
                self.fill_opacity = color.a

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_fill_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def fill_opacity(self):
        &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.FILL_ALPHA.value)

    @fill_opacity.setter
    def fill_opacity(self, new):
        if new not in {None, self.INHERIT}:
            _check_range(new)

        super().__setattr__(PDFStyleKeys.FILL_ALPHA.value, new)

    @property
    def stroke_color(self):
        &#34;&#34;&#34;
        The desired stroke color for this path/group.

        When setting this property, if the color specifies an opacity value, that will
        be used to set the fill_opacity property as well.
        &#34;&#34;&#34;
        return self._stroke_color  # pylint: disable=no-member

    @stroke_color.setter
    def stroke_color(self, color):
        if isinstance(color, str):
            color = color_from_hex_string(color)

        if isinstance(color, (DeviceRGB, DeviceGray, DeviceCMYK)):
            super().__setattr__(&#34;_stroke_color&#34;, color)
            if color.a is not None:
                self.stroke_opacity = color.a
            if self.stroke_width is self.INHERIT:
                self.stroke_width = 1

        elif (color is None) or (color is self.INHERIT):
            super().__setattr__(&#34;_stroke_color&#34;, color)

        else:
            raise TypeError(f&#34;{color} doesn&#39;t look like a drawing color&#34;)

    @property
    def stroke_opacity(self):
        &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)

    @stroke_opacity.setter
    def stroke_opacity(self, new):
        if new not in {None, self.INHERIT}:
            _check_range(new)

        super().__setattr__(PDFStyleKeys.STROKE_ALPHA.value, new)

    @property
    def blend_mode(self):
        &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.BLEND_MODE.value)

    @blend_mode.setter
    def blend_mode(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.BLEND_MODE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.BLEND_MODE.value, BlendMode.coerce(value).value
            )

    @property
    def stroke_width(self):
        &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)

    @stroke_width.setter
    def stroke_width(self, width):
        if not isinstance(
            width,
            (int, float, decimal.Decimal, type(None), type(self.INHERIT)),
        ):
            raise TypeError(f&#34;stroke_width must be a number, not {type(width)}&#34;)

        super().__setattr__(PDFStyleKeys.STROKE_WIDTH.value, width)

    @property
    def stroke_cap_style(self):
        &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)

    @stroke_cap_style.setter
    def stroke_cap_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_CAP_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_CAP_STYLE.value, StrokeCapStyle.coerce(value)
            )

    @property
    def stroke_join_style(self):
        &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)

    @stroke_join_style.setter
    def stroke_join_style(self, value):
        if value is self.INHERIT:
            super().__setattr__(PDFStyleKeys.STROKE_JOIN_STYLE.value, value)
        else:
            super().__setattr__(
                PDFStyleKeys.STROKE_JOIN_STYLE.value,
                StrokeJoinStyle.coerce(value),
            )

    @property
    def stroke_miter_limit(self):
        &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
        return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)

    @stroke_miter_limit.setter
    def stroke_miter_limit(self, value):
        if (value is self.INHERIT) or isinstance(value, NumberClass):
            super().__setattr__(PDFStyleKeys.STROKE_MITER_LIMIT.value, value)
        else:
            raise TypeError(f&#34;{value} is not a number&#34;)

    @property
    def stroke_dash_pattern(self):
        &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_pattern  # pylint: disable=no-member

    @stroke_dash_pattern.setter
    def stroke_dash_pattern(self, value):
        if value is None:
            result = ()
        elif value is self.INHERIT:
            result = value
        elif isinstance(value, NumberClass):
            result = (value,)
        else:
            try:
                accum = []
                for item in value:
                    if not isinstance(item, NumberClass):
                        raise TypeError(
                            f&#34;stroke_dash_pattern {value} sequence has non-numeric value&#34;
                        )
                    accum.append(item)
            except TypeError:
                raise TypeError(
                    f&#34;stroke_dash_pattern {value} must be a number or sequence of numbers&#34;
                ) from None
            result = (*accum,)

        super().__setattr__(&#34;_stroke_dash_pattern&#34;, result)

    @property
    def stroke_dash_phase(self):
        &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
        return self._stroke_dash_phase  # pylint: disable=no-member

    @stroke_dash_phase.setter
    def stroke_dash_phase(self, value):
        if value is self.INHERIT or isinstance(value, NumberClass):
            return super().__setattr__(&#34;_stroke_dash_phase&#34;, value)

        raise TypeError(f&#34;{value} isn&#39;t a number or GraphicsStyle.INHERIT&#34;)

    def serialize(self):
        &#34;&#34;&#34;
        Convert this style object to a PDF dictionary with appropriate style keys.

        Only explicitly specified values are emitted.
        &#34;&#34;&#34;
        result = OrderedDict()

        for key in self.PDF_STYLE_KEYS:
            value = getattr(self, key, self.INHERIT)

            if (value is not self.INHERIT) and (value is not None):
                # None is used for out-of-band signaling on these, e.g. a stroke_width
                # of None doesn&#39;t need to land here because it signals the
                # PathPaintRule auto resolution only.
                result[key] = value

        # There is additional logic in GraphicsContext to ensure that this will work
        if self.stroke_dash_pattern and self.stroke_dash_pattern is not self.INHERIT:
            result[PDFStyleKeys.STROKE_DASH_PATTERN.value] = [
                self.stroke_dash_pattern,
                self.stroke_dash_phase,
            ]

        if self.allow_transparency is False:
            for key in self.TRANSPARENCY_KEYS:
                if key in result:
                    del result[key]

        if result:
            # Only insert this key if there is at least one other item in the result so
            # that we don&#39;t junk up the output PDF with empty ExtGState dictionaries.
            type_name = Name(&#34;Type&#34;)
            result[type_name] = Name(&#34;ExtGState&#34;)
            result.move_to_end(type_name, last=False)

            return render_pdf_primitive(result)

        # this signals to the GraphicsStateDictRegistry that there is nothing to
        # register. This is a success case.
        return None

    @force_nodocument
    def resolve_paint_rule(self):
        &#34;&#34;&#34;
        Resolve `PathPaintRule.AUTO` to a real paint rule based on this style.

        Returns:
            the resolved `PathPaintRule`.
        &#34;&#34;&#34;
        if self.paint_rule is PathPaintRule.AUTO:
            want = set()
            if self.stroke_width is not None and self.stroke_color is not None:
                want.add(&#34;stroke&#34;)
            if self.fill_color is not None:
                want.add(&#34;fill&#34;)
                # we need to guarantee that this will not be None. The default will
                # be &#34;nonzero&#34;.
                assert self.intersection_rule is not None
                want.add(self.intersection_rule)

            try:
                rule = self._PAINT_RULE_LOOKUP[frozenset(want)]
            except KeyError:
                # don&#39;t default to DONT_PAINT because that&#39;s almost certainly not a very
                # good default.
                rule = PathPaintRule.STROKE_FILL_NONZERO

        elif self.paint_rule is self.INHERIT:
            # this shouldn&#39;t happen under normal usage, but certain API (ab)use can end
            # up in this state. We can&#39;t resolve anything meaningful, so fall back to a
            # sane(?) default.
            rule = PathPaintRule.STROKE_FILL_NONZERO

        else:
            rule = self.paint_rule

        return rule</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.drawing.GraphicsStyle.INHERIT"><code class="name">var <span class="ident">INHERIT</span></code></dt>
<dd>
<div class="desc"><p>Singleton specifying a style parameter should be inherited from the parent context.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.MERGE_PROPERTIES"><code class="name">var <span class="ident">MERGE_PROPERTIES</span></code></dt>
<dd>
<div class="desc"><p>An ordered collection of properties to use when merging two GraphicsStyles.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.PDF_STYLE_KEYS"><code class="name">var <span class="ident">PDF_STYLE_KEYS</span></code></dt>
<dd>
<div class="desc"><p>An ordered collection of keys to directly emit when serializing the style.</p></div>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.TRANSPARENCY_KEYS"><code class="name">var <span class="ident">TRANSPARENCY_KEYS</span></code></dt>
<dd>
<div class="desc"><p>An ordered collection of attributes not to emit in no transparency mode.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.drawing.GraphicsStyle.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>parent, child)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge parent and child into a single GraphicsStyle.</p>
<p>The result contains the properties of the parent as overridden by any properties
explicitly set on the child. If both the parent and the child specify to
inherit a given property, that property will preserve the inherit value.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.GraphicsStyle.allow_transparency"><code class="name">prop <span class="ident">allow_transparency</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def allow_transparency(self):
    return self._allow_transparency  # pylint: disable=no-member</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.auto_close"><code class="name">prop <span class="ident">auto_close</span></code></dt>
<dd>
<div class="desc"><p>If True, unclosed paths will be automatically closed before stroking.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def auto_close(self):
    &#34;&#34;&#34;If True, unclosed paths will be automatically closed before stroking.&#34;&#34;&#34;
    return self._auto_close  # pylint: disable=no-member</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.blend_mode"><code class="name">prop <span class="ident">blend_mode</span></code></dt>
<dd>
<div class="desc"><p>The desired blend mode for this path/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def blend_mode(self):
    &#34;&#34;&#34;The desired blend mode for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.BLEND_MODE.value)</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.fill_color"><code class="name">prop <span class="ident">fill_color</span></code></dt>
<dd>
<div class="desc"><p>The desired fill color for this path/group.</p>
<p>When setting this property, if the color specifies an opacity value, that will
be used to set the fill_opacity property as well.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fill_color(self):
    &#34;&#34;&#34;
    The desired fill color for this path/group.

    When setting this property, if the color specifies an opacity value, that will
    be used to set the fill_opacity property as well.
    &#34;&#34;&#34;
    return self._fill_color  # pylint: disable=no-member</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.fill_opacity"><code class="name">prop <span class="ident">fill_opacity</span></code></dt>
<dd>
<div class="desc"><p>The desired fill opacity for this path/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fill_opacity(self):
    &#34;&#34;&#34;The desired fill opacity for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.FILL_ALPHA.value)</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.intersection_rule"><code class="name">prop <span class="ident">intersection_rule</span></code></dt>
<dd>
<div class="desc"><p>The desired intersection rule for this path/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def intersection_rule(self):
    &#34;&#34;&#34;The desired intersection rule for this path/group.&#34;&#34;&#34;
    return self._intersection_rule  # pylint: disable=no-member</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.paint_rule"><code class="name">prop <span class="ident">paint_rule</span></code></dt>
<dd>
<div class="desc"><p>The paint rule to use for this path/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def paint_rule(self):
    &#34;&#34;&#34;The paint rule to use for this path/group.&#34;&#34;&#34;
    return self._paint_rule  # pylint: disable=no-member</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_cap_style"><code class="name">prop <span class="ident">stroke_cap_style</span></code></dt>
<dd>
<div class="desc"><p>The desired stroke cap style for this path/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stroke_cap_style(self):
    &#34;&#34;&#34;The desired stroke cap style for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.STROKE_CAP_STYLE.value)</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_color"><code class="name">prop <span class="ident">stroke_color</span></code></dt>
<dd>
<div class="desc"><p>The desired stroke color for this path/group.</p>
<p>When setting this property, if the color specifies an opacity value, that will
be used to set the fill_opacity property as well.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stroke_color(self):
    &#34;&#34;&#34;
    The desired stroke color for this path/group.

    When setting this property, if the color specifies an opacity value, that will
    be used to set the fill_opacity property as well.
    &#34;&#34;&#34;
    return self._stroke_color  # pylint: disable=no-member</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_dash_pattern"><code class="name">prop <span class="ident">stroke_dash_pattern</span></code></dt>
<dd>
<div class="desc"><p>The desired stroke dash pattern for this path/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stroke_dash_pattern(self):
    &#34;&#34;&#34;The desired stroke dash pattern for this path/group.&#34;&#34;&#34;
    return self._stroke_dash_pattern  # pylint: disable=no-member</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_dash_phase"><code class="name">prop <span class="ident">stroke_dash_phase</span></code></dt>
<dd>
<div class="desc"><p>The desired stroke dash pattern phase offset for this path/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stroke_dash_phase(self):
    &#34;&#34;&#34;The desired stroke dash pattern phase offset for this path/group.&#34;&#34;&#34;
    return self._stroke_dash_phase  # pylint: disable=no-member</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_join_style"><code class="name">prop <span class="ident">stroke_join_style</span></code></dt>
<dd>
<div class="desc"><p>The desired stroke join style for this path/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stroke_join_style(self):
    &#34;&#34;&#34;The desired stroke join style for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.STROKE_JOIN_STYLE.value)</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_miter_limit"><code class="name">prop <span class="ident">stroke_miter_limit</span></code></dt>
<dd>
<div class="desc"><p>The desired stroke miter limit for this path/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stroke_miter_limit(self):
    &#34;&#34;&#34;The desired stroke miter limit for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.STROKE_MITER_LIMIT.value)</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_opacity"><code class="name">prop <span class="ident">stroke_opacity</span></code></dt>
<dd>
<div class="desc"><p>The desired stroke opacity for this path/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stroke_opacity(self):
    &#34;&#34;&#34;The desired stroke opacity for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.STROKE_ALPHA.value)</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.GraphicsStyle.stroke_width"><code class="name">prop <span class="ident">stroke_width</span></code></dt>
<dd>
<div class="desc"><p>The desired stroke width for this path/group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stroke_width(self):
    &#34;&#34;&#34;The desired stroke width for this path/group.&#34;&#34;&#34;
    return getattr(self, PDFStyleKeys.STROKE_WIDTH.value)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.GraphicsStyle.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert this style object to a PDF dictionary with appropriate style keys.</p>
<p>Only explicitly specified values are emitted.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.HorizontalLine"><code class="flex name class">
<span>class <span class="ident">HorizontalLine</span></span>
<span>(</span><span>x: Union[int, float, decimal.Decimal])</span>
</code></dt>
<dd>
<div class="desc"><p>A path line element that takes its ordinate from the end of the previous element.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.horizontal_line_to" href="#fpdf.drawing.PaintedPath.horizontal_line_to">PaintedPath.horizontal_line_to()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L1792-L1851" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class HorizontalLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element that takes its ordinate from the end of the previous element.

    See: `PaintedPath.horizontal_line_to`
    &#34;&#34;&#34;

    x: Number
    &#34;&#34;&#34;The abscissa of the horizontal line&#39;s end point.&#34;&#34;&#34;

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        end_point = Point(x=self.x, y=last_item.end_point.y)
        return _render_line(end_point), Line(end_point), initial_point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `HorizontalLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.HorizontalLine.x"><code class="name">var <span class="ident">x</span> : Union[int, float, decimal.Decimal]</code></dt>
<dd>
<div class="desc"><p>The abscissa of the horizontal line's end point.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.ImplicitClose"><code class="flex name class">
<span>class <span class="ident">ImplicitClose</span></span>
</code></dt>
<dd>
<div class="desc"><p>A path close element that is conditionally rendered depending on the value of
<code><a title="fpdf.drawing.GraphicsStyle.auto_close" href="#fpdf.drawing.GraphicsStyle.auto_close">GraphicsStyle.auto_close</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L2971-L3029" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ImplicitClose(NamedTuple):
    &#34;&#34;&#34;
    A path close element that is conditionally rendered depending on the value of
    `GraphicsStyle.auto_close`.
    &#34;&#34;&#34;

    # pylint: disable=no-self-use
    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is whatever the old
            last_item was.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        if style.auto_close:
            return &#34;h&#34;, last_item, initial_point

        return &#34;&#34;, last_item, initial_point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `ImplicitClose.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {rendered}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
</dd>
<dt id="fpdf.drawing.Line"><code class="flex name class">
<span>class <span class="ident">Line</span></span>
<span>(</span><span>pt: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A path line element.</p>
<p>This draws a straight line from the end point of the previous path element to the
point specified by <code>pt</code>.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.line_to" href="#fpdf.drawing.PaintedPath.line_to">PaintedPath.line_to()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L1658-L1723" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Line(NamedTuple):
    &#34;&#34;&#34;
    A path line element.

    This draws a straight line from the end point of the previous path element to the
    point specified by `pt`.

    See: `PaintedPath.line_to`
    &#34;&#34;&#34;

    pt: Point
    &#34;&#34;&#34;The point to which the line is drawn.&#34;&#34;&#34;

    @property
    def end_point(self):
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.pt

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        return _render_line(self.pt), self, initial_point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Line.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.Line.end_point"><code class="name">prop <span class="ident">end_point</span></code></dt>
<dd>
<div class="desc"><p>The end point of this path element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end_point(self):
    &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
    return self.pt</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.Line.pt"><code class="name">var <span class="ident">pt</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The point to which the line is drawn.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.Move"><code class="flex name class">
<span>class <span class="ident">Move</span></span>
<span>(</span><span>pt: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A path move element.</p>
<p>If a path has been created but not yet painted, this will create a new subpath.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.move_to" href="#fpdf.drawing.PaintedPath.move_to">PaintedPath.move_to()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L1526-L1590" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Move(NamedTuple):
    &#34;&#34;&#34;
    A path move element.

    If a path has been created but not yet painted, this will create a new subpath.

    See: `PaintedPath.move_to`
    &#34;&#34;&#34;

    pt: Point
    &#34;&#34;&#34;The point to which to move.&#34;&#34;&#34;

    @property
    def end_point(self):
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.pt

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        return _render_move(self.pt), self, self.pt

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Move.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(str(self) + &#34;\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.Move.end_point"><code class="name">prop <span class="ident">end_point</span></code></dt>
<dd>
<div class="desc"><p>The end point of this path element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end_point(self):
    &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
    return self.pt</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.Move.pt"><code class="name">var <span class="ident">pt</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The point to which to move.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.PaintedPath"><code class="flex name class">
<span>class <span class="ident">PaintedPath</span></span>
<span>(</span><span>x=0, y=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A path to be drawn by the PDF renderer.</p>
<p>A painted path is defined by a style and an arbitrary sequence of path elements,
which include the primitive path elements (<code><a title="fpdf.drawing.Move" href="#fpdf.drawing.Move">Move</a></code>, <code><a title="fpdf.drawing.Line" href="#fpdf.drawing.Line">Line</a></code>, <code><a title="fpdf.drawing.BezierCurve" href="#fpdf.drawing.BezierCurve">BezierCurve</a></code>, &hellip;) as
well as arbitrarily nested <code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code> containing their own sequence of
primitive path elements and <code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L3264-L3832" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PaintedPath:
    &#34;&#34;&#34;
    A path to be drawn by the PDF renderer.

    A painted path is defined by a style and an arbitrary sequence of path elements,
    which include the primitive path elements (`Move`, `Line`, `BezierCurve`, ...) as
    well as arbitrarily nested `GraphicsContext` containing their own sequence of
    primitive path elements and `GraphicsContext`.
    &#34;&#34;&#34;

    def __init__(self, x=0, y=0):
        self._root_graphics_context = GraphicsContext()
        self._graphics_context = self._root_graphics_context

        self._closed = True
        self._close_context = self._graphics_context

        self._starter_move = Move(Point(x, y))

    def __deepcopy__(self, memo):
        # there&#39;s no real way to recover the matching current _graphics_context after
        # copying the root context, but that&#39;s ok because we can just disallow copying
        # of paths under modification as that is almost certainly wrong usage.
        if self._graphics_context is not self._root_graphics_context:
            raise RuntimeError(f&#34;cannot copy path {self} while it is being modified&#34;)

        copied = self.__class__()
        copied._root_graphics_context = copy.deepcopy(self._root_graphics_context, memo)
        copied._graphics_context = copied._root_graphics_context
        copied._closed = self._closed
        copied._close_context = copied._graphics_context

        return copied

    @property
    def style(self):
        &#34;&#34;&#34;The `GraphicsStyle` applied to all elements of this path.&#34;&#34;&#34;
        return self._root_graphics_context.style

    @property
    def transform(self):
        &#34;&#34;&#34;The `Transform` that applies to all of the elements of this path.&#34;&#34;&#34;
        return self._root_graphics_context.transform

    @transform.setter
    def transform(self, tf):
        self._root_graphics_context.transform = tf

    @property
    def auto_close(self):
        &#34;&#34;&#34;If true, the path should automatically close itself before painting.&#34;&#34;&#34;
        return self.style.auto_close

    @auto_close.setter
    def auto_close(self, should):
        self.style.auto_close = should

    @property
    def paint_rule(self):
        &#34;&#34;&#34;Manually specify the `PathPaintRule` to use for rendering the path.&#34;&#34;&#34;
        return self.style.paint_rule

    @paint_rule.setter
    def paint_rule(self, style):
        self.style.paint_rule = style

    @property
    def clipping_path(self):
        &#34;&#34;&#34;Set the clipping path for this path.&#34;&#34;&#34;
        return self._root_graphics_context.clipping_path

    @clipping_path.setter
    def clipping_path(self, new_clipath):
        self._root_graphics_context.clipping_path = new_clipath

    @contextmanager
    def _new_graphics_context(self, _attach=True):
        old_graphics_context = self._graphics_context
        new_graphics_context = GraphicsContext()
        self._graphics_context = new_graphics_context
        try:
            yield new_graphics_context
            if _attach:
                old_graphics_context.add_item(new_graphics_context)
        finally:
            self._graphics_context = old_graphics_context

    @contextmanager
    def transform_group(self, transform):
        &#34;&#34;&#34;
        Apply the provided `Transform` to all points added within this context.
        &#34;&#34;&#34;
        with self._new_graphics_context() as ctxt:
            ctxt.transform = transform
            yield self

    def add_path_element(self, item, _copy=True):
        &#34;&#34;&#34;
        Add the given element as a path item of this path.

        Args:
            item: the item to add to this path.
            _copy (bool): if true (the default), the item will be copied before being
                appended. This prevents modifications to a referenced object from
                &#34;retroactively&#34; altering its style/shape and should be disabled with
                caution.
        &#34;&#34;&#34;
        if self._starter_move is not None:
            self._closed = False
            self._graphics_context.add_item(self._starter_move, _copy=False)
            self._close_context = self._graphics_context
            self._starter_move = None

        self._graphics_context.add_item(item, _copy=_copy)

    def remove_last_path_element(self):
        self._graphics_context.remove_last_item()

    def rectangle(self, x, y, w, h, rx=0, ry=0):
        &#34;&#34;&#34;
        Append a rectangle as a closed subpath to the current path.

        If the width or the height are 0, the rectangle will be collapsed to a line
        (unless they&#39;re both 0, in which case it&#39;s collapsed to nothing).

        Args:
            x (Number): the abscissa of the starting corner of the rectangle.
            y (Number): the ordinate of the starting corner of the rectangle.
            w (Number): the width of the rectangle (if 0, the rectangle will be
                rendered as a vertical line).
            h (Number): the height of the rectangle (if 0, the rectangle will be
                rendered as a horizontal line).
            rx (Number): the x-radius of the rectangle rounded corner (if 0 the corners
                will not be rounded).
            ry (Number): the y-radius of the rectangle rounded corner (if 0 the corners
                will not be rounded).

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;

        self._insert_implicit_close_if_open()
        self.add_path_element(
            RoundedRectangle(Point(x, y), Point(w, h), Point(rx, ry)), _copy=False
        )
        self._closed = True
        self.move_to(x, y)

        return self

    def circle(self, cx, cy, r):
        &#34;&#34;&#34;
        Append a circle as a closed subpath to the current path.

        Args:
            cx (Number): the abscissa of the circle&#39;s center point.
            cy (Number): the ordinate of the circle&#39;s center point.
            r (Number): the radius of the circle.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        return self.ellipse(cx, cy, r, r)

    def ellipse(self, cx, cy, rx, ry):
        &#34;&#34;&#34;
        Append an ellipse as a closed subpath to the current path.

        Args:
            cx (Number): the abscissa of the ellipse&#39;s center point.
            cy (Number): the ordinate of the ellipse&#39;s center point.
            rx (Number): the x-radius of the ellipse.
            ry (Number): the y-radius of the ellipse.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self._insert_implicit_close_if_open()
        self.add_path_element(Ellipse(Point(rx, ry), Point(cx, cy)), _copy=False)
        self._closed = True
        self.move_to(cx, cy)

        return self

    def move_to(self, x, y):
        &#34;&#34;&#34;
        Start a new subpath or move the path starting point.

        If no path elements have been added yet, this will change the path starting
        point. If path elements have been added, this will insert an implicit close in
        order to start a new subpath.

        Args:
            x (Number): abscissa of the (sub)path starting point.
            y (Number): ordinate of the (sub)path starting point.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self._insert_implicit_close_if_open()
        self._starter_move = Move(Point(x, y))
        return self

    def move_relative(self, x, y):
        &#34;&#34;&#34;
        Start a new subpath or move the path start point relative to the previous point.

        If no path elements have been added yet, this will change the path starting
        point. If path elements have been added, this will insert an implicit close in
        order to start a new subpath.

        This will overwrite an absolute move_to as long as no non-move path items have
        been appended. The relative position is resolved from the previous item when
        the path is being rendered, or from 0, 0 if it is the first item.

        Args:
            x (Number): abscissa of the (sub)path starting point relative to the.
            y (Number): ordinate of the (sub)path starting point relative to the.
        &#34;&#34;&#34;
        self._insert_implicit_close_if_open()
        if self._starter_move is not None:
            self._closed = False
            self._graphics_context.add_item(self._starter_move, _copy=False)
            self._close_context = self._graphics_context
        self._starter_move = RelativeMove(Point(x, y))
        return self

    def line_to(self, x, y):
        &#34;&#34;&#34;
        Append a straight line to this path.

        Args:
            x (Number): abscissa the line&#39;s end point.
            y (Number): ordinate of the line&#39;s end point.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self.add_path_element(Line(Point(x, y)), _copy=False)
        return self

    def line_relative(self, dx, dy):
        &#34;&#34;&#34;
        Append a straight line whose end is computed as an offset from the end of the
        previous path element.

        Args:
            x (Number): abscissa the line&#39;s end point relative to the end point of the
                previous path element.
            y (Number): ordinate of the line&#39;s end point relative to the end point of
                the previous path element.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self.add_path_element(RelativeLine(Point(dx, dy)), _copy=False)
        return self

    def horizontal_line_to(self, x):
        &#34;&#34;&#34;
        Append a straight horizontal line to the given abscissa. The ordinate is
        retrieved from the end point of the previous path element.

        Args:
            x (Number): abscissa of the line&#39;s end point.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self.add_path_element(HorizontalLine(x), _copy=False)
        return self

    def horizontal_line_relative(self, dx):
        &#34;&#34;&#34;
        Append a straight horizontal line to the given offset from the previous path
        element. The ordinate is retrieved from the end point of the previous path
        element.

        Args:
            x (Number): abscissa of the line&#39;s end point relative to the end point of
                the previous path element.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self.add_path_element(RelativeHorizontalLine(dx), _copy=False)
        return self

    def vertical_line_to(self, y):
        &#34;&#34;&#34;
        Append a straight vertical line to the given ordinate. The abscissa is
        retrieved from the end point of the previous path element.

        Args:
            y (Number): ordinate of the line&#39;s end point.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self.add_path_element(VerticalLine(y), _copy=False)
        return self

    def vertical_line_relative(self, dy):
        &#34;&#34;&#34;
        Append a straight vertical line to the given offset from the previous path
        element. The abscissa is retrieved from the end point of the previous path
        element.

        Args:
            y (Number): ordinate of the line&#39;s end point relative to the end point of
                the previous path element.

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        self.add_path_element(RelativeVerticalLine(dy), _copy=False)
        return self

    def curve_to(self, x1, y1, x2, y2, x3, y3):
        &#34;&#34;&#34;
        Append a cubic Bézier curve to this path.

        Args:
            x1 (Number): abscissa of the first control point
            y1 (Number): ordinate of the first control point
            x2 (Number): abscissa of the second control point
            y2 (Number): ordinate of the second control point
            x3 (Number): abscissa of the end point
            y3 (Number): ordinate of the end point

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        ctrl1 = Point(x1, y1)
        ctrl2 = Point(x2, y2)
        end = Point(x3, y3)

        self.add_path_element(BezierCurve(ctrl1, ctrl2, end), _copy=False)
        return self

    def curve_relative(self, dx1, dy1, dx2, dy2, dx3, dy3):
        &#34;&#34;&#34;
        Append a cubic Bézier curve whose points are expressed relative to the
        end point of the previous path element.

        E.g. with a start point of (0, 0), given (1, 1), (2, 2), (3, 3), the output
        curve would have the points:

        (0, 0) c1 (1, 1) c2 (3, 3) e (6, 6)

        Args:
            dx1 (Number): abscissa of the first control point relative to the end point
                of the previous path element
            dy1 (Number): ordinate of the first control point relative to the end point
                of the previous path element
            dx2 (Number): abscissa offset of the second control point relative to the
                end point of the previous path element
            dy2 (Number): ordinate offset of the second control point relative to the
                end point of the previous path element
            dx3 (Number): abscissa offset of the end point relative to the end point of
                the previous path element
            dy3 (Number): ordinate offset of the end point relative to the end point of
                the previous path element

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        c1d = Point(dx1, dy1)
        c2d = Point(dx2, dy2)
        end = Point(dx3, dy3)

        self.add_path_element(RelativeBezierCurve(c1d, c2d, end), _copy=False)
        return self

    def quadratic_curve_to(self, x1, y1, x2, y2):
        &#34;&#34;&#34;
        Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.

        Args:
            x1 (Number): abscissa of the control point
            y1 (Number): ordinate of the control point
            x2 (Number): abscissa of the end point
            y2 (Number): ordinate of the end point

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        ctrl = Point(x1, y1)
        end = Point(x2, y2)
        self.add_path_element(QuadraticBezierCurve(ctrl, end), _copy=False)
        return self

    def quadratic_curve_relative(self, dx1, dy1, dx2, dy2):
        &#34;&#34;&#34;
        Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.

        Args:
            dx1 (Number): abscissa of the control point relative to the end point of
                the previous path element
            dy1 (Number): ordinate of the control point relative to the end point of
                the previous path element
            dx2 (Number): abscissa offset of the end point relative to the end point of
                the previous path element
            dy2 (Number): ordinate offset of the end point relative to the end point of
                the previous path element

        Returns:
            The path, to allow chaining method calls.
        &#34;&#34;&#34;
        ctrl = Point(dx1, dy1)
        end = Point(dx2, dy2)
        self.add_path_element(RelativeQuadraticBezierCurve(ctrl, end), _copy=False)
        return self

    def arc_to(self, rx, ry, rotation, large_arc, positive_sweep, x, y):
        &#34;&#34;&#34;
        Append an elliptical arc from the end of the previous path point to the
        specified end point.

        The arc is approximated using Bézier curves, so it is not perfectly accurate.
        However, the error is small enough to not be noticeable at any reasonable
        (and even most unreasonable) scales, with a worst-case deviation of around 3‱.

        Notes:
            - The signs of the radii arguments (`rx` and `ry`) are ignored (i.e. their
              absolute values are used instead).
            - If either radius is 0, then a straight line will be emitted instead of an
              arc.
            - If the radii are too small for the arc to reach from the current point to
              the specified end point (`x` and `y`), then they will be proportionally
              scaled up until they are big enough, which will always result in a
              half-ellipse arc (i.e. an 180 degree sweep)

        Args:
            rx (Number): radius in the x-direction.
            ry (Number): radius in the y-direction.
            rotation (Number): angle (in degrees) that the arc should be rotated
                clockwise from the principle axes. This parameter does not have
                a visual effect in the case that `rx == ry`.
            large_arc (bool): if True, the arc will cover a sweep angle of at least 180
                degrees. Otherwise, the sweep angle will be at most 180 degrees.
            positive_sweep (bool): if True, the arc will be swept over a positive angle,
                i.e. clockwise. Otherwise, the arc will be swept over a negative
                angle.
            x (Number): abscissa of the arc&#39;s end point.
            y (Number): ordinate of the arc&#39;s end point.
        &#34;&#34;&#34;

        if rx == 0 or ry == 0:
            return self.line_to(x, y)

        radii = Point(abs(rx), abs(ry))
        large_arc = bool(large_arc)
        rotation = math.radians(rotation)
        positive_sweep = bool(positive_sweep)
        end = Point(x, y)

        self.add_path_element(
            Arc(radii, rotation, large_arc, positive_sweep, end), _copy=False
        )
        return self

    def arc_relative(self, rx, ry, rotation, large_arc, positive_sweep, dx, dy):
        &#34;&#34;&#34;
        Append an elliptical arc from the end of the previous path point to an offset
        point.

        The arc is approximated using Bézier curves, so it is not perfectly accurate.
        However, the error is small enough to not be noticeable at any reasonable
        (and even most unreasonable) scales, with a worst-case deviation of around 3‱.

        Notes:
            - The signs of the radii arguments (`rx` and `ry`) are ignored (i.e. their
              absolute values are used instead).
            - If either radius is 0, then a straight line will be emitted instead of an
              arc.
            - If the radii are too small for the arc to reach from the current point to
              the specified end point (`x` and `y`), then they will be proportionally
              scaled up until they are big enough, which will always result in a
              half-ellipse arc (i.e. an 180 degree sweep)

        Args:
            rx (Number): radius in the x-direction.
            ry (Number): radius in the y-direction.
            rotation (Number): angle (in degrees) that the arc should be rotated
                clockwise from the principle axes. This parameter does not have
                a visual effect in the case that `rx == ry`.
            large_arc (bool): if True, the arc will cover a sweep angle of at least 180
                degrees. Otherwise, the sweep angle will be at most 180 degrees.
            positive_sweep (bool): if True, the arc will be swept over a positive angle,
                i.e. clockwise. Otherwise, the arc will be swept over a negative
                angle.
            dx (Number): abscissa of the arc&#39;s end point relative to the end point of
                the previous path element.
            dy (Number): ordinate of the arc&#39;s end point relative to the end point of
                the previous path element.
        &#34;&#34;&#34;
        if rx == 0 or ry == 0:
            return self.line_relative(dx, dy)

        radii = Point(abs(rx), abs(ry))
        large_arc = bool(large_arc)
        rotation = math.radians(rotation)
        positive_sweep = bool(positive_sweep)
        end = Point(dx, dy)

        self.add_path_element(
            RelativeArc(radii, rotation, large_arc, positive_sweep, end), _copy=False
        )
        return self

    def close(self):
        &#34;&#34;&#34;
        Explicitly close the current (sub)path.
        &#34;&#34;&#34;
        self.add_path_element(Close(), _copy=False)
        self._closed = True
        self.move_relative(0, 0)

    def _insert_implicit_close_if_open(self):
        if not self._closed:
            self._close_context.add_item(ImplicitClose(), _copy=False)
            self._close_context = self._graphics_context
            self._closed = True

    def render(
        self, gsd_registry, style, last_item, initial_point, debug_stream=None, pfx=None
    ):
        self._insert_implicit_close_if_open()

        (
            render_list,
            last_item,
            initial_point,
        ) = self._root_graphics_context.build_render_list(
            gsd_registry, style, last_item, initial_point, debug_stream, pfx
        )

        paint_rule = GraphicsStyle.merge(style, self.style).resolve_paint_rule()

        render_list.insert(-1, paint_rule.value)

        return &#34; &#34;.join(render_list), last_item, initial_point

    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `PaintedPath.render`.
        &#34;&#34;&#34;
        return self.render(
            gsd_registry, style, last_item, initial_point, debug_stream, pfx
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fpdf.drawing.ClippingPath" href="#fpdf.drawing.ClippingPath">ClippingPath</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.PaintedPath.auto_close"><code class="name">prop <span class="ident">auto_close</span></code></dt>
<dd>
<div class="desc"><p>If true, the path should automatically close itself before painting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def auto_close(self):
    &#34;&#34;&#34;If true, the path should automatically close itself before painting.&#34;&#34;&#34;
    return self.style.auto_close</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.PaintedPath.clipping_path"><code class="name">prop <span class="ident">clipping_path</span></code></dt>
<dd>
<div class="desc"><p>Set the clipping path for this path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def clipping_path(self):
    &#34;&#34;&#34;Set the clipping path for this path.&#34;&#34;&#34;
    return self._root_graphics_context.clipping_path</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.PaintedPath.paint_rule"><code class="name">prop <span class="ident">paint_rule</span></code></dt>
<dd>
<div class="desc"><p>Manually specify the <code>PathPaintRule</code> to use for rendering the path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def paint_rule(self):
    &#34;&#34;&#34;Manually specify the `PathPaintRule` to use for rendering the path.&#34;&#34;&#34;
    return self.style.paint_rule</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.PaintedPath.style"><code class="name">prop <span class="ident">style</span></code></dt>
<dd>
<div class="desc"><p>The <code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code> applied to all elements of this path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def style(self):
    &#34;&#34;&#34;The `GraphicsStyle` applied to all elements of this path.&#34;&#34;&#34;
    return self._root_graphics_context.style</code></pre>
</details>
</dd>
<dt id="fpdf.drawing.PaintedPath.transform"><code class="name">prop <span class="ident">transform</span></code></dt>
<dd>
<div class="desc"><p>The <code><a title="fpdf.drawing.Transform" href="#fpdf.drawing.Transform">Transform</a></code> that applies to all of the elements of this path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def transform(self):
    &#34;&#34;&#34;The `Transform` that applies to all of the elements of this path.&#34;&#34;&#34;
    return self._root_graphics_context.transform</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.PaintedPath.add_path_element"><code class="name flex">
<span>def <span class="ident">add_path_element</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the given element as a path item of this path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd>the item to add to this path.</dd>
<dt><strong><code>_copy</code></strong> :&ensp;<code>bool</code></dt>
<dd>if true (the default), the item will be copied before being
appended. This prevents modifications to a referenced object from
"retroactively" altering its style/shape and should be disabled with
caution.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.arc_relative"><code class="name flex">
<span>def <span class="ident">arc_relative</span></span>(<span>self, rx, ry, rotation, large_arc, positive_sweep, dx, dy)</span>
</code></dt>
<dd>
<div class="desc"><p>Append an elliptical arc from the end of the previous path point to an offset
point.</p>
<p>The arc is approximated using Bézier curves, so it is not perfectly accurate.
However, the error is small enough to not be noticeable at any reasonable
(and even most unreasonable) scales, with a worst-case deviation of around 3‱.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>The signs of the radii arguments (<code>rx</code> and <code>ry</code>) are ignored (i.e. their
absolute values are used instead).</li>
<li>If either radius is 0, then a straight line will be emitted instead of an
arc.</li>
<li>If the radii are too small for the arc to reach from the current point to
the specified end point (<code>x</code> and <code>y</code>), then they will be proportionally
scaled up until they are big enough, which will always result in a
half-ellipse arc (i.e. an 180 degree sweep)</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rx</code></strong> :&ensp;<code>Number</code></dt>
<dd>radius in the x-direction.</dd>
<dt><strong><code>ry</code></strong> :&ensp;<code>Number</code></dt>
<dd>radius in the y-direction.</dd>
<dt><strong><code>rotation</code></strong> :&ensp;<code>Number</code></dt>
<dd>angle (in degrees) that the arc should be rotated
clockwise from the principle axes. This parameter does not have
a visual effect in the case that <code>rx == ry</code>.</dd>
<dt><strong><code>large_arc</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the arc will cover a sweep angle of at least 180
degrees. Otherwise, the sweep angle will be at most 180 degrees.</dd>
<dt><strong><code>positive_sweep</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the arc will be swept over a positive angle,
i.e. clockwise. Otherwise, the arc will be swept over a negative
angle.</dd>
<dt><strong><code>dx</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the arc's end point relative to the end point of
the previous path element.</dd>
<dt><strong><code>dy</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the arc's end point relative to the end point of
the previous path element.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.arc_to"><code class="name flex">
<span>def <span class="ident">arc_to</span></span>(<span>self, rx, ry, rotation, large_arc, positive_sweep, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Append an elliptical arc from the end of the previous path point to the
specified end point.</p>
<p>The arc is approximated using Bézier curves, so it is not perfectly accurate.
However, the error is small enough to not be noticeable at any reasonable
(and even most unreasonable) scales, with a worst-case deviation of around 3‱.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>The signs of the radii arguments (<code>rx</code> and <code>ry</code>) are ignored (i.e. their
absolute values are used instead).</li>
<li>If either radius is 0, then a straight line will be emitted instead of an
arc.</li>
<li>If the radii are too small for the arc to reach from the current point to
the specified end point (<code>x</code> and <code>y</code>), then they will be proportionally
scaled up until they are big enough, which will always result in a
half-ellipse arc (i.e. an 180 degree sweep)</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rx</code></strong> :&ensp;<code>Number</code></dt>
<dd>radius in the x-direction.</dd>
<dt><strong><code>ry</code></strong> :&ensp;<code>Number</code></dt>
<dd>radius in the y-direction.</dd>
<dt><strong><code>rotation</code></strong> :&ensp;<code>Number</code></dt>
<dd>angle (in degrees) that the arc should be rotated
clockwise from the principle axes. This parameter does not have
a visual effect in the case that <code>rx == ry</code>.</dd>
<dt><strong><code>large_arc</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the arc will cover a sweep angle of at least 180
degrees. Otherwise, the sweep angle will be at most 180 degrees.</dd>
<dt><strong><code>positive_sweep</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, the arc will be swept over a positive angle,
i.e. clockwise. Otherwise, the arc will be swept over a negative
angle.</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the arc's end point.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the arc's end point.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.circle"><code class="name flex">
<span>def <span class="ident">circle</span></span>(<span>self, cx, cy, r)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a circle as a closed subpath to the current path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cx</code></strong> :&ensp;<code>Number</code></dt>
<dd>the abscissa of the circle's center point.</dd>
<dt><strong><code>cy</code></strong> :&ensp;<code>Number</code></dt>
<dd>the ordinate of the circle's center point.</dd>
<dt><strong><code>r</code></strong> :&ensp;<code>Number</code></dt>
<dd>the radius of the circle.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Explicitly close the current (sub)path.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.curve_relative"><code class="name flex">
<span>def <span class="ident">curve_relative</span></span>(<span>self, dx1, dy1, dx2, dy2, dx3, dy3)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a cubic Bézier curve whose points are expressed relative to the
end point of the previous path element.</p>
<p>E.g. with a start point of (0, 0), given (1, 1), (2, 2), (3, 3), the output
curve would have the points:</p>
<p>(0, 0) c1 (1, 1) c2 (3, 3) e (6, 6)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dx1</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the first control point relative to the end point
of the previous path element</dd>
<dt><strong><code>dy1</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the first control point relative to the end point
of the previous path element</dd>
<dt><strong><code>dx2</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa offset of the second control point relative to the
end point of the previous path element</dd>
<dt><strong><code>dy2</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate offset of the second control point relative to the
end point of the previous path element</dd>
<dt><strong><code>dx3</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa offset of the end point relative to the end point of
the previous path element</dd>
<dt><strong><code>dy3</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate offset of the end point relative to the end point of
the previous path element</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.curve_to"><code class="name flex">
<span>def <span class="ident">curve_to</span></span>(<span>self, x1, y1, x2, y2, x3, y3)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a cubic Bézier curve to this path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the first control point</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the first control point</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the second control point</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the second control point</dd>
<dt><strong><code>x3</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the end point</dd>
<dt><strong><code>y3</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the end point</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>self, cx, cy, rx, ry)</span>
</code></dt>
<dd>
<div class="desc"><p>Append an ellipse as a closed subpath to the current path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cx</code></strong> :&ensp;<code>Number</code></dt>
<dd>the abscissa of the ellipse's center point.</dd>
<dt><strong><code>cy</code></strong> :&ensp;<code>Number</code></dt>
<dd>the ordinate of the ellipse's center point.</dd>
<dt><strong><code>rx</code></strong> :&ensp;<code>Number</code></dt>
<dd>the x-radius of the ellipse.</dd>
<dt><strong><code>ry</code></strong> :&ensp;<code>Number</code></dt>
<dd>the y-radius of the ellipse.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.horizontal_line_relative"><code class="name flex">
<span>def <span class="ident">horizontal_line_relative</span></span>(<span>self, dx)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a straight horizontal line to the given offset from the previous path
element. The ordinate is retrieved from the end point of the previous path
element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the line's end point relative to the end point of
the previous path element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.horizontal_line_to"><code class="name flex">
<span>def <span class="ident">horizontal_line_to</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a straight horizontal line to the given abscissa. The ordinate is
retrieved from the end point of the previous path element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the line's end point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.line_relative"><code class="name flex">
<span>def <span class="ident">line_relative</span></span>(<span>self, dx, dy)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a straight line whose end is computed as an offset from the end of the
previous path element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa the line's end point relative to the end point of the
previous path element.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the line's end point relative to the end point of
the previous path element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.line_to"><code class="name flex">
<span>def <span class="ident">line_to</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a straight line to this path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa the line's end point.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the line's end point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.move_relative"><code class="name flex">
<span>def <span class="ident">move_relative</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a new subpath or move the path start point relative to the previous point.</p>
<p>If no path elements have been added yet, this will change the path starting
point. If path elements have been added, this will insert an implicit close in
order to start a new subpath.</p>
<p>This will overwrite an absolute move_to as long as no non-move path items have
been appended. The relative position is resolved from the previous item when
the path is being rendered, or from 0, 0 if it is the first item.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the (sub)path starting point relative to the.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the (sub)path starting point relative to the.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.move_to"><code class="name flex">
<span>def <span class="ident">move_to</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a new subpath or move the path starting point.</p>
<p>If no path elements have been added yet, this will change the path starting
point. If path elements have been added, this will insert an implicit close in
order to start a new subpath.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the (sub)path starting point.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the (sub)path starting point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.quadratic_curve_relative"><code class="name flex">
<span>def <span class="ident">quadratic_curve_relative</span></span>(<span>self, dx1, dy1, dx2, dy2)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dx1</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the control point relative to the end point of
the previous path element</dd>
<dt><strong><code>dy1</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the control point relative to the end point of
the previous path element</dd>
<dt><strong><code>dx2</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa offset of the end point relative to the end point of
the previous path element</dd>
<dt><strong><code>dy2</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate offset of the end point relative to the end point of
the previous path element</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.quadratic_curve_to"><code class="name flex">
<span>def <span class="ident">quadratic_curve_to</span></span>(<span>self, x1, y1, x2, y2)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a cubic Bézier curve mimicking the specified quadratic Bézier curve.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the control point</dd>
<dt><strong><code>y1</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the control point</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the end point</dd>
<dt><strong><code>y2</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the end point</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.rectangle"><code class="name flex">
<span>def <span class="ident">rectangle</span></span>(<span>self, x, y, w, h, rx=0, ry=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a rectangle as a closed subpath to the current path.</p>
<p>If the width or the height are 0, the rectangle will be collapsed to a line
(unless they're both 0, in which case it's collapsed to nothing).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>the abscissa of the starting corner of the rectangle.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>the ordinate of the starting corner of the rectangle.</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>Number</code></dt>
<dd>the width of the rectangle (if 0, the rectangle will be
rendered as a vertical line).</dd>
<dt><strong><code>h</code></strong> :&ensp;<code>Number</code></dt>
<dd>the height of the rectangle (if 0, the rectangle will be
rendered as a horizontal line).</dd>
<dt><strong><code>rx</code></strong> :&ensp;<code>Number</code></dt>
<dd>the x-radius of the rectangle rounded corner (if 0 the corners
will not be rounded).</dd>
<dt><strong><code>ry</code></strong> :&ensp;<code>Number</code></dt>
<dd>the y-radius of the rectangle rounded corner (if 0 the corners
will not be rounded).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.remove_last_path_element"><code class="name flex">
<span>def <span class="ident">remove_last_path_element</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, gsd_registry, style, last_item, initial_point, debug_stream=None, pfx=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.render_debug"><code class="name flex">
<span>def <span class="ident">render_debug</span></span>(<span>self, gsd_registry, style, last_item, initial_point, debug_stream, pfx)</span>
</code></dt>
<dd>
<div class="desc"><p>Render this path element to its PDF representation and produce debug
information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gsd_registry</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStateDictRegistry" href="#fpdf.drawing.GraphicsStateDictRegistry">GraphicsStateDictRegistry</a></code></dt>
<dd>the owner's graphics state
dictionary registry.</dd>
<dt><strong><code>style</code></strong> :&ensp;<code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></dt>
<dd>the current resolved graphics style</dd>
<dt><strong><code>last_item</code></strong></dt>
<dd>the previous path element.</dd>
<dt><strong><code>initial_point</code></strong></dt>
<dd>last position set by a "M" or "m" command</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which the debug output should be
written. This is not guaranteed to be seekable (e.g. it may be stdout or
stderr).</dd>
<dt><strong><code>pfx</code></strong> :&ensp;<code>str</code></dt>
<dd>the current debug output prefix string (only needed if emitting
more than one line).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same tuple as <code><a title="fpdf.drawing.PaintedPath.render" href="#fpdf.drawing.PaintedPath.render">PaintedPath.render()</a></code>.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.transform_group"><code class="name flex">
<span>def <span class="ident">transform_group</span></span>(<span>self, transform)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the provided <code><a title="fpdf.drawing.Transform" href="#fpdf.drawing.Transform">Transform</a></code> to all points added within this context.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.vertical_line_relative"><code class="name flex">
<span>def <span class="ident">vertical_line_relative</span></span>(<span>self, dy)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a straight vertical line to the given offset from the previous path
element. The abscissa is retrieved from the end point of the previous path
element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the line's end point relative to the end point of
the previous path element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
<dt id="fpdf.drawing.PaintedPath.vertical_line_to"><code class="name flex">
<span>def <span class="ident">vertical_line_to</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Append a straight vertical line to the given ordinate. The abscissa is
retrieved from the end point of the previous path element.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the line's end point.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The path, to allow chaining method calls.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>x: Union[int, float, decimal.Decimal], y: Union[int, float, decimal.Decimal])</span>
</code></dt>
<dd>
<div class="desc"><p>An x-y coordinate pair within the two-dimensional coordinate frame.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L505-L717" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Point(NamedTuple):
    &#34;&#34;&#34;
    An x-y coordinate pair within the two-dimensional coordinate frame.
    &#34;&#34;&#34;

    x: Number
    &#34;&#34;&#34;The abscissa of the point.&#34;&#34;&#34;

    y: Number
    &#34;&#34;&#34;The ordinate of the point.&#34;&#34;&#34;

    def render(self):
        &#34;&#34;&#34;Render the point to the string `&#34;x y&#34;` for emitting to a PDF.&#34;&#34;&#34;

        return f&#34;{number_to_str(self.x)} {number_to_str(self.y)}&#34;

    def dot(self, other):
        &#34;&#34;&#34;
        Compute the dot product of two points.

        Args:
            other (Point): the point with which to compute the dot product.

        Returns:
            The scalar result of the dot product computation.

        Raises:
            TypeError: if `other` is not a `Point`.
        &#34;&#34;&#34;
        if not isinstance(other, Point):
            raise TypeError(f&#34;cannot dot with {other!r}&#34;)

        return self.x * other.x + self.y * other.y

    def angle(self, other):
        &#34;&#34;&#34;
        Compute the angle between two points (interpreted as vectors from the origin).

        The return value is in the interval (-pi, pi]. Sign is dependent on ordering,
        with clockwise angle travel considered to be positive due to the orientation of
        the coordinate frame basis vectors (i.e. the angle between `(1, 0)` and `(0, 1)`
        is `+pi/2`, the angle between `(1, 0)` and `(0, -1)` is `-pi/2`, and the angle
        between `(0, -1)` and `(1, 0)` is `+pi/2`).

        Args:
            other (Point): the point to compute the angle sweep toward.

        Returns:
            The scalar angle between the two points **in radians**.

        Raises:
            TypeError: if `other` is not a `Point`.
        &#34;&#34;&#34;

        if not isinstance(other, Point):
            raise TypeError(f&#34;cannot compute angle with {other!r}&#34;)

        signifier = (self.x * other.y) - (self.y * other.x)
        sign = (signifier &gt;= 0) - (signifier &lt; 0)
        return sign * math.acos(round(self.dot(other) / (self.mag() * other.mag()), 8))

    def mag(self):
        &#34;&#34;&#34;
        Compute the Cartesian distance from this point to the origin

        This is the same as computing the magnitude of the vector represented by this
        point.

        Returns:
            The scalar result of the distance computation.
        &#34;&#34;&#34;

        return (self.x**2 + self.y**2) ** 0.5

    @force_document
    def __add__(self, other):
        &#34;&#34;&#34;
        Produce the sum of two points.

        Adding two points is the same as translating the source point by interpreting
        the other point&#39;s x and y coordinates as distances.

        Args:
            other (Point): right-hand side of the infix addition operation

        Returns:
            A Point which is the sum of the two source points.
        &#34;&#34;&#34;
        if isinstance(other, Point):
            return Point(x=self.x + other.x, y=self.y + other.y)

        return NotImplemented

    @force_document
    def __sub__(self, other):
        &#34;&#34;&#34;
        Produce the difference between two points.

        Unlike addition, this is not a commutative operation!

        Args:
            other (Point): right-hand side of the infix subtraction operation

        Returns:
            A Point which is the difference of the two source points.
        &#34;&#34;&#34;
        if isinstance(other, Point):
            return Point(x=self.x - other.x, y=self.y - other.y)

        return NotImplemented

    @force_document
    def __neg__(self):
        &#34;&#34;&#34;
        Produce a point by negating this point&#39;s coordinates.

        Returns:
            A Point whose coordinates are this points coordinates negated.
        &#34;&#34;&#34;
        return Point(x=-self.x, y=-self.y)

    @force_document
    def __mul__(self, other):
        &#34;&#34;&#34;
        Multiply a point by a scalar value.

        Args:
            other (Number): the scalar value by which to multiply the point&#39;s
                coordinates.

        Returns:
            A Point whose coordinates are the result of the multiplication.
        &#34;&#34;&#34;
        if isinstance(other, NumberClass):
            return Point(self.x * other, self.y * other)

        return NotImplemented

    __rmul__ = __mul__

    @force_document
    def __truediv__(self, other):
        &#34;&#34;&#34;
        Divide a point by a scalar value.

        .. note::

            Because division is not commutative, `Point / scalar` is implemented, but
            `scalar / Point` is nonsensical and not implemented.

        Args:
            other (Number): the scalar value by which to divide the point&#39;s coordinates.

        Returns:
            A Point whose coordinates are the result of the division.
        &#34;&#34;&#34;
        if isinstance(other, NumberClass):
            return Point(self.x / other, self.y / other)

        return NotImplemented

    @force_document
    def __floordiv__(self, other):
        &#34;&#34;&#34;
        Divide a point by a scalar value using integer division.

        .. note::

            Because division is not commutative, `Point // scalar` is implemented, but
            `scalar // Point` is nonsensical and not implemented.

        Args:
            other (Number): the scalar value by which to divide the point&#39;s coordinates.

        Returns:
            A Point whose coordinates are the result of the division.
        &#34;&#34;&#34;
        if isinstance(other, NumberClass):
            return Point(self.x // other, self.y // other)

        return NotImplemented

    # no __r(true|floor)div__ because division is not commutative!

    @force_document
    def __matmul__(self, other):
        &#34;&#34;&#34;
        Transform a point with the given transform matrix.

        .. note::
            This operator is only implemented for Transforms. This transform is not
            commutative, so `Point @ Transform` is implemented, but `Transform @ Point`
            is not implemented (technically speaking, the current implementation is
            commutative because of the way points and transforms are represented, but
            if that representation were to change this operation could stop being
            commutative)

        Args:
            other (Transform): the transform to apply to the point

        Returns:
            A Point whose coordinates are the result of applying the transform.
        &#34;&#34;&#34;
        if isinstance(other, Transform):
            return Point(
                x=other.a * self.x + other.c * self.y + other.e,
                y=other.b * self.x + other.d * self.y + other.f,
            )

        return NotImplemented

    def __str__(self):
        return f&#34;(x={number_to_str(self.x)}, y={number_to_str(self.y)})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.Point.x"><code class="name">var <span class="ident">x</span> : Union[int, float, decimal.Decimal]</code></dt>
<dd>
<div class="desc"><p>The abscissa of the point.</p></div>
</dd>
<dt id="fpdf.drawing.Point.y"><code class="name">var <span class="ident">y</span> : Union[int, float, decimal.Decimal]</code></dt>
<dd>
<div class="desc"><p>The ordinate of the point.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.Point.__add__"><code class="name flex">
<span>def <span class="ident">__add__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce the sum of two points.</p>
<p>Adding two points is the same as translating the source point by interpreting
the other point's x and y coordinates as distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>right-hand side of the infix addition operation</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Point which is the sum of the two source points.</p></div>
</dd>
<dt id="fpdf.drawing.Point.__floordiv__"><code class="name flex">
<span>def <span class="ident">__floordiv__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Divide a point by a scalar value using integer division.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because division is not commutative, <code>Point // scalar</code> is implemented, but
<code>scalar // Point</code> is nonsensical and not implemented.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>Number</code></dt>
<dd>the scalar value by which to divide the point's coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Point whose coordinates are the result of the division.</p></div>
</dd>
<dt id="fpdf.drawing.Point.__matmul__"><code class="name flex">
<span>def <span class="ident">__matmul__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform a point with the given transform matrix.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator is only implemented for Transforms. This transform is not
commutative, so <code>Point @ Transform</code> is implemented, but <code>Transform @ Point</code>
is not implemented (technically speaking, the current implementation is
commutative because of the way points and transforms are represented, but
if that representation were to change this operation could stop being
commutative)</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="fpdf.drawing.Transform" href="#fpdf.drawing.Transform">Transform</a></code></dt>
<dd>the transform to apply to the point</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Point whose coordinates are the result of applying the transform.</p></div>
</dd>
<dt id="fpdf.drawing.Point.__mul__"><code class="name flex">
<span>def <span class="ident">__mul__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply a point by a scalar value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>Number</code></dt>
<dd>the scalar value by which to multiply the point's
coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Point whose coordinates are the result of the multiplication.</p></div>
</dd>
<dt id="fpdf.drawing.Point.__neg__"><code class="name flex">
<span>def <span class="ident">__neg__</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a point by negating this point's coordinates.</p>
<h2 id="returns">Returns</h2>
<p>A Point whose coordinates are this points coordinates negated.</p></div>
</dd>
<dt id="fpdf.drawing.Point.__sub__"><code class="name flex">
<span>def <span class="ident">__sub__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce the difference between two points.</p>
<p>Unlike addition, this is not a commutative operation!</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>right-hand side of the infix subtraction operation</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Point which is the difference of the two source points.</p></div>
</dd>
<dt id="fpdf.drawing.Point.__truediv__"><code class="name flex">
<span>def <span class="ident">__truediv__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Divide a point by a scalar value.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because division is not commutative, <code>Point / scalar</code> is implemented, but
<code>scalar / Point</code> is nonsensical and not implemented.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>Number</code></dt>
<dd>the scalar value by which to divide the point's coordinates.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Point whose coordinates are the result of the division.</p></div>
</dd>
<dt id="fpdf.drawing.Point.angle"><code class="name flex">
<span>def <span class="ident">angle</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the angle between two points (interpreted as vectors from the origin).</p>
<p>The return value is in the interval (-pi, pi]. Sign is dependent on ordering,
with clockwise angle travel considered to be positive due to the orientation of
the coordinate frame basis vectors (i.e. the angle between <code>(1, 0)</code> and <code>(0, 1)</code>
is <code>+pi/2</code>, the angle between <code>(1, 0)</code> and <code>(0, -1)</code> is <code>-pi/2</code>, and the angle
between <code>(0, -1)</code> and <code>(1, 0)</code> is <code>+pi/2</code>).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>the point to compute the angle sweep toward.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The scalar angle between the two points <strong>in radians</strong>.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>if <code>other</code> is not a <code><a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code>.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.Point.dot"><code class="name flex">
<span>def <span class="ident">dot</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the dot product of two points.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>the point with which to compute the dot product.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The scalar result of the dot product computation.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>if <code>other</code> is not a <code><a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code>.</dd>
</dl></div>
</dd>
<dt id="fpdf.drawing.Point.mag"><code class="name flex">
<span>def <span class="ident">mag</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Cartesian distance from this point to the origin</p>
<p>This is the same as computing the magnitude of the vector represented by this
point.</p>
<h2 id="returns">Returns</h2>
<p>The scalar result of the distance computation.</p></div>
</dd>
<dt id="fpdf.drawing.Point.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Render the point to the string <code>"x y"</code> for emitting to a PDF.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.QuadraticBezierCurve"><code class="flex name class">
<span>class <span class="ident">QuadraticBezierCurve</span></span>
<span>(</span><span>ctrl: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>, end: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A quadratic Bézier curve path element.</p>
<p>This draws a Bézier curve parameterized by the end point of the previous path
element, one off-curve control point, and an end point.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.quadratic_curve_to" href="#fpdf.drawing.PaintedPath.quadratic_curve_to">PaintedPath.quadratic_curve_to()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L2200-L2289" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class QuadraticBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A quadratic Bézier curve path element.

    This draws a Bézier curve parameterized by the end point of the previous path
    element, one off-curve control point, and an end point.

    See: `PaintedPath.quadratic_curve_to`
    &#34;&#34;&#34;

    ctrl: Point
    &#34;&#34;&#34;The curve&#39;s control point.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point.&#34;&#34;&#34;

    @property
    def end_point(self):
        &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
        return self.end

    def to_cubic_curve(self, start_point):
        ctrl = self.ctrl
        end = self.end

        ctrl1 = Point(
            x=start_point.x + 2 * (ctrl.x - start_point.x) / 3,
            y=start_point.y + 2 * (ctrl.y - start_point.y) / 3,
        )
        ctrl2 = Point(
            x=end.x + 2 * (ctrl.x - end.x) / 3,
            y=end.y + 2 * (ctrl.y - end.y) / 3,
        )

        return BezierCurve(ctrl1, ctrl2, end)

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is `self`.
        &#34;&#34;&#34;
        return (
            self.to_cubic_curve(last_item.end_point).render(
                gsd_registry, style, last_item, initial_point
            )[0],
            self,
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `QuadraticBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(
            f&#34;{self} resolved to {self.to_cubic_curve(last_item.end_point)}\n&#34;
        )

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.QuadraticBezierCurve.ctrl"><code class="name">var <span class="ident">ctrl</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The curve's control point.</p></div>
</dd>
<dt id="fpdf.drawing.QuadraticBezierCurve.end"><code class="name">var <span class="ident">end</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The curve's end point.</p></div>
</dd>
<dt id="fpdf.drawing.QuadraticBezierCurve.end_point"><code class="name">prop <span class="ident">end_point</span></code></dt>
<dd>
<div class="desc"><p>The end point of this path element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end_point(self):
    &#34;&#34;&#34;The end point of this path element.&#34;&#34;&#34;
    return self.end</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.QuadraticBezierCurve.to_cubic_curve"><code class="name flex">
<span>def <span class="ident">to_cubic_curve</span></span>(<span>self, start_point)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.Rectangle"><code class="flex name class">
<span>class <span class="ident">Rectangle</span></span>
<span>(</span><span>org: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>, size: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A pdf primitive rectangle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L2665-L2726" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Rectangle(NamedTuple):
    &#34;&#34;&#34;A pdf primitive rectangle.&#34;&#34;&#34;

    org: Point
    &#34;&#34;&#34;The top-left corner of the rectangle.&#34;&#34;&#34;
    size: Point
    &#34;&#34;&#34;The width and height of the rectangle.&#34;&#34;&#34;

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a `Line` back to
            the rectangle&#39;s origin.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument

        return (
            f&#34;{self.org.render()} {self.size.render()} re&#34;,
            Line(self.org),
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `Rectangle.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {rendered}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.Rectangle.org"><code class="name">var <span class="ident">org</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The top-left corner of the rectangle.</p></div>
</dd>
<dt id="fpdf.drawing.Rectangle.size"><code class="name">var <span class="ident">size</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The width and height of the rectangle.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeArc"><code class="flex name class">
<span>class <span class="ident">RelativeArc</span></span>
<span>(</span><span>radii: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>, rotation: Union[int, float, decimal.Decimal], large: bool, sweep: bool, end: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>An elliptical arc path element.</p>
<p>The arc is drawn from the end of the current path element to its specified end point
using a number of parameters to determine how it is constructed.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.arc_relative" href="#fpdf.drawing.PaintedPath.arc_relative">PaintedPath.arc_relative()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L2583-L2662" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RelativeArc(NamedTuple):
    &#34;&#34;&#34;
    An elliptical arc path element.

    The arc is drawn from the end of the current path element to its specified end point
    using a number of parameters to determine how it is constructed.

    See: `PaintedPath.arc_relative`
    &#34;&#34;&#34;

    radii: Point
    &#34;&#34;&#34;
    The x- and y-radii of the arc. If `radii.x == radii.y` the arc will be circular.
    &#34;&#34;&#34;
    rotation: Number
    &#34;&#34;&#34;The rotation of the arc&#39;s major/minor axes relative to the coordinate frame.&#34;&#34;&#34;
    large: bool
    &#34;&#34;&#34;If True, sweep the arc over an angle greater than or equal to 180 degrees.&#34;&#34;&#34;
    sweep: bool
    &#34;&#34;&#34;If True, the arc is swept in the positive angular direction.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The end point of the arc relative to the end of the previous path element.&#34;&#34;&#34;

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render(gsd_registry, style, last_item, initial_point)

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeArc.render`.
        &#34;&#34;&#34;
        # newline is intentionally missing here
        debug_stream.write(f&#34;{self} resolved to &#34;)

        return Arc(
            self.radii,
            self.rotation,
            self.large,
            self.sweep,
            last_item.end_point + self.end,
        ).render_debug(gsd_registry, style, last_item, initial_point, debug_stream, pfx)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeArc.end"><code class="name">var <span class="ident">end</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The end point of the arc relative to the end of the previous path element.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeArc.large"><code class="name">var <span class="ident">large</span> : bool</code></dt>
<dd>
<div class="desc"><p>If True, sweep the arc over an angle greater than or equal to 180 degrees.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeArc.radii"><code class="name">var <span class="ident">radii</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The x- and y-radii of the arc. If <code>radii.x == radii.y</code> the arc will be circular.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeArc.rotation"><code class="name">var <span class="ident">rotation</span> : Union[int, float, decimal.Decimal]</code></dt>
<dd>
<div class="desc"><p>The rotation of the arc's major/minor axes relative to the coordinate frame.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeArc.sweep"><code class="name">var <span class="ident">sweep</span> : bool</code></dt>
<dd>
<div class="desc"><p>If True, the arc is swept in the positive angular direction.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeBezierCurve"><code class="flex name class">
<span>class <span class="ident">RelativeBezierCurve</span></span>
<span>(</span><span>c1: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>, c2: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>, end: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A cubic Bézier curve path element whose points are specified relative to the end
point of the previous path element.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.curve_relative" href="#fpdf.drawing.PaintedPath.curve_relative">PaintedPath.curve_relative()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L2120-L2197" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RelativeBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A cubic Bézier curve path element whose points are specified relative to the end
    point of the previous path element.

    See: `PaintedPath.curve_relative`
    &#34;&#34;&#34;

    c1: Point
    &#34;&#34;&#34;
    The curve&#39;s first control point relative to the end of the previous path element.
    &#34;&#34;&#34;
    c2: Point
    &#34;&#34;&#34;
    The curve&#39;s second control point relative to the end of the previous path element.
    &#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point relative to the end of the previous path element.&#34;&#34;&#34;

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `BezierCurve`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        last_point = last_item.end_point

        c1 = last_point + self.c1
        c2 = last_point + self.c2
        end = last_point + self.end

        return (
            _render_curve(c1, c2, end),
            BezierCurve(c1=c1, c2=c2, end=end),
            initial_point,
        )

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeBezierCurve.c1"><code class="name">var <span class="ident">c1</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The curve's first control point relative to the end of the previous path element.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeBezierCurve.c2"><code class="name">var <span class="ident">c2</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The curve's second control point relative to the end of the previous path element.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeBezierCurve.end"><code class="name">var <span class="ident">end</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The curve's end point relative to the end of the previous path element.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeHorizontalLine"><code class="flex name class">
<span>class <span class="ident">RelativeHorizontalLine</span></span>
<span>(</span><span>x: Union[int, float, decimal.Decimal])</span>
</code></dt>
<dd>
<div class="desc"><p>A path line element that takes its ordinate from the end of the previous element and
computes its abscissa offset from the end of that element.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.horizontal_line_relative" href="#fpdf.drawing.PaintedPath.horizontal_line_relative">PaintedPath.horizontal_line_relative()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L1854-L1917" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RelativeHorizontalLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element that takes its ordinate from the end of the previous element and
    computes its abscissa offset from the end of that element.

    See: `PaintedPath.horizontal_line_relative`
    &#34;&#34;&#34;

    x: Number
    &#34;&#34;&#34;
    The abscissa of the horizontal line&#39;s end point relative to the abscissa of the
    previous path element.
    &#34;&#34;&#34;

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        end_point = Point(x=last_item.end_point.x + self.x, y=last_item.end_point.y)
        return _render_line(end_point), Line(end_point), initial_point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeHorizontalLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeHorizontalLine.x"><code class="name">var <span class="ident">x</span> : Union[int, float, decimal.Decimal]</code></dt>
<dd>
<div class="desc"><p>The abscissa of the horizontal line's end point relative to the abscissa of the
previous path element.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeLine"><code class="flex name class">
<span>class <span class="ident">RelativeLine</span></span>
<span>(</span><span>pt: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A path line element with an endpoint relative to the end of the previous element.</p>
<p>This draws a straight line from the end point of the previous path element to the
point specified by <code>last_item.end_point + pt</code>. The absolute coordinates of the end
point are resolved during the rendering process.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.line_relative" href="#fpdf.drawing.PaintedPath.line_relative">PaintedPath.line_relative()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L1726-L1789" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RelativeLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element with an endpoint relative to the end of the previous element.

    This draws a straight line from the end point of the previous path element to the
    point specified by `last_item.end_point + pt`. The absolute coordinates of the end
    point are resolved during the rendering process.

    See: `PaintedPath.line_relative`
    &#34;&#34;&#34;

    pt: Point
    &#34;&#34;&#34;The endpoint of the line relative to the previous path element.&#34;&#34;&#34;

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        point = last_item.end_point + self.pt
        return _render_line(point), Line(point), initial_point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeLine.pt"><code class="name">var <span class="ident">pt</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The endpoint of the line relative to the previous path element.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeMove"><code class="flex name class">
<span>class <span class="ident">RelativeMove</span></span>
<span>(</span><span>pt: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A path move element with an end point relative to the end of the previous path
element.</p>
<p>If a path has been created but not yet painted, this will create a new subpath.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.move_relative" href="#fpdf.drawing.PaintedPath.move_relative">PaintedPath.move_relative()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L1593-L1655" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RelativeMove(NamedTuple):
    &#34;&#34;&#34;
    A path move element with an end point relative to the end of the previous path
    element.

    If a path has been created but not yet painted, this will create a new subpath.

    See: `PaintedPath.move_relative`
    &#34;&#34;&#34;

    pt: Point
    &#34;&#34;&#34;The offset by which to move.&#34;&#34;&#34;

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Move`
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        point = last_item.end_point + self.pt
        return _render_move(point), Move(point), point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeMove.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeMove.pt"><code class="name">var <span class="ident">pt</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The offset by which to move.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeQuadraticBezierCurve"><code class="flex name class">
<span>class <span class="ident">RelativeQuadraticBezierCurve</span></span>
<span>(</span><span>ctrl: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>, end: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A quadratic Bézier curve path element whose points are specified relative to the end
point of the previous path element.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.quadratic_curve_relative" href="#fpdf.drawing.PaintedPath.quadratic_curve_relative">PaintedPath.quadratic_curve_relative()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L2292-L2361" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RelativeQuadraticBezierCurve(NamedTuple):
    &#34;&#34;&#34;
    A quadratic Bézier curve path element whose points are specified relative to the end
    point of the previous path element.

    See: `PaintedPath.quadratic_curve_relative`
    &#34;&#34;&#34;

    ctrl: Point
    &#34;&#34;&#34;The curve&#39;s control point relative to the end of the previous path element.&#34;&#34;&#34;
    end: Point
    &#34;&#34;&#34;The curve&#39;s end point relative to the end of the previous path element.&#34;&#34;&#34;

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `QuadraticBezierCurve`.
        &#34;&#34;&#34;
        last_point = last_item.end_point

        ctrl = last_point + self.ctrl
        end = last_point + self.end

        absolute = QuadraticBezierCurve(ctrl=ctrl, end=end)
        return absolute.render(gsd_registry, style, last_item, initial_point)

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeQuadraticBezierCurve.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(
            f&#34;{self} resolved to {resolved} &#34;
            f&#34;then to {resolved.to_cubic_curve(last_item.end_point)}\n&#34;
        )

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeQuadraticBezierCurve.ctrl"><code class="name">var <span class="ident">ctrl</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The curve's control point relative to the end of the previous path element.</p></div>
</dd>
<dt id="fpdf.drawing.RelativeQuadraticBezierCurve.end"><code class="name">var <span class="ident">end</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The curve's end point relative to the end of the previous path element.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RelativeVerticalLine"><code class="flex name class">
<span>class <span class="ident">RelativeVerticalLine</span></span>
<span>(</span><span>y: Union[int, float, decimal.Decimal])</span>
</code></dt>
<dd>
<div class="desc"><p>A path line element that takes its abscissa from the end of the previous element and
computes its ordinate offset from the end of that element.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.vertical_line_relative" href="#fpdf.drawing.PaintedPath.vertical_line_relative">PaintedPath.vertical_line_relative()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L1982-L2045" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RelativeVerticalLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element that takes its abscissa from the end of the previous element and
    computes its ordinate offset from the end of that element.

    See: `PaintedPath.vertical_line_relative`
    &#34;&#34;&#34;

    y: Number
    &#34;&#34;&#34;
    The ordinate of the vertical line&#39;s end point relative to the ordinate of the
    previous path element.
    &#34;&#34;&#34;

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        end_point = Point(x=last_item.end_point.x, y=last_item.end_point.y + self.y)
        return _render_line(end_point), Line(end_point), initial_point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RelativeVerticalLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RelativeVerticalLine.y"><code class="name">var <span class="ident">y</span> : Union[int, float, decimal.Decimal]</code></dt>
<dd>
<div class="desc"><p>The ordinate of the vertical line's end point relative to the ordinate of the
previous path element.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.RoundedRectangle"><code class="flex name class">
<span>class <span class="ident">RoundedRectangle</span></span>
<span>(</span><span>org: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>, size: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>, corner_radii: <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A rectangle with rounded corners.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.rectangle" href="#fpdf.drawing.PaintedPath.rectangle">PaintedPath.rectangle()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L2729-L2858" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class RoundedRectangle(NamedTuple):
    &#34;&#34;&#34;
    A rectangle with rounded corners.

    See: `PaintedPath.rectangle`
    &#34;&#34;&#34;

    org: Point
    &#34;&#34;&#34;The top-left corner of the rectangle.&#34;&#34;&#34;
    size: Point
    &#34;&#34;&#34;The width and height of the rectangle.&#34;&#34;&#34;
    corner_radii: Point
    &#34;&#34;&#34;The x- and y-radius of the corners.&#34;&#34;&#34;

    def _decompose(self):
        items = []

        if (self.size.x == 0) and (self.size.y == 0):
            pass
        elif (self.size.x == 0) or (self.size.y == 0):
            items.append(Move(self.org))
            items.append(Line(self.org + self.size))
            items.append(Close())
        elif (self.corner_radii.x == 0) or (self.corner_radii.y == 0):
            items.append(Rectangle(self.org, self.size))
        else:
            x, y = self.org
            w, h = self.size
            rx, ry = self.corner_radii
            sign_width = (self.size.x &gt;= 0) - (self.size.x &lt; 0)
            sign_height = (self.size.y &gt;= 0) - (self.size.y &lt; 0)

            if abs(rx) &gt; abs(w):
                rx = self.size.x

            if abs(ry) &gt; abs(h):
                ry = self.size.y

            rx = sign_width * abs(rx)
            ry = sign_height * abs(ry)
            arc_rad = Point(rx, ry)

            items.append(Move(Point(x + rx, y)))
            items.append(Line(Point(x + w - rx, y)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + w, y + ry)))
            items.append(Line(Point(x + w, y + h - ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + w - rx, y + h)))
            items.append(Line(Point(x + rx, y + h)))
            items.append(Arc(arc_rad, 0, False, True, Point(x, y + h - ry)))
            items.append(Line(Point(x, y + ry)))
            items.append(Arc(arc_rad, 0, False, True, Point(x + rx, y)))
            items.append(Close())

        return items

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is a resolved
            `Line`.
        &#34;&#34;&#34;
        components = self._decompose()

        if not components:
            return &#34;&#34;, last_item

        render_list = []
        for item in components:
            rendered, last_item, initial_point = item.render(
                gsd_registry, style, last_item, initial_point
            )
            render_list.append(rendered)

        return &#34; &#34;.join(render_list), Line(self.org), initial_point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `RoundedRectangle.render`.
        &#34;&#34;&#34;
        components = self._decompose()

        debug_stream.write(f&#34;{self} resolved to:\n&#34;)
        if not components:
            debug_stream.write(pfx + &#34; └─ nothing\n&#34;)
            return &#34;&#34;, last_item

        render_list = []
        for item in components[:-1]:
            rendered, last_item, initial_point = item.render(
                gsd_registry, style, last_item, initial_point
            )
            debug_stream.write(pfx + f&#34; ├─ {item}\n&#34;)
            render_list.append(rendered)

        rendered, last_item, initial_point = components[-1].render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(pfx + f&#34; └─ {components[-1]}\n&#34;)
        render_list.append(rendered)

        return &#34; &#34;.join(render_list), Line(self.org), initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.RoundedRectangle.corner_radii"><code class="name">var <span class="ident">corner_radii</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The x- and y-radius of the corners.</p></div>
</dd>
<dt id="fpdf.drawing.RoundedRectangle.org"><code class="name">var <span class="ident">org</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The top-left corner of the rectangle.</p></div>
</dd>
<dt id="fpdf.drawing.RoundedRectangle.size"><code class="name">var <span class="ident">size</span> : <a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></dt>
<dd>
<div class="desc"><p>The width and height of the rectangle.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.Transform"><code class="flex name class">
<span>class <span class="ident">Transform</span></span>
<span>(</span><span>a: Union[int, float, decimal.Decimal], b: Union[int, float, decimal.Decimal], c: Union[int, float, decimal.Decimal], d: Union[int, float, decimal.Decimal], e: Union[int, float, decimal.Decimal], f: Union[int, float, decimal.Decimal])</span>
</code></dt>
<dd>
<div class="desc"><p>A representation of an affine transformation matrix for 2D shapes.</p>
<p>The actual matrix is:</p>
<pre><code>                    [ a b 0 ]
[x' y' 1] = [x y 1] [ c d 0 ]
                    [ e f 1 ]
</code></pre>
<p>Complex transformation operations can be composed via a sequence of simple
transformations by performing successive matrix multiplication of the simple
transformations.</p>
<p>For example, scaling a set of points around a specific center point can be
represented by a translation-scale-translation sequence, where the first
translation translates the center to the origin, the scale transform scales the
points relative to the origin, and the second translation translates the points
back to the specified center point. Transform multiplication is performed using
python's dedicated matrix multiplication operator, <code>@</code></p>
<p>The semantics of this representation mean composed transformations are specified
left-to-right in order of application (some other systems provide transposed
representations, in which case the application order is right-to-left).</p>
<p>For example, to rotate the square <code>(1,1) (1,3) (3,3) (3,1)</code> 45 degrees clockwise
about its center point (which is <code>(2,2)</code>) , the translate-rotate-translate
process described above may be applied:</p>
<pre><code class="language-python">rotate_centered = (
    Transform.translation(-2, -2)
    @ Transform.rotation_d(45)
    @ Transform.translation(2, 2)
)
</code></pre>
<p>Instances of this class provide a chaining API, so the above transform could also be
constructed as follows:</p>
<pre><code class="language-python">rotate_centered = Transform.translation(-2, -2).rotate_d(45).translate(2, 2)
</code></pre>
<p>Or, because the particular operation of performing some transformations about a
specific point is pretty common,</p>
<pre><code class="language-python">rotate_centered = Transform.rotation_d(45).about(2, 2)
</code></pre>
<p>By convention, this class provides class method constructors following noun-ish
naming (<code>translation</code>, <code>scaling</code>, <code>rotation</code>, <code>shearing</code>) and instance method
manipulations following verb-ish naming (<code>translate</code>, <code>scale</code>, <code>rotate</code>, <code>shear</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L720-L1069" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Transform(NamedTuple):
    &#34;&#34;&#34;
    A representation of an affine transformation matrix for 2D shapes.

    The actual matrix is:

    ```
                        [ a b 0 ]
    [x&#39; y&#39; 1] = [x y 1] [ c d 0 ]
                        [ e f 1 ]
    ```

    Complex transformation operations can be composed via a sequence of simple
    transformations by performing successive matrix multiplication of the simple
    transformations.

    For example, scaling a set of points around a specific center point can be
    represented by a translation-scale-translation sequence, where the first
    translation translates the center to the origin, the scale transform scales the
    points relative to the origin, and the second translation translates the points
    back to the specified center point. Transform multiplication is performed using
    python&#39;s dedicated matrix multiplication operator, `@`

    The semantics of this representation mean composed transformations are specified
    left-to-right in order of application (some other systems provide transposed
    representations, in which case the application order is right-to-left).

    For example, to rotate the square `(1,1) (1,3) (3,3) (3,1)` 45 degrees clockwise
    about its center point (which is `(2,2)`) , the translate-rotate-translate
    process described above may be applied:

    ```python
    rotate_centered = (
        Transform.translation(-2, -2)
        @ Transform.rotation_d(45)
        @ Transform.translation(2, 2)
    )
    ```

    Instances of this class provide a chaining API, so the above transform could also be
    constructed as follows:

    ```python
    rotate_centered = Transform.translation(-2, -2).rotate_d(45).translate(2, 2)
    ```

    Or, because the particular operation of performing some transformations about a
    specific point is pretty common,

    ```python
    rotate_centered = Transform.rotation_d(45).about(2, 2)
    ```

    By convention, this class provides class method constructors following noun-ish
    naming (`translation`, `scaling`, `rotation`, `shearing`) and instance method
    manipulations following verb-ish naming (`translate`, `scale`, `rotate`, `shear`).
    &#34;&#34;&#34;

    a: Number
    b: Number
    c: Number
    d: Number
    e: Number
    f: Number

    # compact representation of an affine transformation matrix for 2D shapes.
    # The actual matrix is:
    #                     [ A B 0 ]
    # [x&#39; y&#39; 1] = [x y 1] [ C D 0 ]
    #                     [ E F 1 ]
    # The identity transform is 1 0 0 1 0 0

    @classmethod
    def identity(cls):
        &#34;&#34;&#34;
        Create a transform representing the identity transform.

        The identity transform is a no-op.
        &#34;&#34;&#34;
        return cls(1, 0, 0, 1, 0, 0)

    @classmethod
    def translation(cls, x, y):
        &#34;&#34;&#34;
        Create a transform that performs translation.

        Args:
            x (Number): distance to translate points along the x (horizontal) axis.
            y (Number): distance to translate points along the y (vertical) axis.

        Returns:
            A Transform representing the specified translation.
        &#34;&#34;&#34;

        return cls(1, 0, 0, 1, x, y)

    @classmethod
    def scaling(cls, x, y=None):
        &#34;&#34;&#34;
        Create a transform that performs scaling.

        Args:
            x (Number): scaling ratio in the x (horizontal) axis. A value of 1
                results in no scale change in the x axis.
            y (Number): optional scaling ratio in the y (vertical) axis. A value of 1
                results in no scale change in the y axis. If this value is omitted, it
                defaults to the value provided to the `x` argument.

        Returns:
            A Transform representing the specified scaling.
        &#34;&#34;&#34;
        if y is None:
            y = x

        return cls(x, 0, 0, y, 0, 0)

    @classmethod
    def rotation(cls, theta):
        &#34;&#34;&#34;
        Create a transform that performs rotation.

        Args:
            theta (Number): the angle **in radians** by which to rotate. Positive
                values represent clockwise rotations.

        Returns:
            A Transform representing the specified rotation.

        &#34;&#34;&#34;
        return cls(
            math.cos(theta), math.sin(theta), -math.sin(theta), math.cos(theta), 0, 0
        )

    @classmethod
    def rotation_d(cls, theta_d):
        &#34;&#34;&#34;
        Create a transform that performs rotation **in degrees**.

        Args:
            theta_d (Number): the angle **in degrees** by which to rotate. Positive
                values represent clockwise rotations.

        Returns:
            A Transform representing the specified rotation.

        &#34;&#34;&#34;
        return cls.rotation(math.radians(theta_d))

    @classmethod
    def shearing(cls, x, y=None):
        &#34;&#34;&#34;
        Create a transform that performs shearing (not of sheep).

        Args:
            x (Number): The amount to shear along the x (horizontal) axis.
            y (Number): Optional amount to shear along the y (vertical) axis. If omitted,
                this defaults to the value provided to the `x` argument.

        Returns:
            A Transform representing the specified shearing.

        &#34;&#34;&#34;
        if y is None:
            y = x
        return cls(1, y, x, 1, 0, 0)

    def translate(self, x, y):
        &#34;&#34;&#34;
        Produce a transform by composing the current transform with a translation.

        .. note::
            Transforms are immutable, so this returns a new transform rather than
            mutating self.

        Args:
            x (Number): distance to translate points along the x (horizontal) axis.
            y (Number): distance to translate points along the y (vertical) axis.

        Returns:
            A Transform representing the composed transform.
        &#34;&#34;&#34;
        return self @ Transform.translation(x, y)

    def scale(self, x, y=None):
        &#34;&#34;&#34;
        Produce a transform by composing the current transform with a scaling.

        .. note::
            Transforms are immutable, so this returns a new transform rather than
            mutating self.

        Args:
            x (Number): scaling ratio in the x (horizontal) axis. A value of 1
                results in no scale change in the x axis.
            y (Number): optional scaling ratio in the y (vertical) axis. A value of 1
                results in no scale change in the y axis. If this value is omitted, it
                defaults to the value provided to the `x` argument.

        Returns:
            A Transform representing the composed transform.
        &#34;&#34;&#34;
        return self @ Transform.scaling(x, y)

    def rotate(self, theta):
        &#34;&#34;&#34;
        Produce a transform by composing the current transform with a rotation.

        .. note::
            Transforms are immutable, so this returns a new transform rather than
            mutating self.

        Args:
            theta (Number): the angle **in radians** by which to rotate. Positive
                values represent clockwise rotations.

        Returns:
            A Transform representing the composed transform.
        &#34;&#34;&#34;
        return self @ Transform.rotation(theta)

    def rotate_d(self, theta_d):
        &#34;&#34;&#34;
        Produce a transform by composing the current transform with a rotation
        **in degrees**.

        .. note::
            Transforms are immutable, so this returns a new transform rather than
            mutating self.

        Args:
            theta_d (Number): the angle **in degrees** by which to rotate. Positive
                values represent clockwise rotations.

        Returns:
            A Transform representing the composed transform.
        &#34;&#34;&#34;
        return self @ Transform.rotation_d(theta_d)

    def shear(self, x, y=None):
        &#34;&#34;&#34;
        Produce a transform by composing the current transform with a shearing.

        .. note::
            Transforms are immutable, so this returns a new transform rather than
            mutating self.

        Args:
            x (Number): The amount to shear along the x (horizontal) axis.
            y (Number): Optional amount to shear along the y (vertical) axis. If omitted,
                this defaults to the value provided to the `x` argument.

        Returns:
            A Transform representing the composed transform.
        &#34;&#34;&#34;
        return self @ Transform.shearing(x, y)

    def about(self, x, y):
        &#34;&#34;&#34;
        Bracket the given transform in a pair of translations to make it appear about a
        point that isn&#39;t the origin.

        This is a useful shorthand for performing a transform like a rotation around the
        center point of an object that isn&#39;t centered at the origin.

        .. note::
            Transforms are immutable, so this returns a new transform rather than
            mutating self.

        Args:
            x (Number): the point along the x (horizontal) axis about which to transform.
            y (Number): the point along the y (vertical) axis about which to transform.

        Returns:
            A Transform representing the composed transform.
        &#34;&#34;&#34;
        return Transform.translation(-x, -y) @ self @ Transform.translation(x, y)

    @force_document
    def __mul__(self, other):
        &#34;&#34;&#34;
        Multiply the individual transform parameters by a scalar value.

        Args:
            other (Number): the scalar value by which to multiply the parameters

        Returns:
            A Transform with the modified parameters.
        &#34;&#34;&#34;
        if isinstance(other, NumberClass):
            return Transform(
                a=self.a * other,
                b=self.b * other,
                c=self.c * other,
                d=self.d * other,
                e=self.e * other,
                f=self.f * other,
            )

        return NotImplemented

    # scalar multiplication is commutative
    __rmul__ = __mul__

    @force_document
    def __matmul__(self, other):
        &#34;&#34;&#34;
        Compose two transforms into a single transform.

        Args:
            other (Transform): the right-hand side transform of the infix operator.

        Returns:
            A Transform representing the composed transform.
        &#34;&#34;&#34;
        if isinstance(other, Transform):
            return self.__class__(
                a=self.a * other.a + self.b * other.c,
                b=self.a * other.b + self.b * other.d,
                c=self.c * other.a + self.d * other.c,
                d=self.c * other.b + self.d * other.d,
                e=self.e * other.a + self.f * other.c + other.e,
                f=self.e * other.b + self.f * other.d + other.f,
            )

        return NotImplemented

    def render(self, last_item):
        &#34;&#34;&#34;
        Render the transform to its PDF output representation.

        Args:
            last_item: the last path element this transform applies to

        Returns:
            A tuple of `(str, last_item)`. `last_item` is returned unchanged.
        &#34;&#34;&#34;
        return (
            f&#34;{number_to_str(self.a)} {number_to_str(self.b)} &#34;
            f&#34;{number_to_str(self.c)} {number_to_str(self.d)} &#34;
            f&#34;{number_to_str(self.e)} {number_to_str(self.f)} cm&#34;,
            last_item,
        )

    def __str__(self):
        return (
            f&#34;transform: [&#34;
            f&#34;{number_to_str(self.a)} {number_to_str(self.b)} 0; &#34;
            f&#34;{number_to_str(self.c)} {number_to_str(self.d)} 0; &#34;
            f&#34;{number_to_str(self.e)} {number_to_str(self.f)} 1]&#34;
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.drawing.Transform.identity"><code class="name flex">
<span>def <span class="ident">identity</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a transform representing the identity transform.</p>
<p>The identity transform is a no-op.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.rotation"><code class="name flex">
<span>def <span class="ident">rotation</span></span>(<span>theta)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a transform that performs rotation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>Number</code></dt>
<dd>the angle <strong>in radians</strong> by which to rotate. Positive
values represent clockwise rotations.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform representing the specified rotation.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.rotation_d"><code class="name flex">
<span>def <span class="ident">rotation_d</span></span>(<span>theta_d)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a transform that performs rotation <strong>in degrees</strong>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>theta_d</code></strong> :&ensp;<code>Number</code></dt>
<dd>the angle <strong>in degrees</strong> by which to rotate. Positive
values represent clockwise rotations.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform representing the specified rotation.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.scaling"><code class="name flex">
<span>def <span class="ident">scaling</span></span>(<span>x, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a transform that performs scaling.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>scaling ratio in the x (horizontal) axis. A value of 1
results in no scale change in the x axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>optional scaling ratio in the y (vertical) axis. A value of 1
results in no scale change in the y axis. If this value is omitted, it
defaults to the value provided to the <code>x</code> argument.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform representing the specified scaling.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.shearing"><code class="name flex">
<span>def <span class="ident">shearing</span></span>(<span>x, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a transform that performs shearing (not of sheep).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>The amount to shear along the x (horizontal) axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>Optional amount to shear along the y (vertical) axis. If omitted,
this defaults to the value provided to the <code>x</code> argument.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform representing the specified shearing.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.translation"><code class="name flex">
<span>def <span class="ident">translation</span></span>(<span>x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a transform that performs translation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>distance to translate points along the x (horizontal) axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>distance to translate points along the y (vertical) axis.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform representing the specified translation.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.drawing.Transform.__matmul__"><code class="name flex">
<span>def <span class="ident">__matmul__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compose two transforms into a single transform.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="fpdf.drawing.Transform" href="#fpdf.drawing.Transform">Transform</a></code></dt>
<dd>the right-hand side transform of the infix operator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform representing the composed transform.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.__mul__"><code class="name flex">
<span>def <span class="ident">__mul__</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply the individual transform parameters by a scalar value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>Number</code></dt>
<dd>the scalar value by which to multiply the parameters</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform with the modified parameters.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.about"><code class="name flex">
<span>def <span class="ident">about</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Bracket the given transform in a pair of translations to make it appear about a
point that isn't the origin.</p>
<p>This is a useful shorthand for performing a transform like a rotation around the
center point of an object that isn't centered at the origin.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Transforms are immutable, so this returns a new transform rather than
mutating self.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>the point along the x (horizontal) axis about which to transform.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>the point along the y (vertical) axis about which to transform.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform representing the composed transform.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, last_item)</span>
</code></dt>
<dd>
<div class="desc"><p>Render the transform to its PDF output representation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>last_item</code></strong></dt>
<dd>the last path element this transform applies to</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of <code>(str, last_item)</code>. <code>last_item</code> is returned unchanged.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.rotate"><code class="name flex">
<span>def <span class="ident">rotate</span></span>(<span>self, theta)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a transform by composing the current transform with a rotation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Transforms are immutable, so this returns a new transform rather than
mutating self.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>theta</code></strong> :&ensp;<code>Number</code></dt>
<dd>the angle <strong>in radians</strong> by which to rotate. Positive
values represent clockwise rotations.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform representing the composed transform.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.rotate_d"><code class="name flex">
<span>def <span class="ident">rotate_d</span></span>(<span>self, theta_d)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a transform by composing the current transform with a rotation
<strong>in degrees</strong>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Transforms are immutable, so this returns a new transform rather than
mutating self.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>theta_d</code></strong> :&ensp;<code>Number</code></dt>
<dd>the angle <strong>in degrees</strong> by which to rotate. Positive
values represent clockwise rotations.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform representing the composed transform.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, x, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a transform by composing the current transform with a scaling.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Transforms are immutable, so this returns a new transform rather than
mutating self.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>scaling ratio in the x (horizontal) axis. A value of 1
results in no scale change in the x axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>optional scaling ratio in the y (vertical) axis. A value of 1
results in no scale change in the y axis. If this value is omitted, it
defaults to the value provided to the <code>x</code> argument.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform representing the composed transform.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.shear"><code class="name flex">
<span>def <span class="ident">shear</span></span>(<span>self, x, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a transform by composing the current transform with a shearing.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Transforms are immutable, so this returns a new transform rather than
mutating self.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>The amount to shear along the x (horizontal) axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>Optional amount to shear along the y (vertical) axis. If omitted,
this defaults to the value provided to the <code>x</code> argument.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform representing the composed transform.</p></div>
</dd>
<dt id="fpdf.drawing.Transform.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce a transform by composing the current transform with a translation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Transforms are immutable, so this returns a new transform rather than
mutating self.</p>
</div>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>distance to translate points along the x (horizontal) axis.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>distance to translate points along the y (vertical) axis.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A Transform representing the composed transform.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.drawing.VerticalLine"><code class="flex name class">
<span>class <span class="ident">VerticalLine</span></span>
<span>(</span><span>y: Union[int, float, decimal.Decimal])</span>
</code></dt>
<dd>
<div class="desc"><p>A path line element that takes its abscissa from the end of the previous element.</p>
<p>See: <code><a title="fpdf.drawing.PaintedPath.vertical_line_to" href="#fpdf.drawing.PaintedPath.vertical_line_to">PaintedPath.vertical_line_to()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/drawing.py#L1920-L1979" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VerticalLine(NamedTuple):
    &#34;&#34;&#34;
    A path line element that takes its abscissa from the end of the previous element.

    See: `PaintedPath.vertical_line_to`
    &#34;&#34;&#34;

    y: Number
    &#34;&#34;&#34;The ordinate of the vertical line&#39;s end point.&#34;&#34;&#34;

    @force_nodocument
    def render(self, gsd_registry, style, last_item, initial_point):
        &#34;&#34;&#34;
        Render this path element to its PDF representation.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command

        Returns:
            a tuple of `(str, new_last_item)`, where `new_last_item` is the resolved
            `Line`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        end_point = Point(x=last_item.end_point.x, y=self.y)
        return _render_line(end_point), Line(end_point), initial_point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, pfx
    ):
        &#34;&#34;&#34;
        Render this path element to its PDF representation and produce debug
        information.

        Args:
            gsd_registry (GraphicsStateDictRegistry): the owner&#39;s graphics state
                dictionary registry.
            style (GraphicsStyle): the current resolved graphics style
            last_item: the previous path element.
            initial_point: last position set by a &#34;M&#34; or &#34;m&#34; command
            debug_stream (io.TextIO): the stream to which the debug output should be
                written. This is not guaranteed to be seekable (e.g. it may be stdout or
                stderr).
            pfx (str): the current debug output prefix string (only needed if emitting
                more than one line).

        Returns:
            The same tuple as `VerticalLine.render`.
        &#34;&#34;&#34;
        # pylint: disable=unused-argument
        rendered, resolved, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self} resolved to {resolved}\n&#34;)

        return rendered, resolved, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.drawing.VerticalLine.y"><code class="name">var <span class="ident">y</span> : Union[int, float, decimal.Decimal]</code></dt>
<dd>
<div class="desc"><p>The ordinate of the vertical line's end point.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="fpdf.drawing.DELIMITERS" href="#fpdf.drawing.DELIMITERS">DELIMITERS</a></code></li>
<li><code><a title="fpdf.drawing.EOL_CHARS" href="#fpdf.drawing.EOL_CHARS">EOL_CHARS</a></code></li>
<li><code><a title="fpdf.drawing.WHITESPACE" href="#fpdf.drawing.WHITESPACE">WHITESPACE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fpdf.drawing.cmyk8" href="#fpdf.drawing.cmyk8">cmyk8</a></code></li>
<li><code><a title="fpdf.drawing.color_from_hex_string" href="#fpdf.drawing.color_from_hex_string">color_from_hex_string</a></code></li>
<li><code><a title="fpdf.drawing.color_from_rgb_string" href="#fpdf.drawing.color_from_rgb_string">color_from_rgb_string</a></code></li>
<li><code><a title="fpdf.drawing.convert_to_device_color" href="#fpdf.drawing.convert_to_device_color">convert_to_device_color</a></code></li>
<li><code><a title="fpdf.drawing.gray8" href="#fpdf.drawing.gray8">gray8</a></code></li>
<li><code><a title="fpdf.drawing.number_to_str" href="#fpdf.drawing.number_to_str">number_to_str</a></code></li>
<li><code><a title="fpdf.drawing.render_pdf_primitive" href="#fpdf.drawing.render_pdf_primitive">render_pdf_primitive</a></code></li>
<li><code><a title="fpdf.drawing.rgb8" href="#fpdf.drawing.rgb8">rgb8</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.drawing.Arc" href="#fpdf.drawing.Arc">Arc</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.Arc.end" href="#fpdf.drawing.Arc.end">end</a></code></li>
<li><code><a title="fpdf.drawing.Arc.large" href="#fpdf.drawing.Arc.large">large</a></code></li>
<li><code><a title="fpdf.drawing.Arc.radii" href="#fpdf.drawing.Arc.radii">radii</a></code></li>
<li><code><a title="fpdf.drawing.Arc.rotation" href="#fpdf.drawing.Arc.rotation">rotation</a></code></li>
<li><code><a title="fpdf.drawing.Arc.sweep" href="#fpdf.drawing.Arc.sweep">sweep</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.BezierCurve" href="#fpdf.drawing.BezierCurve">BezierCurve</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.BezierCurve.c1" href="#fpdf.drawing.BezierCurve.c1">c1</a></code></li>
<li><code><a title="fpdf.drawing.BezierCurve.c2" href="#fpdf.drawing.BezierCurve.c2">c2</a></code></li>
<li><code><a title="fpdf.drawing.BezierCurve.end" href="#fpdf.drawing.BezierCurve.end">end</a></code></li>
<li><code><a title="fpdf.drawing.BezierCurve.end_point" href="#fpdf.drawing.BezierCurve.end_point">end_point</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.ClippingPath" href="#fpdf.drawing.ClippingPath">ClippingPath</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.ClippingPath.render" href="#fpdf.drawing.ClippingPath.render">render</a></code></li>
<li><code><a title="fpdf.drawing.ClippingPath.render_debug" href="#fpdf.drawing.ClippingPath.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Close" href="#fpdf.drawing.Close">Close</a></code></h4>
</li>
<li>
<h4><code><a title="fpdf.drawing.DeviceCMYK" href="#fpdf.drawing.DeviceCMYK">DeviceCMYK</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.DeviceCMYK.colors" href="#fpdf.drawing.DeviceCMYK.colors">colors</a></code></li>
<li><code><a title="fpdf.drawing.DeviceCMYK.serialize" href="#fpdf.drawing.DeviceCMYK.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.DeviceGray" href="#fpdf.drawing.DeviceGray">DeviceGray</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.DeviceGray.colors" href="#fpdf.drawing.DeviceGray.colors">colors</a></code></li>
<li><code><a title="fpdf.drawing.DeviceGray.colors255" href="#fpdf.drawing.DeviceGray.colors255">colors255</a></code></li>
<li><code><a title="fpdf.drawing.DeviceGray.serialize" href="#fpdf.drawing.DeviceGray.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.DeviceRGB" href="#fpdf.drawing.DeviceRGB">DeviceRGB</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.DeviceRGB.colors" href="#fpdf.drawing.DeviceRGB.colors">colors</a></code></li>
<li><code><a title="fpdf.drawing.DeviceRGB.colors255" href="#fpdf.drawing.DeviceRGB.colors255">colors255</a></code></li>
<li><code><a title="fpdf.drawing.DeviceRGB.serialize" href="#fpdf.drawing.DeviceRGB.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.DrawingContext" href="#fpdf.drawing.DrawingContext">DrawingContext</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.DrawingContext.add_item" href="#fpdf.drawing.DrawingContext.add_item">add_item</a></code></li>
<li><code><a title="fpdf.drawing.DrawingContext.render" href="#fpdf.drawing.DrawingContext.render">render</a></code></li>
<li><code><a title="fpdf.drawing.DrawingContext.render_debug" href="#fpdf.drawing.DrawingContext.render_debug">render_debug</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Ellipse" href="#fpdf.drawing.Ellipse">Ellipse</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.Ellipse.center" href="#fpdf.drawing.Ellipse.center">center</a></code></li>
<li><code><a title="fpdf.drawing.Ellipse.radii" href="#fpdf.drawing.Ellipse.radii">radii</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.GraphicsContext" href="#fpdf.drawing.GraphicsContext">GraphicsContext</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.GraphicsContext.add_item" href="#fpdf.drawing.GraphicsContext.add_item">add_item</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.clipping_path" href="#fpdf.drawing.GraphicsContext.clipping_path">clipping_path</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.merge" href="#fpdf.drawing.GraphicsContext.merge">merge</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.remove_last_item" href="#fpdf.drawing.GraphicsContext.remove_last_item">remove_last_item</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.render" href="#fpdf.drawing.GraphicsContext.render">render</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.render_debug" href="#fpdf.drawing.GraphicsContext.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsContext.transform" href="#fpdf.drawing.GraphicsContext.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.GraphicsStateDictRegistry" href="#fpdf.drawing.GraphicsStateDictRegistry">GraphicsStateDictRegistry</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.GraphicsStateDictRegistry.register_style" href="#fpdf.drawing.GraphicsStateDictRegistry.register_style">register_style</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.GraphicsStyle" href="#fpdf.drawing.GraphicsStyle">GraphicsStyle</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.GraphicsStyle.INHERIT" href="#fpdf.drawing.GraphicsStyle.INHERIT">INHERIT</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.MERGE_PROPERTIES" href="#fpdf.drawing.GraphicsStyle.MERGE_PROPERTIES">MERGE_PROPERTIES</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.PDF_STYLE_KEYS" href="#fpdf.drawing.GraphicsStyle.PDF_STYLE_KEYS">PDF_STYLE_KEYS</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.TRANSPARENCY_KEYS" href="#fpdf.drawing.GraphicsStyle.TRANSPARENCY_KEYS">TRANSPARENCY_KEYS</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.allow_transparency" href="#fpdf.drawing.GraphicsStyle.allow_transparency">allow_transparency</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.auto_close" href="#fpdf.drawing.GraphicsStyle.auto_close">auto_close</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.blend_mode" href="#fpdf.drawing.GraphicsStyle.blend_mode">blend_mode</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.fill_color" href="#fpdf.drawing.GraphicsStyle.fill_color">fill_color</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.fill_opacity" href="#fpdf.drawing.GraphicsStyle.fill_opacity">fill_opacity</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.intersection_rule" href="#fpdf.drawing.GraphicsStyle.intersection_rule">intersection_rule</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.merge" href="#fpdf.drawing.GraphicsStyle.merge">merge</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.paint_rule" href="#fpdf.drawing.GraphicsStyle.paint_rule">paint_rule</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.serialize" href="#fpdf.drawing.GraphicsStyle.serialize">serialize</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_cap_style" href="#fpdf.drawing.GraphicsStyle.stroke_cap_style">stroke_cap_style</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_color" href="#fpdf.drawing.GraphicsStyle.stroke_color">stroke_color</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_dash_pattern" href="#fpdf.drawing.GraphicsStyle.stroke_dash_pattern">stroke_dash_pattern</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_dash_phase" href="#fpdf.drawing.GraphicsStyle.stroke_dash_phase">stroke_dash_phase</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_join_style" href="#fpdf.drawing.GraphicsStyle.stroke_join_style">stroke_join_style</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_miter_limit" href="#fpdf.drawing.GraphicsStyle.stroke_miter_limit">stroke_miter_limit</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_opacity" href="#fpdf.drawing.GraphicsStyle.stroke_opacity">stroke_opacity</a></code></li>
<li><code><a title="fpdf.drawing.GraphicsStyle.stroke_width" href="#fpdf.drawing.GraphicsStyle.stroke_width">stroke_width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.HorizontalLine" href="#fpdf.drawing.HorizontalLine">HorizontalLine</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.HorizontalLine.x" href="#fpdf.drawing.HorizontalLine.x">x</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.ImplicitClose" href="#fpdf.drawing.ImplicitClose">ImplicitClose</a></code></h4>
</li>
<li>
<h4><code><a title="fpdf.drawing.Line" href="#fpdf.drawing.Line">Line</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.Line.end_point" href="#fpdf.drawing.Line.end_point">end_point</a></code></li>
<li><code><a title="fpdf.drawing.Line.pt" href="#fpdf.drawing.Line.pt">pt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Move" href="#fpdf.drawing.Move">Move</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.Move.end_point" href="#fpdf.drawing.Move.end_point">end_point</a></code></li>
<li><code><a title="fpdf.drawing.Move.pt" href="#fpdf.drawing.Move.pt">pt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.PaintedPath" href="#fpdf.drawing.PaintedPath">PaintedPath</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.PaintedPath.add_path_element" href="#fpdf.drawing.PaintedPath.add_path_element">add_path_element</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.arc_relative" href="#fpdf.drawing.PaintedPath.arc_relative">arc_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.arc_to" href="#fpdf.drawing.PaintedPath.arc_to">arc_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.auto_close" href="#fpdf.drawing.PaintedPath.auto_close">auto_close</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.circle" href="#fpdf.drawing.PaintedPath.circle">circle</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.clipping_path" href="#fpdf.drawing.PaintedPath.clipping_path">clipping_path</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.close" href="#fpdf.drawing.PaintedPath.close">close</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.curve_relative" href="#fpdf.drawing.PaintedPath.curve_relative">curve_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.curve_to" href="#fpdf.drawing.PaintedPath.curve_to">curve_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.ellipse" href="#fpdf.drawing.PaintedPath.ellipse">ellipse</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.horizontal_line_relative" href="#fpdf.drawing.PaintedPath.horizontal_line_relative">horizontal_line_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.horizontal_line_to" href="#fpdf.drawing.PaintedPath.horizontal_line_to">horizontal_line_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.line_relative" href="#fpdf.drawing.PaintedPath.line_relative">line_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.line_to" href="#fpdf.drawing.PaintedPath.line_to">line_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.move_relative" href="#fpdf.drawing.PaintedPath.move_relative">move_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.move_to" href="#fpdf.drawing.PaintedPath.move_to">move_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.paint_rule" href="#fpdf.drawing.PaintedPath.paint_rule">paint_rule</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.quadratic_curve_relative" href="#fpdf.drawing.PaintedPath.quadratic_curve_relative">quadratic_curve_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.quadratic_curve_to" href="#fpdf.drawing.PaintedPath.quadratic_curve_to">quadratic_curve_to</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.rectangle" href="#fpdf.drawing.PaintedPath.rectangle">rectangle</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.remove_last_path_element" href="#fpdf.drawing.PaintedPath.remove_last_path_element">remove_last_path_element</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.render" href="#fpdf.drawing.PaintedPath.render">render</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.render_debug" href="#fpdf.drawing.PaintedPath.render_debug">render_debug</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.style" href="#fpdf.drawing.PaintedPath.style">style</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.transform" href="#fpdf.drawing.PaintedPath.transform">transform</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.transform_group" href="#fpdf.drawing.PaintedPath.transform_group">transform_group</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.vertical_line_relative" href="#fpdf.drawing.PaintedPath.vertical_line_relative">vertical_line_relative</a></code></li>
<li><code><a title="fpdf.drawing.PaintedPath.vertical_line_to" href="#fpdf.drawing.PaintedPath.vertical_line_to">vertical_line_to</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Point" href="#fpdf.drawing.Point">Point</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.Point.__add__" href="#fpdf.drawing.Point.__add__">__add__</a></code></li>
<li><code><a title="fpdf.drawing.Point.__floordiv__" href="#fpdf.drawing.Point.__floordiv__">__floordiv__</a></code></li>
<li><code><a title="fpdf.drawing.Point.__matmul__" href="#fpdf.drawing.Point.__matmul__">__matmul__</a></code></li>
<li><code><a title="fpdf.drawing.Point.__mul__" href="#fpdf.drawing.Point.__mul__">__mul__</a></code></li>
<li><code><a title="fpdf.drawing.Point.__neg__" href="#fpdf.drawing.Point.__neg__">__neg__</a></code></li>
<li><code><a title="fpdf.drawing.Point.__sub__" href="#fpdf.drawing.Point.__sub__">__sub__</a></code></li>
<li><code><a title="fpdf.drawing.Point.__truediv__" href="#fpdf.drawing.Point.__truediv__">__truediv__</a></code></li>
<li><code><a title="fpdf.drawing.Point.angle" href="#fpdf.drawing.Point.angle">angle</a></code></li>
<li><code><a title="fpdf.drawing.Point.dot" href="#fpdf.drawing.Point.dot">dot</a></code></li>
<li><code><a title="fpdf.drawing.Point.mag" href="#fpdf.drawing.Point.mag">mag</a></code></li>
<li><code><a title="fpdf.drawing.Point.render" href="#fpdf.drawing.Point.render">render</a></code></li>
<li><code><a title="fpdf.drawing.Point.x" href="#fpdf.drawing.Point.x">x</a></code></li>
<li><code><a title="fpdf.drawing.Point.y" href="#fpdf.drawing.Point.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.QuadraticBezierCurve" href="#fpdf.drawing.QuadraticBezierCurve">QuadraticBezierCurve</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.QuadraticBezierCurve.ctrl" href="#fpdf.drawing.QuadraticBezierCurve.ctrl">ctrl</a></code></li>
<li><code><a title="fpdf.drawing.QuadraticBezierCurve.end" href="#fpdf.drawing.QuadraticBezierCurve.end">end</a></code></li>
<li><code><a title="fpdf.drawing.QuadraticBezierCurve.end_point" href="#fpdf.drawing.QuadraticBezierCurve.end_point">end_point</a></code></li>
<li><code><a title="fpdf.drawing.QuadraticBezierCurve.to_cubic_curve" href="#fpdf.drawing.QuadraticBezierCurve.to_cubic_curve">to_cubic_curve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Rectangle" href="#fpdf.drawing.Rectangle">Rectangle</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.Rectangle.org" href="#fpdf.drawing.Rectangle.org">org</a></code></li>
<li><code><a title="fpdf.drawing.Rectangle.size" href="#fpdf.drawing.Rectangle.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeArc" href="#fpdf.drawing.RelativeArc">RelativeArc</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RelativeArc.end" href="#fpdf.drawing.RelativeArc.end">end</a></code></li>
<li><code><a title="fpdf.drawing.RelativeArc.large" href="#fpdf.drawing.RelativeArc.large">large</a></code></li>
<li><code><a title="fpdf.drawing.RelativeArc.radii" href="#fpdf.drawing.RelativeArc.radii">radii</a></code></li>
<li><code><a title="fpdf.drawing.RelativeArc.rotation" href="#fpdf.drawing.RelativeArc.rotation">rotation</a></code></li>
<li><code><a title="fpdf.drawing.RelativeArc.sweep" href="#fpdf.drawing.RelativeArc.sweep">sweep</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeBezierCurve" href="#fpdf.drawing.RelativeBezierCurve">RelativeBezierCurve</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RelativeBezierCurve.c1" href="#fpdf.drawing.RelativeBezierCurve.c1">c1</a></code></li>
<li><code><a title="fpdf.drawing.RelativeBezierCurve.c2" href="#fpdf.drawing.RelativeBezierCurve.c2">c2</a></code></li>
<li><code><a title="fpdf.drawing.RelativeBezierCurve.end" href="#fpdf.drawing.RelativeBezierCurve.end">end</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeHorizontalLine" href="#fpdf.drawing.RelativeHorizontalLine">RelativeHorizontalLine</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RelativeHorizontalLine.x" href="#fpdf.drawing.RelativeHorizontalLine.x">x</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeLine" href="#fpdf.drawing.RelativeLine">RelativeLine</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RelativeLine.pt" href="#fpdf.drawing.RelativeLine.pt">pt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeMove" href="#fpdf.drawing.RelativeMove">RelativeMove</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RelativeMove.pt" href="#fpdf.drawing.RelativeMove.pt">pt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeQuadraticBezierCurve" href="#fpdf.drawing.RelativeQuadraticBezierCurve">RelativeQuadraticBezierCurve</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RelativeQuadraticBezierCurve.ctrl" href="#fpdf.drawing.RelativeQuadraticBezierCurve.ctrl">ctrl</a></code></li>
<li><code><a title="fpdf.drawing.RelativeQuadraticBezierCurve.end" href="#fpdf.drawing.RelativeQuadraticBezierCurve.end">end</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RelativeVerticalLine" href="#fpdf.drawing.RelativeVerticalLine">RelativeVerticalLine</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RelativeVerticalLine.y" href="#fpdf.drawing.RelativeVerticalLine.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.RoundedRectangle" href="#fpdf.drawing.RoundedRectangle">RoundedRectangle</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.RoundedRectangle.corner_radii" href="#fpdf.drawing.RoundedRectangle.corner_radii">corner_radii</a></code></li>
<li><code><a title="fpdf.drawing.RoundedRectangle.org" href="#fpdf.drawing.RoundedRectangle.org">org</a></code></li>
<li><code><a title="fpdf.drawing.RoundedRectangle.size" href="#fpdf.drawing.RoundedRectangle.size">size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.Transform" href="#fpdf.drawing.Transform">Transform</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.drawing.Transform.__matmul__" href="#fpdf.drawing.Transform.__matmul__">__matmul__</a></code></li>
<li><code><a title="fpdf.drawing.Transform.__mul__" href="#fpdf.drawing.Transform.__mul__">__mul__</a></code></li>
<li><code><a title="fpdf.drawing.Transform.about" href="#fpdf.drawing.Transform.about">about</a></code></li>
<li><code><a title="fpdf.drawing.Transform.identity" href="#fpdf.drawing.Transform.identity">identity</a></code></li>
<li><code><a title="fpdf.drawing.Transform.render" href="#fpdf.drawing.Transform.render">render</a></code></li>
<li><code><a title="fpdf.drawing.Transform.rotate" href="#fpdf.drawing.Transform.rotate">rotate</a></code></li>
<li><code><a title="fpdf.drawing.Transform.rotate_d" href="#fpdf.drawing.Transform.rotate_d">rotate_d</a></code></li>
<li><code><a title="fpdf.drawing.Transform.rotation" href="#fpdf.drawing.Transform.rotation">rotation</a></code></li>
<li><code><a title="fpdf.drawing.Transform.rotation_d" href="#fpdf.drawing.Transform.rotation_d">rotation_d</a></code></li>
<li><code><a title="fpdf.drawing.Transform.scale" href="#fpdf.drawing.Transform.scale">scale</a></code></li>
<li><code><a title="fpdf.drawing.Transform.scaling" href="#fpdf.drawing.Transform.scaling">scaling</a></code></li>
<li><code><a title="fpdf.drawing.Transform.shear" href="#fpdf.drawing.Transform.shear">shear</a></code></li>
<li><code><a title="fpdf.drawing.Transform.shearing" href="#fpdf.drawing.Transform.shearing">shearing</a></code></li>
<li><code><a title="fpdf.drawing.Transform.translate" href="#fpdf.drawing.Transform.translate">translate</a></code></li>
<li><code><a title="fpdf.drawing.Transform.translation" href="#fpdf.drawing.Transform.translation">translation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.drawing.VerticalLine" href="#fpdf.drawing.VerticalLine">VerticalLine</a></code></h4>
<ul class="">
<li><code><a title="fpdf.drawing.VerticalLine.y" href="#fpdf.drawing.VerticalLine.y">y</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
