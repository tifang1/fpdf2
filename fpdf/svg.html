<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>fpdf.svg API documentation</title>
<meta name="description" content="Utilities to parse SVG graphics into fpdf.drawing objects …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.svg</code></h1>
</header>
<section id="section-intro">
<p>Utilities to parse SVG graphics into fpdf.drawing objects.</p>
<p>The contents of this module are internal to fpdf2, and not part of the public API.
They may change at any time without prior warning or any deprecation period,
in non-backward-compatible ways.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.svg.PathPen"><code class="flex name class">
<span>class <span class="ident">PathPen</span></span>
<span>(</span><span>pdf_path, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for drawing pens. You must override _moveTo, _lineTo and
_curveToOne. You may additionally override _closePath, _endPath,
addComponent, addVarComponent, and/or _qCurveToOne. You should not
override any other methods.</p>
<p>Takes a 'glyphSet' argument (dict), in which the glyphs that are referenced
as components are looked up by their name.</p>
<p>If the optional 'reverseFlipped' argument is True, components whose transformation
matrix has a negative determinant will be decomposed with a reversed path direction
to compensate for the flip.</p>
<p>The optional 'skipMissingComponents' argument can be set to True/False to
override the homonymous class attribute for a given pen instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/svg.py#L554-L606" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PathPen(BasePen):
    def __init__(self, pdf_path, *args, **kwargs):
        self.pdf_path = pdf_path
        self.last_was_line_to = False
        self.first_is_move = None
        super().__init__(*args, **kwargs)

    def _moveTo(self, pt):
        self.pdf_path.move_to(*pt)
        self.last_was_line_to = False
        if self.first_is_move is None:
            self.first_is_move = True

    def _lineTo(self, pt):
        self.pdf_path.line_to(*pt)
        self.last_was_line_to = True
        if self.first_is_move is None:
            self.first_is_move = False

    def _curveToOne(self, pt1, pt2, pt3):
        self.pdf_path.curve_to(
            x1=pt1[0], y1=pt1[1], x2=pt2[0], y2=pt2[1], x3=pt3[0], y3=pt3[1]
        )
        self.last_was_line_to = False
        if self.first_is_move is None:
            self.first_is_move = False

    def _qCurveToOne(self, pt1, pt2):
        self.pdf_path.quadratic_curve_to(x1=pt1[0], y1=pt1[1], x2=pt2[0], y2=pt2[1])
        self.last_was_line_to = False
        if self.first_is_move is None:
            self.first_is_move = False

    def arcTo(self, rx, ry, rotation, arc, sweep, end):
        self.pdf_path.arc_to(
            rx=rx,
            ry=ry,
            rotation=rotation,
            large_arc=arc,
            positive_sweep=sweep,
            x=end[0],
            y=end[1],
        )
        self.last_was_line_to = False
        if self.first_is_move is None:
            self.first_is_move = False

    def _closePath(self):
        # The fonttools parser inserts an unnecessary explicit line back to the start
        # point of the path before actually closing it. Let&#39;s get rid of that again.
        if self.last_was_line_to:
            self.pdf_path.remove_last_path_element()
        self.pdf_path.close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>fontTools.pens.basePen.BasePen</li>
<li>fontTools.pens.basePen.DecomposingPen</li>
<li>fontTools.pens.basePen.LoggingPen</li>
<li>fontTools.misc.loggingTools.LogMixin</li>
<li>fontTools.pens.basePen.AbstractPen</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.svg.PathPen.arcTo"><code class="name flex">
<span>def <span class="ident">arcTo</span></span>(<span>self, rx, ry, rotation, arc, sweep, end)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.svg.SVGImage"><code class="flex name class">
<span>class <span class="ident">SVGImage</span></span>
<span>(</span><span>href: str, x: numbers.Number, y: numbers.Number, width: numbers.Number, height: numbers.Number, svg_obj: <a title="fpdf.svg.SVGObject" href="#fpdf.svg.SVGObject">SVGObject</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>SVGImage(href, x, y, width, height, svg_obj)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/svg.py#L1023-L1079" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SVGImage(NamedTuple):
    href: str
    x: Number
    y: Number
    width: Number
    height: Number
    svg_obj: SVGObject

    def __deepcopy__(self, _memo):
        # Defining this method is required to avoid the .svg_obj reference to be cloned:
        return SVGImage(
            href=self.href,
            x=self.x,
            y=self.y,
            width=self.width,
            height=self.height,
            svg_obj=self.svg_obj,
        )

    @force_nodocument
    def render(self, _gsd_registry, _style, last_item, initial_point):
        image_cache = self.svg_obj and self.svg_obj.image_cache
        if not image_cache:
            raise AssertionError(
                &#34;fpdf2 bug - Cannot render a raster image without a SVGObject.image_cache&#34;
            )

        # We lazy-import this function to circumvent a circular import problem:
        # pylint: disable=cyclic-import,import-outside-toplevel
        from .image_parsing import preload_image

        _, _, info = preload_image(image_cache, self.href)
        if isinstance(info, VectorImageInfo):
            LOGGER.warning(
                &#34;Inserting .svg vector graphics in &lt;image&gt; tags is currently not supported (contributions are welcome to add support for it)&#34;
            )
            return &#34;&#34;, last_item, initial_point
        w, h = info.size_in_document_units(self.width, self.height)
        stream_content = stream_content_for_raster_image(
            info=info,
            x=self.x,
            y=self.y,
            w=w,
            h=h,
            keep_aspect_ratio=True,
        )
        return stream_content, last_item, initial_point

    @force_nodocument
    def render_debug(
        self, gsd_registry, style, last_item, initial_point, debug_stream, _pfx
    ):
        stream_content, last_item, initial_point = self.render(
            gsd_registry, style, last_item, initial_point
        )
        debug_stream.write(f&#34;{self.href} rendered as: {stream_content}\n&#34;)
        return stream_content, last_item, initial_point</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.svg.SVGImage.height"><code class="name">var <span class="ident">height</span> : numbers.Number</code></dt>
<dd>
<div class="desc"><p>Alias for field number 4</p></div>
</dd>
<dt id="fpdf.svg.SVGImage.href"><code class="name">var <span class="ident">href</span> : str</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="fpdf.svg.SVGImage.svg_obj"><code class="name">var <span class="ident">svg_obj</span> : <a title="fpdf.svg.SVGObject" href="#fpdf.svg.SVGObject">SVGObject</a></code></dt>
<dd>
<div class="desc"><p>Alias for field number 5</p></div>
</dd>
<dt id="fpdf.svg.SVGImage.width"><code class="name">var <span class="ident">width</span> : numbers.Number</code></dt>
<dd>
<div class="desc"><p>Alias for field number 3</p></div>
</dd>
<dt id="fpdf.svg.SVGImage.x"><code class="name">var <span class="ident">x</span> : numbers.Number</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="fpdf.svg.SVGImage.y"><code class="name">var <span class="ident">y</span> : numbers.Number</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.svg.SVGObject"><code class="flex name class">
<span>class <span class="ident">SVGObject</span></span>
<span>(</span><span>svg_text, image_cache: <a title="fpdf.image_datastructures.ImageCache" href="image_datastructures.html#fpdf.image_datastructures.ImageCache">ImageCache</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A representation of an SVG that has been converted to a PDF representation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/8e3857d46e647ab3184512938fbd08e4a91327ff/fpdf/svg.py#L617-L1020" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SVGObject:
    &#34;&#34;&#34;
    A representation of an SVG that has been converted to a PDF representation.
    &#34;&#34;&#34;

    @classmethod
    def from_file(cls, filename, *args, encoding=&#34;utf-8&#34;, **kwargs):
        &#34;&#34;&#34;
        Create an `SVGObject` from the contents of the file at `filename`.

        Args:
            filename (path-like): the path to a file containing SVG data.
            *args: forwarded directly to the SVGObject initializer. For subclass use.
            encoding (str): optional charset encoding to use when reading the file.
            **kwargs: forwarded directly to the SVGObject initializer. For subclass use.

        Returns:
            A converted `SVGObject`.
        &#34;&#34;&#34;
        with open(filename, &#34;r&#34;, encoding=encoding) as svgfile:
            return cls(svgfile.read(), *args, **kwargs)

    def __init__(self, svg_text, image_cache: ImageCache = None):
        self.image_cache = image_cache  # Needed to render images
        self.cross_references = {}

        # disabling bandit rule as we use defusedxml:
        svg_tree = parse_xml_str(svg_text)  # nosec B314

        if svg_tree.tag not in xmlns_lookup(&#34;svg&#34;, &#34;svg&#34;):
            raise ValueError(f&#34;root tag must be svg, not {svg_tree.tag}&#34;)

        self.extract_shape_info(svg_tree)
        self.convert_graphics(svg_tree)

    @force_nodocument
    def update_xref(self, key, referenced):
        if key:
            key = &#34;#&#34; + key if not key.startswith(&#34;#&#34;) else key
            self.cross_references[key] = referenced

    @force_nodocument
    def extract_shape_info(self, root_tag):
        &#34;&#34;&#34;Collect shape info from the given SVG.&#34;&#34;&#34;

        width = root_tag.get(&#34;width&#34;)
        height = root_tag.get(&#34;height&#34;)
        viewbox = root_tag.get(&#34;viewBox&#34;)
        # we don&#39;t fully support this, just check for its existence
        preserve_ar = root_tag.get(&#34;preserveAspectRatio&#34;, True)
        if preserve_ar == &#34;none&#34;:
            self.preserve_ar = None
        else:
            self.preserve_ar = True

        self.width = None
        if width is not None:
            width.strip()
            if width.endswith(&#34;%&#34;):
                self.width = Percent(width[:-1])
            else:
                self.width = resolve_length(width)

        self.height = None
        if height is not None:
            height.strip()
            if height.endswith(&#34;%&#34;):
                self.height = Percent(height[:-1])
            else:
                self.height = resolve_length(height)

        if viewbox is None:
            self.viewbox = None
        else:
            viewbox.strip()
            vx, vy, vw, vh = [float(num) for num in NUMBER_SPLIT.split(viewbox)]
            if (vw &lt; 0) or (vh &lt; 0):
                raise ValueError(f&#34;invalid negative width/height in viewbox {viewbox}&#34;)

            self.viewbox = [vx, vy, vw, vh]

    @force_nodocument
    def convert_graphics(self, root_tag):
        &#34;&#34;&#34;Convert the graphics contained in the SVG into the PDF representation.&#34;&#34;&#34;
        base_group = GraphicsContext()
        base_group.style.stroke_width = None
        base_group.style.auto_close = False
        base_group.style.stroke_cap_style = &#34;butt&#34;

        self.build_group(root_tag, base_group)

        self.base_group = base_group

    def transform_to_page_viewport(self, pdf, align_viewbox=True):
        &#34;&#34;&#34;
        Size the converted SVG paths to the page viewport.

        The SVG document size can be specified relative to the rendering viewport
        (e.g. width=50%). If the converted SVG sizes are relative units, then this
        computes the appropriate scale transform to size the SVG to the correct
        dimensions for a page in the current PDF document.

        If the SVG document size is specified in absolute units, then it is not scaled.

        Args:
            pdf (fpdf.FPDF): the pdf to use the page size of.
            align_viewbox (bool): if True, mimic some of the SVG alignment rules if the
                viewbox aspect ratio does not match that of the viewport.

        Returns:
            The same thing as `SVGObject.transform_to_rect_viewport`.
        &#34;&#34;&#34;

        return self.transform_to_rect_viewport(pdf.k, pdf.epw, pdf.eph, align_viewbox)

    def transform_to_rect_viewport(
        self, scale, width, height, align_viewbox=True, ignore_svg_top_attrs=False
    ):
        &#34;&#34;&#34;
        Size the converted SVG paths to an arbitrarily sized viewport.

        The SVG document size can be specified relative to the rendering viewport
        (e.g. width=50%). If the converted SVG sizes are relative units, then this
        computes the appropriate scale transform to size the SVG to the correct
        dimensions for a page in the current PDF document.

        Args:
            scale (Number): the scale factor from document units to PDF points.
            width (Number): the width of the viewport to scale to in document units.
            height (Number): the height of the viewport to scale to in document units.
            align_viewbox (bool): if True, mimic some of the SVG alignment rules if the
                viewbox aspect ratio does not match that of the viewport.
            ignore_svg_top_attrs (bool): ignore &lt;svg&gt; top attributes like &#34;width&#34;, &#34;height&#34;
                or &#34;preserveAspectRatio&#34; when figuring the image dimensions.
                Require width &amp; height to be provided as parameters.

        Returns:
            A tuple of (width, height, `fpdf.drawing.GraphicsContext`), where width and
            height are the resolved width and height (they may be 0. If 0, the returned
            `fpdf.drawing.GraphicsContext` will be empty). The
            `fpdf.drawing.GraphicsContext` contains all of the paths that were
            converted from the SVG, scaled to the given viewport size.
        &#34;&#34;&#34;

        if ignore_svg_top_attrs:
            vp_width = width
        elif isinstance(self.width, Percent):
            if not width:
                raise ValueError(
                    &#39;SVG &#34;width&#34; is a percentage, hence a viewport width is required&#39;
                )
            vp_width = self.width * width / 100
        else:
            vp_width = self.width or width

        if ignore_svg_top_attrs:
            vp_height = height
        elif isinstance(self.height, Percent):
            if not height:
                raise ValueError(
                    &#39;SVG &#34;height&#34; is a percentage, hence a viewport height is required&#39;
                )
            vp_height = self.height * height / 100
        else:
            vp_height = self.height or height

        if scale == 1:
            transform = Transform.identity()
        else:
            transform = Transform.scaling(1 / scale)

        if self.viewbox:
            vx, vy, vw, vh = self.viewbox

            if (vw == 0) or (vh == 0):
                return 0, 0, GraphicsContext()

            w_ratio = vp_width / vw
            h_ratio = vp_height / vh

            if not ignore_svg_top_attrs and self.preserve_ar and (w_ratio != h_ratio):
                w_ratio = h_ratio = min(w_ratio, h_ratio)

            transform = (
                transform
                @ Transform.translation(x=-vx, y=-vy)
                @ Transform.scaling(x=w_ratio, y=h_ratio)
            )

            if align_viewbox:
                transform = transform @ Transform.translation(
                    x=vp_width / 2 - (vw / 2) * w_ratio,
                    y=vp_height / 2 - (vh / 2) * h_ratio,
                )

        self.base_group.transform = transform

        return vp_width / scale, vp_height / scale, self.base_group

    def draw_to_page(self, pdf, x=None, y=None, debug_stream=None):
        &#34;&#34;&#34;
        Directly draw the converted SVG to the given PDF&#39;s current page.

        The page viewport is used for sizing the SVG.

        Args:
            pdf (fpdf.FPDF): the document to which the converted SVG is rendered.
            x (Number): abscissa of the converted SVG&#39;s top-left corner.
            y (Number): ordinate of the converted SVG&#39;s top-left corner.
            debug_stream (io.TextIO): the stream to which rendering debug info will be
                written.
        &#34;&#34;&#34;
        self.image_cache = pdf.image_cache  # Needed to render images
        _, _, path = self.transform_to_page_viewport(pdf)

        old_x, old_y = pdf.x, pdf.y
        try:
            if x is not None and y is not None:
                pdf.set_xy(0, 0)
                path.transform = path.transform @ Transform.translation(x, y)

            pdf.draw_path(path, debug_stream)

        finally:
            pdf.set_xy(old_x, old_y)

    # defs paths are not drawn immediately but are added to xrefs and can be referenced
    # later to be drawn.
    @force_nodocument
    def handle_defs(self, defs):
        &#34;&#34;&#34;Produce lookups for groups and paths inside the &lt;defs&gt; tag&#34;&#34;&#34;
        for child in defs:
            if child.tag in xmlns_lookup(&#34;svg&#34;, &#34;g&#34;):
                self.build_group(child)
            elif child.tag in xmlns_lookup(&#34;svg&#34;, &#34;path&#34;):
                self.build_path(child)
            elif child.tag in xmlns_lookup(&#34;svg&#34;, &#34;image&#34;):
                self.build_image(child)
            elif child.tag in shape_tags:
                self.build_shape(child)
            elif child.tag in xmlns_lookup(&#34;svg&#34;, &#34;clipPath&#34;):
                try:
                    clip_id = child.attrib[&#34;id&#34;]
                except KeyError:
                    clip_id = None
                for child_ in child:
                    self.build_clipping_path(child_, clip_id)
            else:
                LOGGER.warning(
                    &#34;Ignoring unsupported SVG tag: &lt;%s&gt; (contributions are welcome to add support for it)&#34;,
                    without_ns(child.tag),
                )

    # this assumes xrefs only reference already-defined ids.
    # I don&#39;t know if this is required by the SVG spec.
    @force_nodocument
    def build_xref(self, xref):
        &#34;&#34;&#34;Resolve a cross-reference to an already-seen SVG element by ID.&#34;&#34;&#34;
        pdf_group = GraphicsContext()
        apply_styles(pdf_group, xref)

        for candidate in xmlns_lookup(&#34;xlink&#34;, &#34;href&#34;, &#34;id&#34;):
            try:
                ref = xref.attrib[candidate]
                break
            except KeyError:
                pass
        else:
            raise ValueError(f&#34;use {xref} doesn&#39;t contain known xref attribute&#34;)

        try:
            pdf_group.add_item(self.cross_references[ref])
        except KeyError:
            raise ValueError(
                f&#34;use {xref} references nonexistent ref id {ref}&#34;
            ) from None

        if &#34;x&#34; in xref.attrib or &#34;y&#34; in xref.attrib:
            # Quoting the SVG spec - 5.6.2. Layout of re-used graphics:
            # &gt; The x and y properties define an additional transformation translate(x,y)
            x, y = float(xref.attrib.get(&#34;x&#34;, 0)), float(xref.attrib.get(&#34;y&#34;, 0))
            pdf_group.transform = Transform.translation(x=x, y=y)
        # Note that we currently do not support &#34;width&#34; &amp; &#34;height&#34; in &lt;use&gt;

        return pdf_group

    @force_nodocument
    def build_group(self, group, pdf_group=None):
        &#34;&#34;&#34;Handle nested items within a group &lt;g&gt; tag.&#34;&#34;&#34;
        if pdf_group is None:
            pdf_group = GraphicsContext()
            apply_styles(pdf_group, group)

        # handle defs before anything else
        for child in [
            child for child in group if child.tag in xmlns_lookup(&#34;svg&#34;, &#34;defs&#34;)
        ]:
            self.handle_defs(child)

        for child in group:
            if child.tag in xmlns_lookup(&#34;svg&#34;, &#34;defs&#34;):
                self.handle_defs(child)
            elif child.tag in xmlns_lookup(&#34;svg&#34;, &#34;g&#34;):
                pdf_group.add_item(self.build_group(child))
            elif child.tag in xmlns_lookup(&#34;svg&#34;, &#34;path&#34;):
                pdf_group.add_item(self.build_path(child))
            elif child.tag in shape_tags:
                pdf_group.add_item(self.build_shape(child))
            elif child.tag in xmlns_lookup(&#34;svg&#34;, &#34;use&#34;):
                pdf_group.add_item(self.build_xref(child))
            elif child.tag in xmlns_lookup(&#34;svg&#34;, &#34;image&#34;):
                pdf_group.add_item(self.build_image(child))
            else:
                LOGGER.warning(
                    &#34;Ignoring unsupported SVG tag: &lt;%s&gt; (contributions are welcome to add support for it)&#34;,
                    without_ns(child.tag),
                )

        self.update_xref(group.attrib.get(&#34;id&#34;), pdf_group)

        return pdf_group

    @force_nodocument
    def build_path(self, path):
        &#34;&#34;&#34;Convert an SVG &lt;path&gt; tag into a PDF path object.&#34;&#34;&#34;
        pdf_path = PaintedPath()
        apply_styles(pdf_path, path)
        self.apply_clipping_path(pdf_path, path)
        svg_path = path.attrib.get(&#34;d&#34;)
        if svg_path is not None:
            svg_path_converter(pdf_path, svg_path)
        self.update_xref(path.attrib.get(&#34;id&#34;), pdf_path)
        return pdf_path

    @force_nodocument
    def build_shape(self, shape):
        &#34;&#34;&#34;Convert an SVG shape tag into a PDF path object. Necessary to make xref (because ShapeBuilder doesn&#39;t have access to this object.)&#34;&#34;&#34;
        shape_builder = getattr(ShapeBuilder, shape_tags[shape.tag])
        shape_path = shape_builder(shape)
        self.apply_clipping_path(shape_path, shape)
        self.update_xref(shape.attrib.get(&#34;id&#34;), shape_path)
        return shape_path

    @force_nodocument
    def build_clipping_path(self, shape, clip_id):
        if shape.tag in shape_tags:
            shape_builder = getattr(ShapeBuilder, shape_tags[shape.tag])
            clipping_path_shape = shape_builder(shape, True)
        elif shape.tag in xmlns_lookup(&#34;svg&#34;, &#34;path&#34;):
            clipping_path_shape = PaintedPath()
            apply_styles(clipping_path_shape, shape)
            clipping_path_shape.paint_rule = PathPaintRule.DONT_PAINT
            svg_path = shape.attrib.get(&#34;d&#34;)
            if svg_path is not None:
                svg_path_converter(clipping_path_shape, svg_path)
        else:
            LOGGER.warning(
                &#34;Ignoring unsupported &lt;clipPath&gt; child tag: &lt;%s&gt; (contributions are welcome to add support for it)&#34;,
                without_ns(shape.tag),
            )
            return
        self.update_xref(clip_id, clipping_path_shape)

    @force_nodocument
    def apply_clipping_path(self, stylable, svg_element):
        clipping_path = svg_element.attrib.get(&#34;clip-path&#34;)
        if clipping_path:
            clipping_path_id = re.search(r&#34;url\((\#\w+)\)&#34;, clipping_path)
            stylable.clipping_path = self.cross_references[clipping_path_id[1]]

    @force_nodocument
    def build_image(self, image):
        href = None
        for key in xmlns_lookup(&#34;xlink&#34;, &#34;href&#34;):
            if key in image.attrib:
                href = image.attrib[key]
                break
        if not href:
            raise ValueError(&#34;&lt;image&gt; is missing a href attribute&#34;)
        width = float(image.attrib.get(&#34;width&#34;, 0))
        height = float(image.attrib.get(&#34;height&#34;, 0))
        if &#34;preserveAspectRatio&#34; in image.attrib:
            LOGGER.warning(
                &#39;&#34;preserveAspectRatio&#34; defined on &lt;image&gt; is currently not supported (contributions are welcome to add support for it)&#39;
            )
        if &#34;style&#34; in image.attrib:
            LOGGER.warning(
                &#39;&#34;style&#34; defined on &lt;image&gt; is currently not supported (contributions are welcome to add support for it)&#39;
            )
        if &#34;transform&#34; in image.attrib:
            LOGGER.warning(
                &#39;&#34;transform&#34; defined on &lt;image&gt; is currently not supported (contributions are welcome to add support for it)&#39;
            )
        # Note: at this moment, self.image_cache is not set yet:
        svg_image = SVGImage(
            href=href,
            x=float(image.attrib.get(&#34;x&#34;, &#34;0&#34;)),
            y=float(image.attrib.get(&#34;y&#34;, &#34;0&#34;)),
            width=width,
            height=height,
            svg_obj=self,
        )
        self.update_xref(image.attrib.get(&#34;id&#34;), svg_image)
        return svg_image</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.svg.SVGObject.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>filename, *args, encoding='utf-8', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an <code><a title="fpdf.svg.SVGObject" href="#fpdf.svg.SVGObject">SVGObject</a></code> from the contents of the file at <code>filename</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>path-like</code></dt>
<dd>the path to a file containing SVG data.</dd>
<dt><strong><code>*args</code></strong></dt>
<dd>forwarded directly to the SVGObject initializer. For subclass use.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code></dt>
<dd>optional charset encoding to use when reading the file.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>forwarded directly to the SVGObject initializer. For subclass use.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A converted <code><a title="fpdf.svg.SVGObject" href="#fpdf.svg.SVGObject">SVGObject</a></code>.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.svg.SVGObject.draw_to_page"><code class="name flex">
<span>def <span class="ident">draw_to_page</span></span>(<span>self, pdf, x=None, y=None, debug_stream=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Directly draw the converted SVG to the given PDF's current page.</p>
<p>The page viewport is used for sizing the SVG.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pdf</code></strong> :&ensp;<code>fpdf.FPDF</code></dt>
<dd>the document to which the converted SVG is rendered.</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>Number</code></dt>
<dd>abscissa of the converted SVG's top-left corner.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Number</code></dt>
<dd>ordinate of the converted SVG's top-left corner.</dd>
<dt><strong><code>debug_stream</code></strong> :&ensp;<code>io.TextIO</code></dt>
<dd>the stream to which rendering debug info will be
written.</dd>
</dl></div>
</dd>
<dt id="fpdf.svg.SVGObject.transform_to_page_viewport"><code class="name flex">
<span>def <span class="ident">transform_to_page_viewport</span></span>(<span>self, pdf, align_viewbox=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Size the converted SVG paths to the page viewport.</p>
<p>The SVG document size can be specified relative to the rendering viewport
(e.g. width=50%). If the converted SVG sizes are relative units, then this
computes the appropriate scale transform to size the SVG to the correct
dimensions for a page in the current PDF document.</p>
<p>If the SVG document size is specified in absolute units, then it is not scaled.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pdf</code></strong> :&ensp;<code>fpdf.FPDF</code></dt>
<dd>the pdf to use the page size of.</dd>
<dt><strong><code>align_viewbox</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, mimic some of the SVG alignment rules if the
viewbox aspect ratio does not match that of the viewport.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same thing as <code><a title="fpdf.svg.SVGObject.transform_to_rect_viewport" href="#fpdf.svg.SVGObject.transform_to_rect_viewport">SVGObject.transform_to_rect_viewport()</a></code>.</p></div>
</dd>
<dt id="fpdf.svg.SVGObject.transform_to_rect_viewport"><code class="name flex">
<span>def <span class="ident">transform_to_rect_viewport</span></span>(<span>self, scale, width, height, align_viewbox=True, ignore_svg_top_attrs=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Size the converted SVG paths to an arbitrarily sized viewport.</p>
<p>The SVG document size can be specified relative to the rendering viewport
(e.g. width=50%). If the converted SVG sizes are relative units, then this
computes the appropriate scale transform to size the SVG to the correct
dimensions for a page in the current PDF document.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scale</code></strong> :&ensp;<code>Number</code></dt>
<dd>the scale factor from document units to PDF points.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>Number</code></dt>
<dd>the width of the viewport to scale to in document units.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>Number</code></dt>
<dd>the height of the viewport to scale to in document units.</dd>
<dt><strong><code>align_viewbox</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, mimic some of the SVG alignment rules if the
viewbox aspect ratio does not match that of the viewport.</dd>
<dt><strong><code>ignore_svg_top_attrs</code></strong> :&ensp;<code>bool</code></dt>
<dd>ignore <svg> top attributes like "width", "height"
or "preserveAspectRatio" when figuring the image dimensions.
Require width &amp; height to be provided as parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of (width, height, <code><a title="fpdf.drawing.GraphicsContext" href="drawing.html#fpdf.drawing.GraphicsContext">GraphicsContext</a></code>), where width and
height are the resolved width and height (they may be 0. If 0, the returned
<code><a title="fpdf.drawing.GraphicsContext" href="drawing.html#fpdf.drawing.GraphicsContext">GraphicsContext</a></code> will be empty). The
<code><a title="fpdf.drawing.GraphicsContext" href="drawing.html#fpdf.drawing.GraphicsContext">GraphicsContext</a></code> contains all of the paths that were
converted from the SVG, scaled to the given viewport size.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.svg.PathPen" href="#fpdf.svg.PathPen">PathPen</a></code></h4>
<ul class="">
<li><code><a title="fpdf.svg.PathPen.arcTo" href="#fpdf.svg.PathPen.arcTo">arcTo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.svg.SVGImage" href="#fpdf.svg.SVGImage">SVGImage</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.svg.SVGImage.height" href="#fpdf.svg.SVGImage.height">height</a></code></li>
<li><code><a title="fpdf.svg.SVGImage.href" href="#fpdf.svg.SVGImage.href">href</a></code></li>
<li><code><a title="fpdf.svg.SVGImage.svg_obj" href="#fpdf.svg.SVGImage.svg_obj">svg_obj</a></code></li>
<li><code><a title="fpdf.svg.SVGImage.width" href="#fpdf.svg.SVGImage.width">width</a></code></li>
<li><code><a title="fpdf.svg.SVGImage.x" href="#fpdf.svg.SVGImage.x">x</a></code></li>
<li><code><a title="fpdf.svg.SVGImage.y" href="#fpdf.svg.SVGImage.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.svg.SVGObject" href="#fpdf.svg.SVGObject">SVGObject</a></code></h4>
<ul class="">
<li><code><a title="fpdf.svg.SVGObject.draw_to_page" href="#fpdf.svg.SVGObject.draw_to_page">draw_to_page</a></code></li>
<li><code><a title="fpdf.svg.SVGObject.from_file" href="#fpdf.svg.SVGObject.from_file">from_file</a></code></li>
<li><code><a title="fpdf.svg.SVGObject.transform_to_page_viewport" href="#fpdf.svg.SVGObject.transform_to_page_viewport">transform_to_page_viewport</a></code></li>
<li><code><a title="fpdf.svg.SVGObject.transform_to_rect_viewport" href="#fpdf.svg.SVGObject.transform_to_rect_viewport">transform_to_rect_viewport</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
