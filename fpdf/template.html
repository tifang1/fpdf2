<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fpdf.template API documentation</title>
<meta name="description" content="PDF Template Helpers for fpdf.py" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.template</code></h1>
</header>
<section id="section-intro">
<p>PDF Template Helpers for fpdf.py</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;PDF Template Helpers for fpdf.py&#34;&#34;&#34;

__author__ = &#34;Mariano Reingart &lt;reingart@gmail.com&gt;&#34;
__copyright__ = &#34;Copyright (C) 2010 Mariano Reingart&#34;
__license__ = &#34;LGPL 3.0&#34;

import csv, locale, warnings

from .errors import FPDFException
from .fpdf import FPDF


def _rgb(col):
    return (col // 65536), (col // 256 % 256), (col % 256)


def _rgb_as_str(col):
    r, g, b = _rgb(col)
    if (r == 0 and g == 0 and b == 0) or g == -1:
        return f&#34;{r / 255:.3f} g&#34;
    return f&#34;{r / 255:.3f} {g / 255:.3f} {b / 255:.3f} rg&#34;


class FlexTemplate:
    &#34;&#34;&#34;
    A flexible templating class.

    Allows to apply one or several template definitions to any page of
    a document in any combination.
    &#34;&#34;&#34;

    def __init__(self, pdf, elements=None):
        &#34;&#34;&#34;
        Arguments:

            pdf (fpdf.FPDF() instance):
                All content will be added to this object.

            elements (list of dicts):
                A template definition in a list of dicts.
                If you omit this, then you need to call either load_elements()
                or parse_csv() before doing anything else.
        &#34;&#34;&#34;
        if not isinstance(pdf, FPDF):
            raise TypeError(&#34;&#39;pdf&#39; must be an instance of fpdf.FPDF()&#34;)
        self.pdf = pdf
        self.splitting_pdf = None  # for split_multicell()
        if elements:
            self.load_elements(elements)
        self.handlers = {
            &#34;T&#34;: self._text,
            &#34;L&#34;: self._line,
            &#34;I&#34;: self._image,
            &#34;B&#34;: self._rect,
            &#34;E&#34;: self._ellipse,
            &#34;BC&#34;: self._barcode,
            &#34;C39&#34;: self._code39,
            &#34;W&#34;: self._write,
        }
        self.texts = {}

    def load_elements(self, elements):
        &#34;&#34;&#34;
        Load a template definition.

        Arguments:

            elements (list of dicts):
                A template definition in a list of dicts
        &#34;&#34;&#34;
        key_config = {
            # key: type
            &#34;name&#34;: (str, type(None)),
            &#34;type&#34;: (str, type(None)),
            &#34;x1&#34;: (int, float),
            &#34;y1&#34;: (int, float),
            &#34;x2&#34;: (int, float),
            &#34;y2&#34;: (int, float),
            &#34;font&#34;: (str, type(None)),
            &#34;size&#34;: (int, float),
            &#34;bold&#34;: object,  # &#34;bool or equivalent&#34;
            &#34;italic&#34;: object,
            &#34;underline&#34;: object,
            &#34;foreground&#34;: int,
            &#34;background&#34;: int,
            &#34;align&#34;: (str, type(None)),
            &#34;text&#34;: (str, type(None)),
            &#34;priority&#34;: int,
            &#34;multiline&#34;: (bool, type(None)),
            &#34;rotate&#34;: (int, float),
        }

        self.elements = elements
        self.keys = []
        for e in elements:
            # priority is optional, but we need a default for sorting.
            if not &#34;priority&#34; in e:
                e[&#34;priority&#34;] = 0
            for k in (&#34;name&#34;, &#34;type&#34;, &#34;x1&#34;, &#34;y1&#34;, &#34;y2&#34;):
                if k not in e:
                    if e[&#34;type&#34;] == &#34;C39&#34;:
                        # lots of legacy special casing.
                        # We need to do that here, so that rotation and scaling
                        # still work.
                        if k == &#34;x1&#34; and &#34;x&#34; in e:
                            e[&#34;x1&#34;] = e[&#34;x&#34;]
                            continue
                        if k == &#34;y1&#34; and &#34;y&#34; in e:
                            e[&#34;y1&#34;] = e[&#34;y&#34;]
                            continue
                        if k == &#34;y2&#34; and &#34;h&#34; in e:
                            e[&#34;y2&#34;] = e[&#34;y1&#34;] + e[&#34;h&#34;]
                            continue
                    raise KeyError(f&#34;Mandatory key &#39;{k}&#39; missing in input data&#34;)
            # x2 is optional for barcode types, but needed for offset rendering
            if &#34;x2&#34; not in e:
                if e[&#34;type&#34;] in [&#34;BC&#34;, &#34;C39&#34;]:
                    e[&#34;x2&#34;] = 0
                else:
                    raise KeyError(&#34;Mandatory key &#39;x2&#39; missing in input data&#34;)
            if not &#34;size&#34; in e and e[&#34;type&#34;] == &#34;C39&#34;:
                if &#34;w&#34; in e:
                    e[&#34;size&#34;] = e[&#34;w&#34;]
            for k, t in key_config.items():
                if k in e and not isinstance(e[k], t):
                    # pylint: disable=no-member
                    ttype = (
                        t.__name__
                        if isinstance(t, type)
                        else &#34; or &#34;.join([f&#34;&#39;{x.__name__}&#39;&#34; for x in t])
                    )
                    raise TypeError(
                        f&#34;Value of element item &#39;{k}&#39; must be {ttype}, not &#39;{type(e[k]).__name__}&#39;.&#34;
                    )
            self.keys.append(e[&#34;name&#34;].lower())

    @staticmethod
    def _parse_colorcode(s):
        &#34;&#34;&#34;Allow hex and oct values for colors&#34;&#34;&#34;
        if s[:2] in [&#34;0x&#34;, &#34;0X&#34;]:
            return int(s, 16)
        if s[0] == &#34;0&#34;:
            return int(s, 8)
        return int(s)

    @staticmethod
    def _parse_multiline(s):
        i = int(s)
        if i &gt; 0:
            return True
        if i &lt; 0:
            return False
        return None

    def parse_csv(self, infile, delimiter=&#34;,&#34;, decimal_sep=&#34;.&#34;, encoding=None):
        &#34;&#34;&#34;
        Load the template definition from a CSV file.

        Arguments:

            infile (string):
                The filename of the CSV file.

            delimiter (single character):
                The character that seperates the fields in the CSV file:
                Usually a comma, semicolon, or tab.

            decimal_sep (single character):
                The decimal separator used in the file.
                Usually either a point or a comma.

            encoding (string):
                The character encoding of the file.
                Default is the system default encoding.

        &#34;&#34;&#34;

        def _varsep_float(s, default=&#34;0&#34;):
            &#34;&#34;&#34;Convert to float with given decimal seperator&#34;&#34;&#34;
            # glad to have nonlocal scoping...
            return float((s.strip() or default).replace(decimal_sep, &#34;.&#34;))

        key_config = (
            # key, converter, mandatory
            (&#34;name&#34;, str, True),
            (&#34;type&#34;, str, True),
            (&#34;x1&#34;, _varsep_float, True),
            (&#34;y1&#34;, _varsep_float, True),
            (&#34;x2&#34;, _varsep_float, True),
            (&#34;y2&#34;, _varsep_float, True),
            (&#34;font&#34;, str, False),
            (&#34;size&#34;, _varsep_float, False),
            (&#34;bold&#34;, int, False),
            (&#34;italic&#34;, int, False),
            (&#34;underline&#34;, int, False),
            (&#34;foreground&#34;, self._parse_colorcode, False),
            (&#34;background&#34;, self._parse_colorcode, False),
            (&#34;align&#34;, str, False),
            (&#34;text&#34;, str, False),
            (&#34;priority&#34;, int, False),
            (&#34;multiline&#34;, self._parse_multiline, False),
            (&#34;rotate&#34;, _varsep_float, False),
        )
        self.elements = []
        if encoding is None:
            encoding = locale.getpreferredencoding()
        with open(infile, encoding=encoding) as f:
            for row in csv.reader(f, delimiter=delimiter):
                # fill in blanks for any missing items
                row.extend([&#34;&#34;] * (len(key_config) - len(row)))
                kargs = {}
                for val, cfg in zip(row, key_config):
                    vs = val.strip()
                    if not vs:
                        if cfg[2]:  # mandatory
                            if cfg[0] == &#34;x2&#34; and row[1] in [&#34;BC&#34;, &#34;C39&#34;]:
                                # two types don&#39;t need x2, but offset rendering does
                                pass
                            else:
                                raise FPDFException(
                                    f&#34;Mandatory value &#39;{cfg[0]}&#39; missing in csv data&#34;
                                )
                        elif cfg[0] == &#34;priority&#34;:
                            # formally optional, but we need some value for sorting
                            kargs[&#34;priority&#34;] = 0
                        # otherwise, let the type handlers use their own defaults
                    else:
                        kargs[cfg[0]] = cfg[1](vs)
                self.elements.append(kargs)
        self.keys = [val[&#34;name&#34;].lower() for val in self.elements]

    def __setitem__(self, name, value):
        assert isinstance(
            name, str
        ), f&#34;name must be of type &#39;str&#39;, not &#39;{type(name).__name__}&#39;.&#34;
        # value has too many valid types to reasonably check here
        if name.lower() not in self.keys:
            raise FPDFException(f&#34;Element not loaded, cannot set item: {name}&#34;)
        self.texts[name.lower()] = value

    # setitem shortcut (may be further extended)
    set = __setitem__

    def __contains__(self, name):
        assert isinstance(
            name, str
        ), f&#34;name must be of type &#39;str&#39;, not &#39;{type(name).__name__}&#39;.&#34;
        return name.lower() in self.keys

    def __getitem__(self, name):
        assert isinstance(
            name, str
        ), f&#34;name must be of type &#39;str&#39;, not &#39;{type(name).__name__}&#39;.&#34;
        if name not in self.keys:
            raise KeyError(name)
        key = name.lower()
        if key in self.texts:
            # text for this page:
            return self.texts[key]
        # find first element for default text:
        return next(
            (x[&#34;text&#34;] for x in self.elements if x[&#34;name&#34;].lower() == key), None
        )

    def split_multicell(self, text, element_name):
        &#34;&#34;&#34;
        Split a string between words, for the parts to fit into a given element
        width. Additional splits will be made replacing any &#39;\\n&#39; characters.

        Arguments:

            text (string):
                The input text string.

            element_name (string):
                The name of the template element to fit the text inside.

        Returns:
            A list of substrings, each of which will fit into the element width
            when rendered in the element font style and size.
        &#34;&#34;&#34;
        element = next(
            element
            for element in self.elements
            if element[&#34;name&#34;].lower() == element_name.lower()
        )
        if not self.splitting_pdf:
            self.splitting_pdf = FPDF()
            self.splitting_pdf.add_page()
        style = &#34;&#34;
        if element.get(&#34;bold&#34;):
            style += &#34;B&#34;
        if element.get(&#34;italic&#34;):
            style += &#34;I&#34;
        if element.get(&#34;underline&#34;):
            style += &#34;U&#34;
        self.splitting_pdf.set_font(element[&#34;font&#34;], style, element[&#34;size&#34;])
        return self.splitting_pdf.multi_cell(
            w=element[&#34;x2&#34;] - element[&#34;x1&#34;],
            h=element[&#34;y2&#34;] - element[&#34;y1&#34;],
            txt=str(text),
            align=element.get(&#34;align&#34;, &#34;&#34;),
            split_only=True,
        )

    def _text(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;helvetica&#34;,
        size=10,
        scale=1.0,
        bold=False,
        italic=False,
        underline=False,
        align=&#34;&#34;,
        foreground=0,
        background=None,
        multiline=None,
        **__,
    ):
        if not text:
            return
        pdf = self.pdf
        if pdf.text_color != _rgb_as_str(foreground):
            pdf.set_text_color(*_rgb(foreground))
        if background is None:
            fill = False
        else:
            fill = True
            if pdf.fill_color != _rgb_as_str(background):
                pdf.set_fill_color(*_rgb(background))

        font = font.strip().lower()
        style = &#34;&#34;
        for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
            if text.startswith(f&#34;&lt;{tag}&gt;&#34;) and text.endswith(f&#34;&lt;/{tag}&gt;&#34;):
                text = text[3:-4]
                style += tag
        if bold:
            style += &#34;B&#34;
        if italic:
            style += &#34;I&#34;
        if underline:
            style += &#34;U&#34;
        pdf.set_font(font, style, size * scale)
        pdf.set_xy(x1, y1)
        width, height = x2 - x1, y2 - y1
        if multiline is None:  # write without wrapping/trimming (default)
            pdf.cell(w=width, h=height, txt=text, border=0, align=align, fill=fill)
        elif multiline:  # automatic word - warp
            pdf.multi_cell(
                w=width, h=height, txt=text, border=0, align=align, fill=fill
            )
        else:  # trim to fit exactly the space defined
            text = pdf.multi_cell(
                w=width, h=height, txt=text, align=align, split_only=True
            )[0]
            pdf.cell(w=width, h=height, txt=text, border=0, align=align, fill=fill)

    def _line(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        size=0,
        scale=1.0,
        foreground=0,
        **__,
    ):
        if self.pdf.draw_color.serialize().lower() != _rgb_as_str(foreground):
            self.pdf.set_draw_color(*_rgb(foreground))
        self.pdf.set_line_width(size * scale)
        self.pdf.line(x1, y1, x2, y2)

    def _rect(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        size=0,
        scale=1.0,
        foreground=0,
        background=None,
        **__,
    ):
        pdf = self.pdf
        if pdf.draw_color.serialize().lower() != _rgb_as_str(foreground):
            pdf.set_draw_color(*_rgb(foreground))
        if background is None:
            style = &#34;D&#34;
        else:
            style = &#34;FD&#34;
            if pdf.fill_color != _rgb_as_str(background):
                pdf.set_fill_color(*_rgb(background))
        pdf.set_line_width(size * scale)
        pdf.rect(x1, y1, x2 - x1, y2 - y1, style=style)

    def _ellipse(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        size=0,
        scale=1.0,
        foreground=0,
        background=None,
        **__,
    ):
        pdf = self.pdf
        if pdf.draw_color.serialize().lower() != _rgb_as_str(foreground):
            pdf.set_draw_color(*_rgb(foreground))
        if background is None:
            style = &#34;D&#34;
        else:
            style = &#34;FD&#34;
            if pdf.fill_color != _rgb_as_str(background):
                pdf.set_fill_color(*_rgb(background))
        pdf.set_line_width(size * scale)
        pdf.ellipse(x1, y1, x2 - x1, y2 - y1, style=style)

    def _image(self, *_, x1=0, y1=0, x2=0, y2=0, text=&#34;&#34;, **__):
        if text:
            self.pdf.image(text, x1, y1, w=x2 - x1, h=y2 - y1, link=&#34;&#34;)

    def _barcode(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;interleaved 2of5 nt&#34;,
        size=1,
        scale=1.0,
        foreground=0,
        **__,
    ):
        # pylint: disable=unused-argument
        pdf = self.pdf
        if pdf.fill_color.serialize().lower() != _rgb_as_str(foreground):
            pdf.set_fill_color(*_rgb(foreground))
        font = font.lower().strip()
        if font == &#34;interleaved 2of5 nt&#34;:
            pdf.interleaved2of5(text, x1, y1, w=size * scale, h=y2 - y1)

    def _code39(
        self,
        *_,
        x1=0,
        y1=0,
        y2=0,
        text=&#34;&#34;,
        size=1.5,
        scale=1.0,
        foreground=0,
        x=None,
        y=None,
        w=None,
        h=None,
        **__,
    ):
        if x is not None or y is not None or w is not None or h is not None:
            warnings.warn(
                &#34;code39 arguments x/y/w/h are deprecated, please use x1/y1/y2/size instead&#34;,
                DeprecationWarning,
                stacklevel=2,
            )
        pdf = self.pdf
        if pdf.fill_color.serialize().lower() != _rgb_as_str(foreground):
            pdf.set_fill_color(*_rgb(foreground))
        h = y2 - y1
        if h &lt;= 0:
            h = 5
        pdf.code39(text, x1, y1, size * scale, h)

    # Added by Derek Schwalenberg Schwalenberg1013@gmail.com to allow (url) links in
    # templates (using write method) 2014-02-22
    def _write(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;helvetica&#34;,
        size=10,
        scale=1.0,
        bold=False,
        italic=False,
        underline=False,
        link=&#34;&#34;,
        foreground=0,
        **__,
    ):
        # pylint: disable=unused-argument
        if not text:
            return
        pdf = self.pdf
        if pdf.text_color != _rgb_as_str(foreground):
            pdf.set_text_color(*_rgb(foreground))
        font = font.strip().lower()
        style = &#34;&#34;
        for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
            if text.startswith(f&#34;&lt;{tag}&gt;&#34;) and text.endswith(f&#34;&lt;/{tag}&gt;&#34;):
                text = text[3:-4]
                style += tag
        if bold:
            style += &#34;B&#34;
        if italic:
            style += &#34;I&#34;
        if underline:
            style += &#34;U&#34;
        pdf.set_font(font, style, size * scale)
        pdf.set_xy(x1, y1)
        pdf.write(5, text, link)

    def render(self, offsetx=0.0, offsety=0.0, rotate=0.0, scale=1.0):
        &#34;&#34;&#34;
        Add the contents of the template to the PDF document.

        Arguments:

            offsetx, offsety (float):
                Place the template to move its origin to the given coordinates.

            rotate (float):
                Rotate the inserted template around its (offset) origin.

            scale (float):
                Scale the inserted template by this factor.
        &#34;&#34;&#34;
        sorted_elements = sorted(self.elements, key=lambda x: x[&#34;priority&#34;])
        with self.pdf.local_context():
            for element in sorted_elements:
                ele = element.copy()  # don&#39;t want to modify the callers original
                ele[&#34;text&#34;] = self.texts.get(ele[&#34;name&#34;].lower(), ele.get(&#34;text&#34;, &#34;&#34;))
                if scale != 1.0:
                    ele[&#34;x1&#34;] = ele[&#34;x1&#34;] * scale
                    ele[&#34;y1&#34;] = ele[&#34;y1&#34;] * scale
                    ele[&#34;x2&#34;] = ele[&#34;x1&#34;] + ((ele[&#34;x2&#34;] - element[&#34;x1&#34;]) * scale)
                    ele[&#34;y2&#34;] = ele[&#34;y1&#34;] + ((ele[&#34;y2&#34;] - element[&#34;y1&#34;]) * scale)
                if offsetx:
                    ele[&#34;x1&#34;] = ele[&#34;x1&#34;] + offsetx
                    ele[&#34;x2&#34;] = ele[&#34;x2&#34;] + offsetx
                if offsety:
                    ele[&#34;y1&#34;] = ele[&#34;y1&#34;] + offsety
                    ele[&#34;y2&#34;] = ele[&#34;y2&#34;] + offsety
                ele[&#34;scale&#34;] = scale
                handler_name = ele[&#34;type&#34;].upper()
                if rotate:  # don&#39;t rotate by 0.0 degrees
                    with self.pdf.rotation(rotate, offsetx, offsety):
                        if &#34;rotate&#34; in ele and ele[&#34;rotate&#34;]:
                            with self.pdf.rotation(ele[&#34;rotate&#34;], ele[&#34;x1&#34;], ele[&#34;y1&#34;]):
                                self.handlers[handler_name](**ele)
                        else:
                            self.handlers[handler_name](**ele)
                else:
                    if &#34;rotate&#34; in ele and ele[&#34;rotate&#34;]:
                        with self.pdf.rotation(ele[&#34;rotate&#34;], ele[&#34;x1&#34;], ele[&#34;y1&#34;]):
                            self.handlers[handler_name](**ele)
                    else:
                        self.handlers[handler_name](**ele)
        self.texts = {}  # reset modified entries for the next page


class Template(FlexTemplate):
    &#34;&#34;&#34;
    A simple templating class.

    Allows to apply a single template definition to all pages of a document.
    &#34;&#34;&#34;

    # Disabling this check due to the &#34;format&#34; parameter below:
    # pylint: disable=redefined-builtin
    # pylint: disable=unused-argument
    def __init__(
        self,
        infile=None,
        elements=None,
        format=&#34;A4&#34;,
        orientation=&#34;portrait&#34;,
        unit=&#34;mm&#34;,
        title=&#34;&#34;,
        author=&#34;&#34;,
        subject=&#34;&#34;,
        creator=&#34;&#34;,
        keywords=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Arguments:

            infile (str):
                [**DEPRECATED since 2.2.0**] unused, will be removed in a later version

            elements (list of dicts):
                A template definition in a list of dicts.
                If you omit this, then you need to call either load_elements()
                or parse_csv() before doing anything else.

            format (str):
                The page format of the document (eg. &#34;A4&#34; or &#34;letter&#34;).

            orientation (str):
                The orientation of the document.
                Possible values are &#34;portrait&#34;/&#34;P&#34; or &#34;landscape&#34;/&#34;L&#34;

            unit (str):
                The units used in the template definition.
                One of &#34;mm&#34;, &#34;cm&#34;, &#34;in&#34;, &#34;pt&#34;, or a number for points per unit.

            title (str): The title of the document.

            author (str): The author of the document.

            subject (str): The subject matter of the document.

            creator (str): The creator of the document.
        &#34;&#34;&#34;
        if infile:
            warnings.warn(
                &#39;&#34;infile&#34; is deprecated, unused and will soon be removed&#39;,
                DeprecationWarning,
                stacklevel=2,
            )
        for arg in (
            &#34;format&#34;,
            &#34;orientation&#34;,
            &#34;unit&#34;,
            &#34;title&#34;,
            &#34;author&#34;,
            &#34;subject&#34;,
            &#34;creator&#34;,
            &#34;keywords&#34;,
        ):
            # nosemgrep: python.lang.security.dangerous-globals-use.dangerous-globals-use
            if not isinstance(locals()[arg], str):
                raise TypeError(f&#39;Argument &#34;{arg}&#34; must be of type str.&#39;)
        pdf = FPDF(format=format, orientation=orientation, unit=unit)
        pdf.set_title(title)
        pdf.set_author(author)
        pdf.set_creator(creator)
        pdf.set_subject(subject)
        pdf.set_keywords(keywords)
        super().__init__(pdf=pdf, elements=elements)

    def add_page(self):
        &#34;&#34;&#34;Finish the current page, and proceed to the next one.&#34;&#34;&#34;
        if self.pdf.page:
            self.render()
        self.pdf.add_page()

    # pylint: disable=arguments-differ
    def render(self, outfile=None, dest=None):
        &#34;&#34;&#34;
        Finish the document and process all pending data.

        Arguments:

            outfile (str):
                If given, the PDF file will be written to this file name.
                Alternatively, the `.pdf.output()` method can be manually called.

            dest (str):
                [**DEPRECATED since 2.2.0**] unused, will be removed in a later version.
        &#34;&#34;&#34;
        if dest:
            warnings.warn(
                &#39;&#34;dest&#34; is deprecated, unused and will soon be removed&#39;,
                DeprecationWarning,
                stacklevel=2,
            )
        self.pdf.set_font(&#34;helvetica&#34;, &#34;B&#34;, 16)
        self.pdf.set_auto_page_break(False, margin=0)
        super().render()
        if outfile:
            self.pdf.output(outfile)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.template.FlexTemplate"><code class="flex name class">
<span>class <span class="ident">FlexTemplate</span></span>
<span>(</span><span>pdf, elements=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A flexible templating class.</p>
<p>Allows to apply one or several template definitions to any page of
a document in any combination.</p>
<h2 id="arguments">Arguments</h2>
<p>pdf (fpdf.FPDF() instance):
All content will be added to this object.</p>
<p>elements (list of dicts):
A template definition in a list of dicts.
If you omit this, then you need to call either load_elements()
or parse_csv() before doing anything else.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FlexTemplate:
    &#34;&#34;&#34;
    A flexible templating class.

    Allows to apply one or several template definitions to any page of
    a document in any combination.
    &#34;&#34;&#34;

    def __init__(self, pdf, elements=None):
        &#34;&#34;&#34;
        Arguments:

            pdf (fpdf.FPDF() instance):
                All content will be added to this object.

            elements (list of dicts):
                A template definition in a list of dicts.
                If you omit this, then you need to call either load_elements()
                or parse_csv() before doing anything else.
        &#34;&#34;&#34;
        if not isinstance(pdf, FPDF):
            raise TypeError(&#34;&#39;pdf&#39; must be an instance of fpdf.FPDF()&#34;)
        self.pdf = pdf
        self.splitting_pdf = None  # for split_multicell()
        if elements:
            self.load_elements(elements)
        self.handlers = {
            &#34;T&#34;: self._text,
            &#34;L&#34;: self._line,
            &#34;I&#34;: self._image,
            &#34;B&#34;: self._rect,
            &#34;E&#34;: self._ellipse,
            &#34;BC&#34;: self._barcode,
            &#34;C39&#34;: self._code39,
            &#34;W&#34;: self._write,
        }
        self.texts = {}

    def load_elements(self, elements):
        &#34;&#34;&#34;
        Load a template definition.

        Arguments:

            elements (list of dicts):
                A template definition in a list of dicts
        &#34;&#34;&#34;
        key_config = {
            # key: type
            &#34;name&#34;: (str, type(None)),
            &#34;type&#34;: (str, type(None)),
            &#34;x1&#34;: (int, float),
            &#34;y1&#34;: (int, float),
            &#34;x2&#34;: (int, float),
            &#34;y2&#34;: (int, float),
            &#34;font&#34;: (str, type(None)),
            &#34;size&#34;: (int, float),
            &#34;bold&#34;: object,  # &#34;bool or equivalent&#34;
            &#34;italic&#34;: object,
            &#34;underline&#34;: object,
            &#34;foreground&#34;: int,
            &#34;background&#34;: int,
            &#34;align&#34;: (str, type(None)),
            &#34;text&#34;: (str, type(None)),
            &#34;priority&#34;: int,
            &#34;multiline&#34;: (bool, type(None)),
            &#34;rotate&#34;: (int, float),
        }

        self.elements = elements
        self.keys = []
        for e in elements:
            # priority is optional, but we need a default for sorting.
            if not &#34;priority&#34; in e:
                e[&#34;priority&#34;] = 0
            for k in (&#34;name&#34;, &#34;type&#34;, &#34;x1&#34;, &#34;y1&#34;, &#34;y2&#34;):
                if k not in e:
                    if e[&#34;type&#34;] == &#34;C39&#34;:
                        # lots of legacy special casing.
                        # We need to do that here, so that rotation and scaling
                        # still work.
                        if k == &#34;x1&#34; and &#34;x&#34; in e:
                            e[&#34;x1&#34;] = e[&#34;x&#34;]
                            continue
                        if k == &#34;y1&#34; and &#34;y&#34; in e:
                            e[&#34;y1&#34;] = e[&#34;y&#34;]
                            continue
                        if k == &#34;y2&#34; and &#34;h&#34; in e:
                            e[&#34;y2&#34;] = e[&#34;y1&#34;] + e[&#34;h&#34;]
                            continue
                    raise KeyError(f&#34;Mandatory key &#39;{k}&#39; missing in input data&#34;)
            # x2 is optional for barcode types, but needed for offset rendering
            if &#34;x2&#34; not in e:
                if e[&#34;type&#34;] in [&#34;BC&#34;, &#34;C39&#34;]:
                    e[&#34;x2&#34;] = 0
                else:
                    raise KeyError(&#34;Mandatory key &#39;x2&#39; missing in input data&#34;)
            if not &#34;size&#34; in e and e[&#34;type&#34;] == &#34;C39&#34;:
                if &#34;w&#34; in e:
                    e[&#34;size&#34;] = e[&#34;w&#34;]
            for k, t in key_config.items():
                if k in e and not isinstance(e[k], t):
                    # pylint: disable=no-member
                    ttype = (
                        t.__name__
                        if isinstance(t, type)
                        else &#34; or &#34;.join([f&#34;&#39;{x.__name__}&#39;&#34; for x in t])
                    )
                    raise TypeError(
                        f&#34;Value of element item &#39;{k}&#39; must be {ttype}, not &#39;{type(e[k]).__name__}&#39;.&#34;
                    )
            self.keys.append(e[&#34;name&#34;].lower())

    @staticmethod
    def _parse_colorcode(s):
        &#34;&#34;&#34;Allow hex and oct values for colors&#34;&#34;&#34;
        if s[:2] in [&#34;0x&#34;, &#34;0X&#34;]:
            return int(s, 16)
        if s[0] == &#34;0&#34;:
            return int(s, 8)
        return int(s)

    @staticmethod
    def _parse_multiline(s):
        i = int(s)
        if i &gt; 0:
            return True
        if i &lt; 0:
            return False
        return None

    def parse_csv(self, infile, delimiter=&#34;,&#34;, decimal_sep=&#34;.&#34;, encoding=None):
        &#34;&#34;&#34;
        Load the template definition from a CSV file.

        Arguments:

            infile (string):
                The filename of the CSV file.

            delimiter (single character):
                The character that seperates the fields in the CSV file:
                Usually a comma, semicolon, or tab.

            decimal_sep (single character):
                The decimal separator used in the file.
                Usually either a point or a comma.

            encoding (string):
                The character encoding of the file.
                Default is the system default encoding.

        &#34;&#34;&#34;

        def _varsep_float(s, default=&#34;0&#34;):
            &#34;&#34;&#34;Convert to float with given decimal seperator&#34;&#34;&#34;
            # glad to have nonlocal scoping...
            return float((s.strip() or default).replace(decimal_sep, &#34;.&#34;))

        key_config = (
            # key, converter, mandatory
            (&#34;name&#34;, str, True),
            (&#34;type&#34;, str, True),
            (&#34;x1&#34;, _varsep_float, True),
            (&#34;y1&#34;, _varsep_float, True),
            (&#34;x2&#34;, _varsep_float, True),
            (&#34;y2&#34;, _varsep_float, True),
            (&#34;font&#34;, str, False),
            (&#34;size&#34;, _varsep_float, False),
            (&#34;bold&#34;, int, False),
            (&#34;italic&#34;, int, False),
            (&#34;underline&#34;, int, False),
            (&#34;foreground&#34;, self._parse_colorcode, False),
            (&#34;background&#34;, self._parse_colorcode, False),
            (&#34;align&#34;, str, False),
            (&#34;text&#34;, str, False),
            (&#34;priority&#34;, int, False),
            (&#34;multiline&#34;, self._parse_multiline, False),
            (&#34;rotate&#34;, _varsep_float, False),
        )
        self.elements = []
        if encoding is None:
            encoding = locale.getpreferredencoding()
        with open(infile, encoding=encoding) as f:
            for row in csv.reader(f, delimiter=delimiter):
                # fill in blanks for any missing items
                row.extend([&#34;&#34;] * (len(key_config) - len(row)))
                kargs = {}
                for val, cfg in zip(row, key_config):
                    vs = val.strip()
                    if not vs:
                        if cfg[2]:  # mandatory
                            if cfg[0] == &#34;x2&#34; and row[1] in [&#34;BC&#34;, &#34;C39&#34;]:
                                # two types don&#39;t need x2, but offset rendering does
                                pass
                            else:
                                raise FPDFException(
                                    f&#34;Mandatory value &#39;{cfg[0]}&#39; missing in csv data&#34;
                                )
                        elif cfg[0] == &#34;priority&#34;:
                            # formally optional, but we need some value for sorting
                            kargs[&#34;priority&#34;] = 0
                        # otherwise, let the type handlers use their own defaults
                    else:
                        kargs[cfg[0]] = cfg[1](vs)
                self.elements.append(kargs)
        self.keys = [val[&#34;name&#34;].lower() for val in self.elements]

    def __setitem__(self, name, value):
        assert isinstance(
            name, str
        ), f&#34;name must be of type &#39;str&#39;, not &#39;{type(name).__name__}&#39;.&#34;
        # value has too many valid types to reasonably check here
        if name.lower() not in self.keys:
            raise FPDFException(f&#34;Element not loaded, cannot set item: {name}&#34;)
        self.texts[name.lower()] = value

    # setitem shortcut (may be further extended)
    set = __setitem__

    def __contains__(self, name):
        assert isinstance(
            name, str
        ), f&#34;name must be of type &#39;str&#39;, not &#39;{type(name).__name__}&#39;.&#34;
        return name.lower() in self.keys

    def __getitem__(self, name):
        assert isinstance(
            name, str
        ), f&#34;name must be of type &#39;str&#39;, not &#39;{type(name).__name__}&#39;.&#34;
        if name not in self.keys:
            raise KeyError(name)
        key = name.lower()
        if key in self.texts:
            # text for this page:
            return self.texts[key]
        # find first element for default text:
        return next(
            (x[&#34;text&#34;] for x in self.elements if x[&#34;name&#34;].lower() == key), None
        )

    def split_multicell(self, text, element_name):
        &#34;&#34;&#34;
        Split a string between words, for the parts to fit into a given element
        width. Additional splits will be made replacing any &#39;\\n&#39; characters.

        Arguments:

            text (string):
                The input text string.

            element_name (string):
                The name of the template element to fit the text inside.

        Returns:
            A list of substrings, each of which will fit into the element width
            when rendered in the element font style and size.
        &#34;&#34;&#34;
        element = next(
            element
            for element in self.elements
            if element[&#34;name&#34;].lower() == element_name.lower()
        )
        if not self.splitting_pdf:
            self.splitting_pdf = FPDF()
            self.splitting_pdf.add_page()
        style = &#34;&#34;
        if element.get(&#34;bold&#34;):
            style += &#34;B&#34;
        if element.get(&#34;italic&#34;):
            style += &#34;I&#34;
        if element.get(&#34;underline&#34;):
            style += &#34;U&#34;
        self.splitting_pdf.set_font(element[&#34;font&#34;], style, element[&#34;size&#34;])
        return self.splitting_pdf.multi_cell(
            w=element[&#34;x2&#34;] - element[&#34;x1&#34;],
            h=element[&#34;y2&#34;] - element[&#34;y1&#34;],
            txt=str(text),
            align=element.get(&#34;align&#34;, &#34;&#34;),
            split_only=True,
        )

    def _text(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;helvetica&#34;,
        size=10,
        scale=1.0,
        bold=False,
        italic=False,
        underline=False,
        align=&#34;&#34;,
        foreground=0,
        background=None,
        multiline=None,
        **__,
    ):
        if not text:
            return
        pdf = self.pdf
        if pdf.text_color != _rgb_as_str(foreground):
            pdf.set_text_color(*_rgb(foreground))
        if background is None:
            fill = False
        else:
            fill = True
            if pdf.fill_color != _rgb_as_str(background):
                pdf.set_fill_color(*_rgb(background))

        font = font.strip().lower()
        style = &#34;&#34;
        for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
            if text.startswith(f&#34;&lt;{tag}&gt;&#34;) and text.endswith(f&#34;&lt;/{tag}&gt;&#34;):
                text = text[3:-4]
                style += tag
        if bold:
            style += &#34;B&#34;
        if italic:
            style += &#34;I&#34;
        if underline:
            style += &#34;U&#34;
        pdf.set_font(font, style, size * scale)
        pdf.set_xy(x1, y1)
        width, height = x2 - x1, y2 - y1
        if multiline is None:  # write without wrapping/trimming (default)
            pdf.cell(w=width, h=height, txt=text, border=0, align=align, fill=fill)
        elif multiline:  # automatic word - warp
            pdf.multi_cell(
                w=width, h=height, txt=text, border=0, align=align, fill=fill
            )
        else:  # trim to fit exactly the space defined
            text = pdf.multi_cell(
                w=width, h=height, txt=text, align=align, split_only=True
            )[0]
            pdf.cell(w=width, h=height, txt=text, border=0, align=align, fill=fill)

    def _line(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        size=0,
        scale=1.0,
        foreground=0,
        **__,
    ):
        if self.pdf.draw_color.serialize().lower() != _rgb_as_str(foreground):
            self.pdf.set_draw_color(*_rgb(foreground))
        self.pdf.set_line_width(size * scale)
        self.pdf.line(x1, y1, x2, y2)

    def _rect(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        size=0,
        scale=1.0,
        foreground=0,
        background=None,
        **__,
    ):
        pdf = self.pdf
        if pdf.draw_color.serialize().lower() != _rgb_as_str(foreground):
            pdf.set_draw_color(*_rgb(foreground))
        if background is None:
            style = &#34;D&#34;
        else:
            style = &#34;FD&#34;
            if pdf.fill_color != _rgb_as_str(background):
                pdf.set_fill_color(*_rgb(background))
        pdf.set_line_width(size * scale)
        pdf.rect(x1, y1, x2 - x1, y2 - y1, style=style)

    def _ellipse(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        size=0,
        scale=1.0,
        foreground=0,
        background=None,
        **__,
    ):
        pdf = self.pdf
        if pdf.draw_color.serialize().lower() != _rgb_as_str(foreground):
            pdf.set_draw_color(*_rgb(foreground))
        if background is None:
            style = &#34;D&#34;
        else:
            style = &#34;FD&#34;
            if pdf.fill_color != _rgb_as_str(background):
                pdf.set_fill_color(*_rgb(background))
        pdf.set_line_width(size * scale)
        pdf.ellipse(x1, y1, x2 - x1, y2 - y1, style=style)

    def _image(self, *_, x1=0, y1=0, x2=0, y2=0, text=&#34;&#34;, **__):
        if text:
            self.pdf.image(text, x1, y1, w=x2 - x1, h=y2 - y1, link=&#34;&#34;)

    def _barcode(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;interleaved 2of5 nt&#34;,
        size=1,
        scale=1.0,
        foreground=0,
        **__,
    ):
        # pylint: disable=unused-argument
        pdf = self.pdf
        if pdf.fill_color.serialize().lower() != _rgb_as_str(foreground):
            pdf.set_fill_color(*_rgb(foreground))
        font = font.lower().strip()
        if font == &#34;interleaved 2of5 nt&#34;:
            pdf.interleaved2of5(text, x1, y1, w=size * scale, h=y2 - y1)

    def _code39(
        self,
        *_,
        x1=0,
        y1=0,
        y2=0,
        text=&#34;&#34;,
        size=1.5,
        scale=1.0,
        foreground=0,
        x=None,
        y=None,
        w=None,
        h=None,
        **__,
    ):
        if x is not None or y is not None or w is not None or h is not None:
            warnings.warn(
                &#34;code39 arguments x/y/w/h are deprecated, please use x1/y1/y2/size instead&#34;,
                DeprecationWarning,
                stacklevel=2,
            )
        pdf = self.pdf
        if pdf.fill_color.serialize().lower() != _rgb_as_str(foreground):
            pdf.set_fill_color(*_rgb(foreground))
        h = y2 - y1
        if h &lt;= 0:
            h = 5
        pdf.code39(text, x1, y1, size * scale, h)

    # Added by Derek Schwalenberg Schwalenberg1013@gmail.com to allow (url) links in
    # templates (using write method) 2014-02-22
    def _write(
        self,
        *_,
        x1=0,
        y1=0,
        x2=0,
        y2=0,
        text=&#34;&#34;,
        font=&#34;helvetica&#34;,
        size=10,
        scale=1.0,
        bold=False,
        italic=False,
        underline=False,
        link=&#34;&#34;,
        foreground=0,
        **__,
    ):
        # pylint: disable=unused-argument
        if not text:
            return
        pdf = self.pdf
        if pdf.text_color != _rgb_as_str(foreground):
            pdf.set_text_color(*_rgb(foreground))
        font = font.strip().lower()
        style = &#34;&#34;
        for tag in &#34;B&#34;, &#34;I&#34;, &#34;U&#34;:
            if text.startswith(f&#34;&lt;{tag}&gt;&#34;) and text.endswith(f&#34;&lt;/{tag}&gt;&#34;):
                text = text[3:-4]
                style += tag
        if bold:
            style += &#34;B&#34;
        if italic:
            style += &#34;I&#34;
        if underline:
            style += &#34;U&#34;
        pdf.set_font(font, style, size * scale)
        pdf.set_xy(x1, y1)
        pdf.write(5, text, link)

    def render(self, offsetx=0.0, offsety=0.0, rotate=0.0, scale=1.0):
        &#34;&#34;&#34;
        Add the contents of the template to the PDF document.

        Arguments:

            offsetx, offsety (float):
                Place the template to move its origin to the given coordinates.

            rotate (float):
                Rotate the inserted template around its (offset) origin.

            scale (float):
                Scale the inserted template by this factor.
        &#34;&#34;&#34;
        sorted_elements = sorted(self.elements, key=lambda x: x[&#34;priority&#34;])
        with self.pdf.local_context():
            for element in sorted_elements:
                ele = element.copy()  # don&#39;t want to modify the callers original
                ele[&#34;text&#34;] = self.texts.get(ele[&#34;name&#34;].lower(), ele.get(&#34;text&#34;, &#34;&#34;))
                if scale != 1.0:
                    ele[&#34;x1&#34;] = ele[&#34;x1&#34;] * scale
                    ele[&#34;y1&#34;] = ele[&#34;y1&#34;] * scale
                    ele[&#34;x2&#34;] = ele[&#34;x1&#34;] + ((ele[&#34;x2&#34;] - element[&#34;x1&#34;]) * scale)
                    ele[&#34;y2&#34;] = ele[&#34;y1&#34;] + ((ele[&#34;y2&#34;] - element[&#34;y1&#34;]) * scale)
                if offsetx:
                    ele[&#34;x1&#34;] = ele[&#34;x1&#34;] + offsetx
                    ele[&#34;x2&#34;] = ele[&#34;x2&#34;] + offsetx
                if offsety:
                    ele[&#34;y1&#34;] = ele[&#34;y1&#34;] + offsety
                    ele[&#34;y2&#34;] = ele[&#34;y2&#34;] + offsety
                ele[&#34;scale&#34;] = scale
                handler_name = ele[&#34;type&#34;].upper()
                if rotate:  # don&#39;t rotate by 0.0 degrees
                    with self.pdf.rotation(rotate, offsetx, offsety):
                        if &#34;rotate&#34; in ele and ele[&#34;rotate&#34;]:
                            with self.pdf.rotation(ele[&#34;rotate&#34;], ele[&#34;x1&#34;], ele[&#34;y1&#34;]):
                                self.handlers[handler_name](**ele)
                        else:
                            self.handlers[handler_name](**ele)
                else:
                    if &#34;rotate&#34; in ele and ele[&#34;rotate&#34;]:
                        with self.pdf.rotation(ele[&#34;rotate&#34;], ele[&#34;x1&#34;], ele[&#34;y1&#34;]):
                            self.handlers[handler_name](**ele)
                    else:
                        self.handlers[handler_name](**ele)
        self.texts = {}  # reset modified entries for the next page</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fpdf.template.Template" href="#fpdf.template.Template">Template</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.template.FlexTemplate.load_elements"><code class="name flex">
<span>def <span class="ident">load_elements</span></span>(<span>self, elements)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a template definition.</p>
<h2 id="arguments">Arguments</h2>
<p>elements (list of dicts):
A template definition in a list of dicts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_elements(self, elements):
    &#34;&#34;&#34;
    Load a template definition.

    Arguments:

        elements (list of dicts):
            A template definition in a list of dicts
    &#34;&#34;&#34;
    key_config = {
        # key: type
        &#34;name&#34;: (str, type(None)),
        &#34;type&#34;: (str, type(None)),
        &#34;x1&#34;: (int, float),
        &#34;y1&#34;: (int, float),
        &#34;x2&#34;: (int, float),
        &#34;y2&#34;: (int, float),
        &#34;font&#34;: (str, type(None)),
        &#34;size&#34;: (int, float),
        &#34;bold&#34;: object,  # &#34;bool or equivalent&#34;
        &#34;italic&#34;: object,
        &#34;underline&#34;: object,
        &#34;foreground&#34;: int,
        &#34;background&#34;: int,
        &#34;align&#34;: (str, type(None)),
        &#34;text&#34;: (str, type(None)),
        &#34;priority&#34;: int,
        &#34;multiline&#34;: (bool, type(None)),
        &#34;rotate&#34;: (int, float),
    }

    self.elements = elements
    self.keys = []
    for e in elements:
        # priority is optional, but we need a default for sorting.
        if not &#34;priority&#34; in e:
            e[&#34;priority&#34;] = 0
        for k in (&#34;name&#34;, &#34;type&#34;, &#34;x1&#34;, &#34;y1&#34;, &#34;y2&#34;):
            if k not in e:
                if e[&#34;type&#34;] == &#34;C39&#34;:
                    # lots of legacy special casing.
                    # We need to do that here, so that rotation and scaling
                    # still work.
                    if k == &#34;x1&#34; and &#34;x&#34; in e:
                        e[&#34;x1&#34;] = e[&#34;x&#34;]
                        continue
                    if k == &#34;y1&#34; and &#34;y&#34; in e:
                        e[&#34;y1&#34;] = e[&#34;y&#34;]
                        continue
                    if k == &#34;y2&#34; and &#34;h&#34; in e:
                        e[&#34;y2&#34;] = e[&#34;y1&#34;] + e[&#34;h&#34;]
                        continue
                raise KeyError(f&#34;Mandatory key &#39;{k}&#39; missing in input data&#34;)
        # x2 is optional for barcode types, but needed for offset rendering
        if &#34;x2&#34; not in e:
            if e[&#34;type&#34;] in [&#34;BC&#34;, &#34;C39&#34;]:
                e[&#34;x2&#34;] = 0
            else:
                raise KeyError(&#34;Mandatory key &#39;x2&#39; missing in input data&#34;)
        if not &#34;size&#34; in e and e[&#34;type&#34;] == &#34;C39&#34;:
            if &#34;w&#34; in e:
                e[&#34;size&#34;] = e[&#34;w&#34;]
        for k, t in key_config.items():
            if k in e and not isinstance(e[k], t):
                # pylint: disable=no-member
                ttype = (
                    t.__name__
                    if isinstance(t, type)
                    else &#34; or &#34;.join([f&#34;&#39;{x.__name__}&#39;&#34; for x in t])
                )
                raise TypeError(
                    f&#34;Value of element item &#39;{k}&#39; must be {ttype}, not &#39;{type(e[k]).__name__}&#39;.&#34;
                )
        self.keys.append(e[&#34;name&#34;].lower())</code></pre>
</details>
</dd>
<dt id="fpdf.template.FlexTemplate.parse_csv"><code class="name flex">
<span>def <span class="ident">parse_csv</span></span>(<span>self, infile, delimiter=',', decimal_sep='.', encoding=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the template definition from a CSV file.</p>
<h2 id="arguments">Arguments</h2>
<p>infile (string):
The filename of the CSV file.</p>
<p>delimiter (single character):
The character that seperates the fields in the CSV file:
Usually a comma, semicolon, or tab.</p>
<p>decimal_sep (single character):
The decimal separator used in the file.
Usually either a point or a comma.</p>
<p>encoding (string):
The character encoding of the file.
Default is the system default encoding.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_csv(self, infile, delimiter=&#34;,&#34;, decimal_sep=&#34;.&#34;, encoding=None):
    &#34;&#34;&#34;
    Load the template definition from a CSV file.

    Arguments:

        infile (string):
            The filename of the CSV file.

        delimiter (single character):
            The character that seperates the fields in the CSV file:
            Usually a comma, semicolon, or tab.

        decimal_sep (single character):
            The decimal separator used in the file.
            Usually either a point or a comma.

        encoding (string):
            The character encoding of the file.
            Default is the system default encoding.

    &#34;&#34;&#34;

    def _varsep_float(s, default=&#34;0&#34;):
        &#34;&#34;&#34;Convert to float with given decimal seperator&#34;&#34;&#34;
        # glad to have nonlocal scoping...
        return float((s.strip() or default).replace(decimal_sep, &#34;.&#34;))

    key_config = (
        # key, converter, mandatory
        (&#34;name&#34;, str, True),
        (&#34;type&#34;, str, True),
        (&#34;x1&#34;, _varsep_float, True),
        (&#34;y1&#34;, _varsep_float, True),
        (&#34;x2&#34;, _varsep_float, True),
        (&#34;y2&#34;, _varsep_float, True),
        (&#34;font&#34;, str, False),
        (&#34;size&#34;, _varsep_float, False),
        (&#34;bold&#34;, int, False),
        (&#34;italic&#34;, int, False),
        (&#34;underline&#34;, int, False),
        (&#34;foreground&#34;, self._parse_colorcode, False),
        (&#34;background&#34;, self._parse_colorcode, False),
        (&#34;align&#34;, str, False),
        (&#34;text&#34;, str, False),
        (&#34;priority&#34;, int, False),
        (&#34;multiline&#34;, self._parse_multiline, False),
        (&#34;rotate&#34;, _varsep_float, False),
    )
    self.elements = []
    if encoding is None:
        encoding = locale.getpreferredencoding()
    with open(infile, encoding=encoding) as f:
        for row in csv.reader(f, delimiter=delimiter):
            # fill in blanks for any missing items
            row.extend([&#34;&#34;] * (len(key_config) - len(row)))
            kargs = {}
            for val, cfg in zip(row, key_config):
                vs = val.strip()
                if not vs:
                    if cfg[2]:  # mandatory
                        if cfg[0] == &#34;x2&#34; and row[1] in [&#34;BC&#34;, &#34;C39&#34;]:
                            # two types don&#39;t need x2, but offset rendering does
                            pass
                        else:
                            raise FPDFException(
                                f&#34;Mandatory value &#39;{cfg[0]}&#39; missing in csv data&#34;
                            )
                    elif cfg[0] == &#34;priority&#34;:
                        # formally optional, but we need some value for sorting
                        kargs[&#34;priority&#34;] = 0
                    # otherwise, let the type handlers use their own defaults
                else:
                    kargs[cfg[0]] = cfg[1](vs)
            self.elements.append(kargs)
    self.keys = [val[&#34;name&#34;].lower() for val in self.elements]</code></pre>
</details>
</dd>
<dt id="fpdf.template.FlexTemplate.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, offsetx=0.0, offsety=0.0, rotate=0.0, scale=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the contents of the template to the PDF document.</p>
<h2 id="arguments">Arguments</h2>
<p>offsetx, offsety (float):
Place the template to move its origin to the given coordinates.</p>
<p>rotate (float):
Rotate the inserted template around its (offset) origin.</p>
<p>scale (float):
Scale the inserted template by this factor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, offsetx=0.0, offsety=0.0, rotate=0.0, scale=1.0):
    &#34;&#34;&#34;
    Add the contents of the template to the PDF document.

    Arguments:

        offsetx, offsety (float):
            Place the template to move its origin to the given coordinates.

        rotate (float):
            Rotate the inserted template around its (offset) origin.

        scale (float):
            Scale the inserted template by this factor.
    &#34;&#34;&#34;
    sorted_elements = sorted(self.elements, key=lambda x: x[&#34;priority&#34;])
    with self.pdf.local_context():
        for element in sorted_elements:
            ele = element.copy()  # don&#39;t want to modify the callers original
            ele[&#34;text&#34;] = self.texts.get(ele[&#34;name&#34;].lower(), ele.get(&#34;text&#34;, &#34;&#34;))
            if scale != 1.0:
                ele[&#34;x1&#34;] = ele[&#34;x1&#34;] * scale
                ele[&#34;y1&#34;] = ele[&#34;y1&#34;] * scale
                ele[&#34;x2&#34;] = ele[&#34;x1&#34;] + ((ele[&#34;x2&#34;] - element[&#34;x1&#34;]) * scale)
                ele[&#34;y2&#34;] = ele[&#34;y1&#34;] + ((ele[&#34;y2&#34;] - element[&#34;y1&#34;]) * scale)
            if offsetx:
                ele[&#34;x1&#34;] = ele[&#34;x1&#34;] + offsetx
                ele[&#34;x2&#34;] = ele[&#34;x2&#34;] + offsetx
            if offsety:
                ele[&#34;y1&#34;] = ele[&#34;y1&#34;] + offsety
                ele[&#34;y2&#34;] = ele[&#34;y2&#34;] + offsety
            ele[&#34;scale&#34;] = scale
            handler_name = ele[&#34;type&#34;].upper()
            if rotate:  # don&#39;t rotate by 0.0 degrees
                with self.pdf.rotation(rotate, offsetx, offsety):
                    if &#34;rotate&#34; in ele and ele[&#34;rotate&#34;]:
                        with self.pdf.rotation(ele[&#34;rotate&#34;], ele[&#34;x1&#34;], ele[&#34;y1&#34;]):
                            self.handlers[handler_name](**ele)
                    else:
                        self.handlers[handler_name](**ele)
            else:
                if &#34;rotate&#34; in ele and ele[&#34;rotate&#34;]:
                    with self.pdf.rotation(ele[&#34;rotate&#34;], ele[&#34;x1&#34;], ele[&#34;y1&#34;]):
                        self.handlers[handler_name](**ele)
                else:
                    self.handlers[handler_name](**ele)
    self.texts = {}  # reset modified entries for the next page</code></pre>
</details>
</dd>
<dt id="fpdf.template.FlexTemplate.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __setitem__(self, name, value):
    assert isinstance(
        name, str
    ), f&#34;name must be of type &#39;str&#39;, not &#39;{type(name).__name__}&#39;.&#34;
    # value has too many valid types to reasonably check here
    if name.lower() not in self.keys:
        raise FPDFException(f&#34;Element not loaded, cannot set item: {name}&#34;)
    self.texts[name.lower()] = value</code></pre>
</details>
</dd>
<dt id="fpdf.template.FlexTemplate.split_multicell"><code class="name flex">
<span>def <span class="ident">split_multicell</span></span>(<span>self, text, element_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Split a string between words, for the parts to fit into a given element
width. Additional splits will be made replacing any '\n' characters.</p>
<h2 id="arguments">Arguments</h2>
<p>text (string):
The input text string.</p>
<p>element_name (string):
The name of the template element to fit the text inside.</p>
<h2 id="returns">Returns</h2>
<p>A list of substrings, each of which will fit into the element width
when rendered in the element font style and size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_multicell(self, text, element_name):
    &#34;&#34;&#34;
    Split a string between words, for the parts to fit into a given element
    width. Additional splits will be made replacing any &#39;\\n&#39; characters.

    Arguments:

        text (string):
            The input text string.

        element_name (string):
            The name of the template element to fit the text inside.

    Returns:
        A list of substrings, each of which will fit into the element width
        when rendered in the element font style and size.
    &#34;&#34;&#34;
    element = next(
        element
        for element in self.elements
        if element[&#34;name&#34;].lower() == element_name.lower()
    )
    if not self.splitting_pdf:
        self.splitting_pdf = FPDF()
        self.splitting_pdf.add_page()
    style = &#34;&#34;
    if element.get(&#34;bold&#34;):
        style += &#34;B&#34;
    if element.get(&#34;italic&#34;):
        style += &#34;I&#34;
    if element.get(&#34;underline&#34;):
        style += &#34;U&#34;
    self.splitting_pdf.set_font(element[&#34;font&#34;], style, element[&#34;size&#34;])
    return self.splitting_pdf.multi_cell(
        w=element[&#34;x2&#34;] - element[&#34;x1&#34;],
        h=element[&#34;y2&#34;] - element[&#34;y1&#34;],
        txt=str(text),
        align=element.get(&#34;align&#34;, &#34;&#34;),
        split_only=True,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.template.Template"><code class="flex name class">
<span>class <span class="ident">Template</span></span>
<span>(</span><span>infile=None, elements=None, format='A4', orientation='portrait', unit='mm', title='', author='', subject='', creator='', keywords='')</span>
</code></dt>
<dd>
<div class="desc"><p>A simple templating class.</p>
<p>Allows to apply a single template definition to all pages of a document.</p>
<h2 id="arguments">Arguments</h2>
<p>infile (str):
[<strong>DEPRECATED since 2.2.0</strong>] unused, will be removed in a later version</p>
<p>elements (list of dicts):
A template definition in a list of dicts.
If you omit this, then you need to call either load_elements()
or parse_csv() before doing anything else.</p>
<p>format (str):
The page format of the document (eg. "A4" or "letter").</p>
<p>orientation (str):
The orientation of the document.
Possible values are "portrait"/"P" or "landscape"/"L"</p>
<p>unit (str):
The units used in the template definition.
One of "mm", "cm", "in", "pt", or a number for points per unit.</p>
<p>title (str): The title of the document.</p>
<p>author (str): The author of the document.</p>
<p>subject (str): The subject matter of the document.</p>
<p>creator (str): The creator of the document.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Template(FlexTemplate):
    &#34;&#34;&#34;
    A simple templating class.

    Allows to apply a single template definition to all pages of a document.
    &#34;&#34;&#34;

    # Disabling this check due to the &#34;format&#34; parameter below:
    # pylint: disable=redefined-builtin
    # pylint: disable=unused-argument
    def __init__(
        self,
        infile=None,
        elements=None,
        format=&#34;A4&#34;,
        orientation=&#34;portrait&#34;,
        unit=&#34;mm&#34;,
        title=&#34;&#34;,
        author=&#34;&#34;,
        subject=&#34;&#34;,
        creator=&#34;&#34;,
        keywords=&#34;&#34;,
    ):
        &#34;&#34;&#34;
        Arguments:

            infile (str):
                [**DEPRECATED since 2.2.0**] unused, will be removed in a later version

            elements (list of dicts):
                A template definition in a list of dicts.
                If you omit this, then you need to call either load_elements()
                or parse_csv() before doing anything else.

            format (str):
                The page format of the document (eg. &#34;A4&#34; or &#34;letter&#34;).

            orientation (str):
                The orientation of the document.
                Possible values are &#34;portrait&#34;/&#34;P&#34; or &#34;landscape&#34;/&#34;L&#34;

            unit (str):
                The units used in the template definition.
                One of &#34;mm&#34;, &#34;cm&#34;, &#34;in&#34;, &#34;pt&#34;, or a number for points per unit.

            title (str): The title of the document.

            author (str): The author of the document.

            subject (str): The subject matter of the document.

            creator (str): The creator of the document.
        &#34;&#34;&#34;
        if infile:
            warnings.warn(
                &#39;&#34;infile&#34; is deprecated, unused and will soon be removed&#39;,
                DeprecationWarning,
                stacklevel=2,
            )
        for arg in (
            &#34;format&#34;,
            &#34;orientation&#34;,
            &#34;unit&#34;,
            &#34;title&#34;,
            &#34;author&#34;,
            &#34;subject&#34;,
            &#34;creator&#34;,
            &#34;keywords&#34;,
        ):
            # nosemgrep: python.lang.security.dangerous-globals-use.dangerous-globals-use
            if not isinstance(locals()[arg], str):
                raise TypeError(f&#39;Argument &#34;{arg}&#34; must be of type str.&#39;)
        pdf = FPDF(format=format, orientation=orientation, unit=unit)
        pdf.set_title(title)
        pdf.set_author(author)
        pdf.set_creator(creator)
        pdf.set_subject(subject)
        pdf.set_keywords(keywords)
        super().__init__(pdf=pdf, elements=elements)

    def add_page(self):
        &#34;&#34;&#34;Finish the current page, and proceed to the next one.&#34;&#34;&#34;
        if self.pdf.page:
            self.render()
        self.pdf.add_page()

    # pylint: disable=arguments-differ
    def render(self, outfile=None, dest=None):
        &#34;&#34;&#34;
        Finish the document and process all pending data.

        Arguments:

            outfile (str):
                If given, the PDF file will be written to this file name.
                Alternatively, the `.pdf.output()` method can be manually called.

            dest (str):
                [**DEPRECATED since 2.2.0**] unused, will be removed in a later version.
        &#34;&#34;&#34;
        if dest:
            warnings.warn(
                &#39;&#34;dest&#34; is deprecated, unused and will soon be removed&#39;,
                DeprecationWarning,
                stacklevel=2,
            )
        self.pdf.set_font(&#34;helvetica&#34;, &#34;B&#34;, 16)
        self.pdf.set_auto_page_break(False, margin=0)
        super().render()
        if outfile:
            self.pdf.output(outfile)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.template.FlexTemplate" href="#fpdf.template.FlexTemplate">FlexTemplate</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="fpdf.template.Template.add_page"><code class="name flex">
<span>def <span class="ident">add_page</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finish the current page, and proceed to the next one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_page(self):
    &#34;&#34;&#34;Finish the current page, and proceed to the next one.&#34;&#34;&#34;
    if self.pdf.page:
        self.render()
    self.pdf.add_page()</code></pre>
</details>
</dd>
<dt id="fpdf.template.Template.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, outfile=None, dest=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Finish the document and process all pending data.</p>
<h2 id="arguments">Arguments</h2>
<p>outfile (str):
If given, the PDF file will be written to this file name.
Alternatively, the <code>.pdf.output()</code> method can be manually called.</p>
<p>dest (str):
[<strong>DEPRECATED since 2.2.0</strong>] unused, will be removed in a later version.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render(self, outfile=None, dest=None):
    &#34;&#34;&#34;
    Finish the document and process all pending data.

    Arguments:

        outfile (str):
            If given, the PDF file will be written to this file name.
            Alternatively, the `.pdf.output()` method can be manually called.

        dest (str):
            [**DEPRECATED since 2.2.0**] unused, will be removed in a later version.
    &#34;&#34;&#34;
    if dest:
        warnings.warn(
            &#39;&#34;dest&#34; is deprecated, unused and will soon be removed&#39;,
            DeprecationWarning,
            stacklevel=2,
        )
    self.pdf.set_font(&#34;helvetica&#34;, &#34;B&#34;, 16)
    self.pdf.set_auto_page_break(False, margin=0)
    super().render()
    if outfile:
        self.pdf.output(outfile)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fpdf.template.FlexTemplate" href="#fpdf.template.FlexTemplate">FlexTemplate</a></b></code>:
<ul class="hlist">
<li><code><a title="fpdf.template.FlexTemplate.load_elements" href="#fpdf.template.FlexTemplate.load_elements">load_elements</a></code></li>
<li><code><a title="fpdf.template.FlexTemplate.parse_csv" href="#fpdf.template.FlexTemplate.parse_csv">parse_csv</a></code></li>
<li><code><a title="fpdf.template.FlexTemplate.split_multicell" href="#fpdf.template.FlexTemplate.split_multicell">split_multicell</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.template.FlexTemplate" href="#fpdf.template.FlexTemplate">FlexTemplate</a></code></h4>
<ul class="">
<li><code><a title="fpdf.template.FlexTemplate.load_elements" href="#fpdf.template.FlexTemplate.load_elements">load_elements</a></code></li>
<li><code><a title="fpdf.template.FlexTemplate.parse_csv" href="#fpdf.template.FlexTemplate.parse_csv">parse_csv</a></code></li>
<li><code><a title="fpdf.template.FlexTemplate.render" href="#fpdf.template.FlexTemplate.render">render</a></code></li>
<li><code><a title="fpdf.template.FlexTemplate.set" href="#fpdf.template.FlexTemplate.set">set</a></code></li>
<li><code><a title="fpdf.template.FlexTemplate.split_multicell" href="#fpdf.template.FlexTemplate.split_multicell">split_multicell</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.template.Template" href="#fpdf.template.Template">Template</a></code></h4>
<ul class="">
<li><code><a title="fpdf.template.Template.add_page" href="#fpdf.template.Template.add_page">add_page</a></code></li>
<li><code><a title="fpdf.template.Template.render" href="#fpdf.template.Template.render">render</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>