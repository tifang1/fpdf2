<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fpdf.html API documentation</title>
<meta name="description" content="HTML renderer â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.html</code></h1>
</header>
<section id="section-intro">
<p>HTML renderer</p>
<p>The contents of this module are internal to fpdf2, and not part of the public API.
They may change at any time without prior warning or any deprecation period,
in non-backward-compatible ways.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L1-L827" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
HTML renderer

The contents of this module are internal to fpdf2, and not part of the public API.
They may change at any time without prior warning or any deprecation period,
in non-backward-compatible ways.
&#34;&#34;&#34;

from html.parser import HTMLParser
import logging, re, warnings

from .enums import TextEmphasis, XPos, YPos
from .errors import FPDFException
from .deprecation import get_stack_level
from .fonts import FontFace
from .table import Table, TableBordersLayout

LOGGER = logging.getLogger(__name__)
BULLET_WIN1252 = &#34;\x95&#34;  # BULLET character in Windows-1252 encoding
DEFAULT_HEADING_SIZES = dict(h1=24, h2=18, h3=14, h4=12, h5=10, h6=8)

# Pattern to substitute whitespace sequences with a single space character each.
# The following are all Unicode characters with White_Space classification plus the newline.
# The pattern excludes the non-breaking spaces that are included in &#34;\s&#34;.
# We also exclude the OGHAM SPACE MARK for now, because while being a word separator,
# it is usually a graphically visible glyph.
_WS_CHARS = &#34;&#34;.join(
    (
        # &#34;\u0009&#34;,  # CHARACTER TABULATION
        # &#34;\u000a&#34;,  # LINE FEED
        # &#34;\u000b&#34;,  # LINE TABULATION
        # &#34;\u000c&#34;,  # FORM FEED
        # &#34;\u000d&#34;,  # CARRIAGE RETURN
        &#34;\u0009-\u000d&#34;,  # combine the above
        &#34;\u0020&#34;,  # SPACE
        &#34;\u0085&#34;,  # NEXT LINE
        # &#34;\u00a0&#34;,  # NO-BREAK SPACE   (keep)
        # &#34;\u1680&#34;,  # OGHAM SPACE MARK (not actually white)
        # &#34;\u2000&#34;,  # EN QUAD
        # &#34;\u2001&#34;,  # EM QUAD
        # &#34;\u2002&#34;,  # EN SPACE
        # &#34;\u2003&#34;,  # EM SPACE
        # &#34;\u2004&#34;,  # THREE-PER-EM SPACE
        # &#34;\u2005&#34;,  # FOUR-PER-EM SPACE
        # &#34;\u2006&#34;,  # SIX-PER-EM SPACE
        # &#34;\u2007&#34;,  # FIGURE SPACE
        # &#34;\u2008&#34;,  # PUNCTUATION SPACE
        # &#34;\u2009&#34;,  # THIN SPACE
        # &#34;\u200a&#34;,  # HAIR SPACE
        &#34;\u2000-\u200a&#34;,  # combine the above
        &#34;\u2028&#34;,  # LINE SEPARATOR
        &#34;\u2029&#34;,  # PARAGRAPH SEPARATOR
        # &#34;\u202f&#34;,  # NARROW NO-BREAK SPACE (keep)
        &#34;\u205f&#34;,  # MEDIUM MATHEMATICAL SPACE
        &#34;\u3000&#34;,  # IDEOGRAPHIC SPACE
    )
)
_WS_SUB_PAT = re.compile(f&#34;[{_WS_CHARS}]+&#34;)

COLOR_DICT = {
    &#34;black&#34;: &#34;#000000&#34;,
    &#34;navy&#34;: &#34;#000080&#34;,
    &#34;darkblue&#34;: &#34;#00008b&#34;,
    &#34;mediumblue&#34;: &#34;#0000cd&#34;,
    &#34;blue&#34;: &#34;#0000ff&#34;,
    &#34;darkgreen&#34;: &#34;#006400&#34;,
    &#34;green&#34;: &#34;#008000&#34;,
    &#34;teal&#34;: &#34;#008080&#34;,
    &#34;darkcyan&#34;: &#34;#008b8b&#34;,
    &#34;deepskyblue&#34;: &#34;#00bfff&#34;,
    &#34;darkturquoise&#34;: &#34;#00ced1&#34;,
    &#34;mediumspringgreen&#34;: &#34;#00fa9a&#34;,
    &#34;lime&#34;: &#34;#00ff00&#34;,
    &#34;springgreen&#34;: &#34;#00ff7f&#34;,
    &#34;aqua&#34;: &#34;#00ffff&#34;,
    &#34;cyan&#34;: &#34;#00ffff&#34;,
    &#34;midnightblue&#34;: &#34;#191970&#34;,
    &#34;dodgerblue&#34;: &#34;#1e90ff&#34;,
    &#34;lightseagreen&#34;: &#34;#20b2aa&#34;,
    &#34;forestgreen&#34;: &#34;#228b22&#34;,
    &#34;seagreen&#34;: &#34;#2e8b57&#34;,
    &#34;darkslategray&#34;: &#34;#2f4f4f&#34;,
    &#34;darkslategrey&#34;: &#34;#2f4f4f&#34;,
    &#34;limegreen&#34;: &#34;#32cd32&#34;,
    &#34;mediumseagreen&#34;: &#34;#3cb371&#34;,
    &#34;turquoise&#34;: &#34;#40e0d0&#34;,
    &#34;royalblue&#34;: &#34;#4169e1&#34;,
    &#34;steelblue&#34;: &#34;#4682b4&#34;,
    &#34;darkslateblue&#34;: &#34;#483d8b&#34;,
    &#34;mediumturquoise&#34;: &#34;#48d1cc&#34;,
    &#34;indigo&#34;: &#34;#4b0082&#34;,
    &#34;darkolivegreen&#34;: &#34;#556b2f&#34;,
    &#34;cadetblue&#34;: &#34;#5f9ea0&#34;,
    &#34;cornflowerblue&#34;: &#34;#6495ed&#34;,
    &#34;rebeccapurple&#34;: &#34;#663399&#34;,
    &#34;mediumaquamarine&#34;: &#34;#66cdaa&#34;,
    &#34;dimgray&#34;: &#34;#696969&#34;,
    &#34;dimgrey&#34;: &#34;#696969&#34;,
    &#34;slateblue&#34;: &#34;#6a5acd&#34;,
    &#34;olivedrab&#34;: &#34;#6b8e23&#34;,
    &#34;slategray&#34;: &#34;#708090&#34;,
    &#34;slategrey&#34;: &#34;#708090&#34;,
    &#34;lightslategray&#34;: &#34;#778899&#34;,
    &#34;lightslategrey&#34;: &#34;#778899&#34;,
    &#34;mediumslateblue&#34;: &#34;#7b68ee&#34;,
    &#34;lawngreen&#34;: &#34;#7cfc00&#34;,
    &#34;chartreuse&#34;: &#34;#7fff00&#34;,
    &#34;aquamarine&#34;: &#34;#7fffd4&#34;,
    &#34;maroon&#34;: &#34;#800000&#34;,
    &#34;purple&#34;: &#34;#800080&#34;,
    &#34;olive&#34;: &#34;#808000&#34;,
    &#34;gray&#34;: &#34;#808080&#34;,
    &#34;grey&#34;: &#34;#808080&#34;,
    &#34;skyblue&#34;: &#34;#87ceeb&#34;,
    &#34;lightskyblue&#34;: &#34;#87cefa&#34;,
    &#34;blueviolet&#34;: &#34;#8a2be2&#34;,
    &#34;darkred&#34;: &#34;#8b0000&#34;,
    &#34;darkmagenta&#34;: &#34;#8b008b&#34;,
    &#34;saddlebrown&#34;: &#34;#8b4513&#34;,
    &#34;darkseagreen&#34;: &#34;#8fbc8f&#34;,
    &#34;lightgreen&#34;: &#34;#90ee90&#34;,
    &#34;mediumpurple&#34;: &#34;#9370db&#34;,
    &#34;darkviolet&#34;: &#34;#9400d3&#34;,
    &#34;palegreen&#34;: &#34;#98fb98&#34;,
    &#34;darkorchid&#34;: &#34;#9932cc&#34;,
    &#34;yellowgreen&#34;: &#34;#9acd32&#34;,
    &#34;sienna&#34;: &#34;#a0522d&#34;,
    &#34;brown&#34;: &#34;#a52a2a&#34;,
    &#34;darkgray&#34;: &#34;#a9a9a9&#34;,
    &#34;darkgrey&#34;: &#34;#a9a9a9&#34;,
    &#34;lightblue&#34;: &#34;#add8e6&#34;,
    &#34;greenyellow&#34;: &#34;#adff2f&#34;,
    &#34;paleturquoise&#34;: &#34;#afeeee&#34;,
    &#34;lightsteelblue&#34;: &#34;#b0c4de&#34;,
    &#34;powderblue&#34;: &#34;#b0e0e6&#34;,
    &#34;firebrick&#34;: &#34;#b22222&#34;,
    &#34;darkgoldenrod&#34;: &#34;#b8860b&#34;,
    &#34;mediumorchid&#34;: &#34;#ba55d3&#34;,
    &#34;rosybrown&#34;: &#34;#bc8f8f&#34;,
    &#34;darkkhaki&#34;: &#34;#bdb76b&#34;,
    &#34;silver&#34;: &#34;#c0c0c0&#34;,
    &#34;mediumvioletred&#34;: &#34;#c71585&#34;,
    &#34;indianred&#34;: &#34;#cd5c5c&#34;,
    &#34;peru&#34;: &#34;#cd853f&#34;,
    &#34;chocolate&#34;: &#34;#d2691e&#34;,
    &#34;tan&#34;: &#34;#d2b48c&#34;,
    &#34;lightgray&#34;: &#34;#d3d3d3&#34;,
    &#34;lightgrey&#34;: &#34;#d3d3d3&#34;,
    &#34;thistle&#34;: &#34;#d8bfd8&#34;,
    &#34;orchid&#34;: &#34;#da70d6&#34;,
    &#34;goldenrod&#34;: &#34;#daa520&#34;,
    &#34;palevioletred&#34;: &#34;#db7093&#34;,
    &#34;crimson&#34;: &#34;#dc143c&#34;,
    &#34;gainsboro&#34;: &#34;#dcdcdc&#34;,
    &#34;plum&#34;: &#34;#dda0dd&#34;,
    &#34;burlywood&#34;: &#34;#deb887&#34;,
    &#34;lightcyan&#34;: &#34;#e0ffff&#34;,
    &#34;lavender&#34;: &#34;#e6e6fa&#34;,
    &#34;darksalmon&#34;: &#34;#e9967a&#34;,
    &#34;violet&#34;: &#34;#ee82ee&#34;,
    &#34;palegoldenrod&#34;: &#34;#eee8aa&#34;,
    &#34;lightcoral&#34;: &#34;#f08080&#34;,
    &#34;khaki&#34;: &#34;#f0e68c&#34;,
    &#34;aliceblue&#34;: &#34;#f0f8ff&#34;,
    &#34;honeydew&#34;: &#34;#f0fff0&#34;,
    &#34;azure&#34;: &#34;#f0ffff&#34;,
    &#34;sandybrown&#34;: &#34;#f4a460&#34;,
    &#34;wheat&#34;: &#34;#f5deb3&#34;,
    &#34;beige&#34;: &#34;#f5f5dc&#34;,
    &#34;whitesmoke&#34;: &#34;#f5f5f5&#34;,
    &#34;mintcream&#34;: &#34;#f5fffa&#34;,
    &#34;ghostwhite&#34;: &#34;#f8f8ff&#34;,
    &#34;salmon&#34;: &#34;#fa8072&#34;,
    &#34;antiquewhite&#34;: &#34;#faebd7&#34;,
    &#34;linen&#34;: &#34;#faf0e6&#34;,
    &#34;lightgoldenrodyellow&#34;: &#34;#fafad2&#34;,
    &#34;oldlace&#34;: &#34;#fdf5e6&#34;,
    &#34;red&#34;: &#34;#ff0000&#34;,
    &#34;fuchsia&#34;: &#34;#ff00ff&#34;,
    &#34;magenta&#34;: &#34;#ff00ff&#34;,
    &#34;deeppink&#34;: &#34;#ff1493&#34;,
    &#34;orangered&#34;: &#34;#ff4500&#34;,
    &#34;tomato&#34;: &#34;#ff6347&#34;,
    &#34;hotpink&#34;: &#34;#ff69b4&#34;,
    &#34;coral&#34;: &#34;#ff7f50&#34;,
    &#34;darkorange&#34;: &#34;#ff8c00&#34;,
    &#34;lightsalmon&#34;: &#34;#ffa07a&#34;,
    &#34;orange&#34;: &#34;#ffa500&#34;,
    &#34;lightpink&#34;: &#34;#ffb6c1&#34;,
    &#34;pink&#34;: &#34;#ffc0cb&#34;,
    &#34;gold&#34;: &#34;#ffd700&#34;,
    &#34;peachpuff&#34;: &#34;#ffdab9&#34;,
    &#34;navajowhite&#34;: &#34;#ffdead&#34;,
    &#34;moccasin&#34;: &#34;#ffe4b5&#34;,
    &#34;bisque&#34;: &#34;#ffe4c4&#34;,
    &#34;mistyrose&#34;: &#34;#ffe4e1&#34;,
    &#34;blanchedalmond&#34;: &#34;#ffebcd&#34;,
    &#34;papayawhip&#34;: &#34;#ffefd5&#34;,
    &#34;lavenderblush&#34;: &#34;#fff0f5&#34;,
    &#34;seashell&#34;: &#34;#fff5ee&#34;,
    &#34;cornsilk&#34;: &#34;#fff8dc&#34;,
    &#34;lemonchiffon&#34;: &#34;#fffacd&#34;,
    &#34;floralwhite&#34;: &#34;#fffaf0&#34;,
    &#34;snow&#34;: &#34;#fffafa&#34;,
    &#34;yellow&#34;: &#34;#ffff00&#34;,
    &#34;lightyellow&#34;: &#34;#ffffe0&#34;,
    &#34;ivory&#34;: &#34;#fffff0&#34;,
    &#34;white&#34;: &#34;#ffffff&#34;,
}


def color_as_decimal(color=&#34;#000000&#34;):
    if not color:
        return None

    # Checks if color is a name and gets the hex value
    hexcolor = COLOR_DICT.get(color.lower(), color)

    if len(hexcolor) == 4:
        r = int(hexcolor[1] * 2, 16)
        g = int(hexcolor[2] * 2, 16)
        b = int(hexcolor[3] * 2, 16)
        return r, g, b

    r = int(hexcolor[1:3], 16)
    g = int(hexcolor[3:5], 16)
    b = int(hexcolor[5:7], 16)
    return r, g, b


class HTML2FPDF(HTMLParser):
    &#34;Render basic HTML to FPDF&#34;

    HTML_UNCLOSED_TAGS = (&#34;br&#34;, &#34;dd&#34;, &#34;dt&#34;, &#34;hr&#34;, &#34;img&#34;, &#34;li&#34;, &#34;td&#34;, &#34;tr&#34;)

    def __init__(
        self,
        pdf,
        image_map=None,
        li_tag_indent=5,
        dd_tag_indent=10,
        table_line_separators=False,
        ul_bullet_char=BULLET_WIN1252,
        heading_sizes=None,
        pre_code_font=&#34;courier&#34;,
        warn_on_tags_not_matching=True,
        **_,
    ):
        &#34;&#34;&#34;
        Args:
            pdf (FPDF): an instance of `fpdf.FPDF`
            image_map (function): an optional one-argument function that map &lt;img&gt; &#34;src&#34;
                to new image URLs
            li_tag_indent (int): numeric indentation of &lt;li&gt; elements
            dd_tag_indent (int): numeric indentation of &lt;dd&gt; elements
            table_line_separators (bool): enable horizontal line separators in &lt;table&gt;
            ul_bullet_char (str): bullet character for &lt;ul&gt; elements
            heading_sizes (dict): font size per heading level names (&#34;h1&#34;, &#34;h2&#34;...)
            pre_code_font (str): font to use for &lt;pre&gt; &amp; &lt;code&gt; blocks
            warn_on_tags_not_matching (bool): control warnings production for unmatched HTML tags
        &#34;&#34;&#34;
        super().__init__()
        self.pdf = pdf
        self.image_map = image_map or (lambda src: src)
        self.li_tag_indent = li_tag_indent
        self.dd_tag_indent = dd_tag_indent
        self.ul_bullet_char = ul_bullet_char
        self.heading_sizes = dict(**DEFAULT_HEADING_SIZES)
        if heading_sizes:
            self.heading_sizes.update(heading_sizes)
        self.pre_code_font = pre_code_font
        self.warn_on_tags_not_matching = warn_on_tags_not_matching

        # We operate in a local context and will only temporarily switch to the outer one for rendering.
        # This is necessary because of the deferred execution of text region writes. Changing fonts and
        # colors in here must not affect the output and/or interfere with the settings during rendering.
        # The TOC gets rendered outside of our scope, so we need to set a font first, in order to
        # ensure that the TOC has one available.
        # If a font was defined previously, we reinstate that seperately after we&#39;re finished here.
        # In this case the TOC will be rendered with that font and not ours. But adding a TOC tag only
        # makes sense if the whole document gets converted from HTML, so this should be acceptable.
        self.style = dict(b=False, i=False, u=False)
        self.font_size = pdf.font_size_pt
        self.set_font(pdf.font_family or &#34;times&#34;, size=self.font_size, set_default=True)
        self._prev_font = (pdf.font_family, self.font_size, self.style)
        self.pdf._push_local_stack()  # xpylint: disable=protected-access

        self._pre_formatted = False  # preserve whitespace while True.
        self._pre_started = (
            False  # nothing written yet to &lt;pre&gt;, remove one initial nl.
        )
        self.follows_trailing_space = False  # The last write has ended with a space.
        self.follows_heading = False  # We don&#39;t want extra space below a heading.
        self.href = &#34;&#34;
        self.align = &#34;&#34;
        self.font_stack = []
        self.indent = 0
        self.bullet = []
        self.font_color = tuple((255 * v for v in pdf.text_color.colors))
        self.heading_level = None
        self.heading_above = 0.2  # extra space above heading, relative to font size
        self.heading_below = 0.4  # extra space below heading, relative to font size
        self._tags_stack = []
        self._column = self.pdf.text_columns(skip_leading_spaces=True)
        self._paragraph = self._column.paragraph()
        # &lt;table&gt;-related properties:
        self.table_line_separators = table_line_separators
        self.table = None  # becomes a Table instance when processing &lt;table&gt; tags
        self.table_row = None  # becomes a Row instance when processing &lt;tr&gt; tags
        self.tr = None  # becomes a dict of attributes when processing &lt;tr&gt; tags
        self.td_th = None  # becomes a dict of attributes when processing &lt;td&gt;/&lt;th&gt; tags
        # &#34;inserted&#34; is a special attribute indicating that a cell has be inserted in self.table_row

    def _new_paragraph(
        self, align=None, line_height=1.0, top_margin=0, bottom_margin=0
    ):
        self._end_paragraph()
        self.align = align or &#34;&#34;
        if not top_margin and not self.follows_heading:
            top_margin = self.font_size / self.pdf.k
        self._paragraph = self._column.paragraph(
            text_align=align,
            line_height=line_height,
            skip_leading_spaces=True,
            top_margin=top_margin,
            bottom_margin=bottom_margin,
        )
        self.follows_trailing_space = True
        self.follows_heading = False

    def _end_paragraph(self):
        self.align = &#34;&#34;
        if self._paragraph:
            self._column.end_paragraph()
            our_context = (
                self.pdf._pop_local_stack()  # pylint: disable=protected-access
            )
            self._column.render()
            self.pdf._push_local_stack(our_context)  # pylint: disable=protected-access
            self._paragraph = None
            self.follows_trailing_space = True

    def _write_paragraph(self, text, link=None):
        if not self._paragraph:
            self._new_paragraph()
        self._paragraph.write(text, link=link)

    def _ln(self, h=None):
        if self._paragraph:
            self._paragraph.ln(h=h)
        else:
            self._column.ln(h=h)
        self.follows_trailing_space = True

    def handle_data(self, data):
        if self.td_th is not None:
            data = data.strip()
            if not data:
                return
            if &#34;inserted&#34; in self.td_th:
                td_th_tag = self.td_th[&#34;tag&#34;]
                raise NotImplementedError(
                    f&#34;Unsupported nested HTML tags inside &lt;{td_th_tag}&gt; element: &lt;{self._tags_stack[-1]}&gt;&#34;
                )
                # We could potentially support nested &lt;b&gt; / &lt;em&gt; / &lt;font&gt; tags
                # by building a list of Fragment instances from the HTML cell content
                # and then passing those fragments to Row.cell().
                # However there should be an incoming refactoring of this code
                # dedicated to text layout, and we should probably wait for that
                # before supporting this feature.
            align = self.td_th.get(&#34;align&#34;, self.tr.get(&#34;align&#34;))
            if align:
                align = align.upper()
            bgcolor = color_as_decimal(
                self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
            )
            colspan = int(self.td_th.get(&#34;colspan&#34;, &#34;1&#34;))
            emphasis = 0
            if self.td_th.get(&#34;b&#34;):
                emphasis |= TextEmphasis.B
            if self.td_th.get(&#34;i&#34;):
                emphasis |= TextEmphasis.I
            if self.td_th.get(&#34;U&#34;):
                emphasis |= TextEmphasis.U
            style = None
            if bgcolor or emphasis:
                style = FontFace(
                    emphasis=emphasis, fill_color=bgcolor, color=self.pdf.text_color
                )
            self.table_row.cell(text=data, align=align, style=style, colspan=colspan)
            self.td_th[&#34;inserted&#34;] = True
        elif self.table is not None:
            # ignore anything else than td inside a table
            pass
        elif self._pre_formatted:  # pre blocks
            # If we want to mimick the exact HTML semantics about newlines at the
            # beginning and end of the block, then this needs some more thought.
            s_nl = data.startswith(&#34;\n&#34;) and self._pre_started
            self._pre_started = False
            e_nl = data.endswith(&#34;\n&#34;)
            if s_nl and e_nl:
                data = data[1:-1]
            elif s_nl:
                data = data[1:]
            # elif e_nl:
            #    data = data[:-1]
            self._write_data(data)
        else:
            data = _WS_SUB_PAT.sub(&#34; &#34;, data)
            if self.follows_trailing_space and data[0] == &#34; &#34;:
                self._write_data(data[1:])
            else:
                self._write_data(data)
            self.follows_trailing_space = data[-1] == &#34; &#34;

    def _write_data(self, data):
        if self.href:
            self.put_link(data)
        else:
            if self.heading_level:
                self.pdf.start_section(data, self.heading_level - 1, strict=False)
            LOGGER.debug(f&#34;write: &#39;%s&#39; h={self.h:.2f}&#34;, data)
            self._write_paragraph(data)

    def handle_starttag(self, tag, attrs):
        self._pre_started = False
        attrs = dict(attrs)
        LOGGER.debug(&#34;STARTTAG %s %s&#34;, tag, attrs)
        self._tags_stack.append(tag)
        if tag == &#34;dt&#34;:
            self._write_paragraph(&#34;\n&#34;)
            tag = &#34;b&#34;
        if tag == &#34;dd&#34;:
            self._write_paragraph(&#34;\n&#34; + &#34;\u00a0&#34; * self.dd_tag_indent)
        if tag == &#34;strong&#34;:
            tag = &#34;b&#34;
        if tag == &#34;em&#34;:
            tag = &#34;i&#34;
        if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
            if self.td_th is not None:
                self.td_th[tag] = True
            else:
                self.set_style(tag, True)
        if tag == &#34;a&#34;:
            self.href = attrs[&#34;href&#34;]
        if tag == &#34;br&#34;:
            self._write_paragraph(&#34;\n&#34;)
        if tag == &#34;p&#34;:
            if &#34;align&#34; in attrs:
                align = attrs.get(&#34;align&#34;)[0].upper()
                if not align in [&#34;L&#34;, &#34;R&#34;, &#34;J&#34;, &#34;C&#34;]:
                    align = None
            else:
                align = None
            if &#34;line-height&#34; in attrs:
                try:
                    # YYY parse and convert non-float line_height values
                    line_height = float(attrs.get(&#34;line-height&#34;))
                except ValueError:
                    line_height = None
            else:
                line_height = None
            self._new_paragraph(align=align, line_height=line_height)
        if tag in self.heading_sizes:
            prev_font_height = self.font_size / self.pdf.k
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.heading_level = int(tag[1:])
            hsize_pt = self.heading_sizes[tag]
            hsize = hsize_pt / self.pdf.k
            if attrs:
                align = attrs.get(&#34;align&#34;)
                if not align in [&#34;L&#34;, &#34;R&#34;, &#34;J&#34;, &#34;C&#34;]:
                    align = None
            else:
                align = None
            self._new_paragraph(
                align=align,
                top_margin=prev_font_height + self.heading_above * hsize,
                bottom_margin=self.heading_below * hsize,
            )
            color = (
                color_as_decimal(attrs[&#34;color&#34;]) if &#34;color&#34; in attrs else (150, 0, 0)
            )
            self.set_text_color(*color)
            self.set_font(size=hsize_pt)

        if tag == &#34;hr&#34;:
            self.pdf.add_page(same=True)
        if tag == &#34;code&#34;:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.set_font(self.pre_code_font, self.font_size)
        if tag == &#34;pre&#34;:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.set_font(self.pre_code_font, self.font_size)
            self._pre_formatted = True
            self._new_paragraph()
            self._pre_started = True
        if tag == &#34;blockquote&#34;:
            self.set_text_color(100, 0, 45)
            self.indent += 1
            self._new_paragraph(top_margin=3, bottom_margin=3)
        if tag == &#34;ul&#34;:
            self.indent += 1
            self.bullet.append(self.ul_bullet_char)
            self._new_paragraph()
        if tag == &#34;ol&#34;:
            self.indent += 1
            self.bullet.append(0)
            self._new_paragraph()
        if tag == &#34;li&#34;:
            self._ln(2)
            self.set_text_color(190, 0, 0)
            if self.bullet:
                bullet = self.bullet[self.indent - 1]
            else:
                # Allow &lt;li&gt; to be used outside of &lt;ul&gt; or &lt;ol&gt;.
                bullet = self.ul_bullet_char
            if not isinstance(bullet, str):
                bullet += 1
                self.bullet[self.indent - 1] = bullet
                bullet = f&#34;{bullet}. &#34;
            indent = &#34;\u00a0&#34; * self.li_tag_indent * self.indent
            self._write_paragraph(f&#34;{indent}{bullet} &#34;)
            self.set_text_color(*self.font_color)
        if tag == &#34;font&#34;:
            # save previous font state:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            if &#34;color&#34; in attrs:
                color = color_as_decimal(attrs[&#34;color&#34;])
                self.font_color = color
            if &#34;face&#34; in attrs:
                face = attrs.get(&#34;face&#34;).lower()
                # This may result in a FPDFException &#34;font not found&#34;.
                self.set_font(face)
                self.font_face = face
            if &#34;size&#34; in attrs:
                self.font_size = int(attrs.get(&#34;size&#34;))
            self.set_font()
            self.set_text_color(*self.font_color)
        if tag == &#34;table&#34;:
            width = attrs.get(&#34;width&#34;)
            if width:
                if width[-1] == &#34;%&#34;:
                    width = self.pdf.epw * int(width[:-1]) / 100
                else:
                    width = int(width) / self.pdf.k
            if &#34;border&#34; in attrs:
                borders_layout = (
                    &#34;ALL&#34; if self.table_line_separators else &#34;NO_HORIZONTAL_LINES&#34;
                )
            else:
                borders_layout = (
                    &#34;HORIZONTAL_LINES&#34;
                    if self.table_line_separators
                    else &#34;SINGLE_TOP_LINE&#34;
                )
            align = attrs.get(&#34;align&#34;, &#34;center&#34;).upper()
            self.table = Table(
                self.pdf,
                align=align,
                borders_layout=borders_layout,
                line_height=self.h * 1.30,
                width=width,
            )
            self._ln()
        if tag == &#34;tr&#34;:
            if not self.table:
                raise FPDFException(&#34;Invalid HTML: &lt;tr&gt; used outside any &lt;table&gt;&#34;)
            self.tr = {k.lower(): v for k, v in attrs.items()}
            self.table_row = self.table.row()
        if tag in (&#34;td&#34;, &#34;th&#34;):
            if not self.table_row:
                raise FPDFException(f&#34;Invalid HTML: &lt;{tag}&gt; used outside any &lt;tr&gt;&#34;)
            self.td_th = {k.lower(): v for k, v in attrs.items()}
            self.td_th[&#34;tag&#34;] = tag
            if tag == &#34;th&#34;:
                self.td_th[&#34;align&#34;] = &#34;CENTER&#34;
                self.td_th[&#34;b&#34;] = True
            elif len(self.table.rows) == 1 and not self.table_row.cells:
                # =&gt; we are in the 1st &lt;tr&gt;, and the 1st cell is a &lt;td&gt;
                # =&gt; we do not treat the first row as a header
                # pylint: disable=protected-access
                self.table._borders_layout = TableBordersLayout.NONE
                self.table._num_heading_rows = 0
            if &#34;height&#34; in attrs:
                LOGGER.warning(
                    &#39;Ignoring unsupported height=&#34;%s&#34; specified on a &lt;%s&gt;&#39;,
                    attrs[&#34;height&#34;],
                    tag,
                )
            if &#34;width&#34; in attrs:
                width = attrs[&#34;width&#34;]
                # pylint: disable=protected-access
                if len(self.table.rows) == 1:  # =&gt; first table row
                    if width[-1] == &#34;%&#34;:
                        width = width[:-1]
                    if not self.table._col_widths:
                        self.table._col_widths = []
                    self.table._col_widths.append(int(width))
                else:
                    LOGGER.warning(
                        &#39;Ignoring width=&#34;%s&#34; specified on a &lt;%s&gt; that is not in the first &lt;tr&gt;&#39;,
                        width,
                        tag,
                    )
        if tag == &#34;img&#34; and &#34;src&#34; in attrs:
            width = int(attrs.get(&#34;width&#34;, 0)) / self.pdf.k
            height = int(attrs.get(&#34;height&#34;, 0)) / self.pdf.k
            if self.table_row:  # =&gt; &lt;img&gt; in a &lt;table&gt;
                if width or height:
                    LOGGER.warning(
                        &#39;Ignoring unsupported &#34;width&#34; / &#34;height&#34; set on &lt;img&gt; element&#39;
                    )
                if self.align:
                    LOGGER.warning(&#34;Ignoring unsupported &lt;img&gt; alignment&#34;)
                self.table_row.cell(img=attrs[&#34;src&#34;], img_fill_width=True)
                self.td_th[&#34;inserted&#34;] = True
                return
            if self.pdf.y + height &gt; self.pdf.page_break_trigger:
                self.pdf.add_page(same=True)
            x, y = self.pdf.get_x(), self.pdf.get_y()
            if self.align and self.align[0].upper() == &#34;C&#34;:
                x = self.pdf.w / 2 - width / 2
            LOGGER.debug(
                &#39;image &#34;%s&#34; x=%d y=%d width=%d height=%d&#39;,
                attrs[&#34;src&#34;],
                x,
                y,
                width,
                height,
            )
            info = self.pdf.image(
                self.image_map(attrs[&#34;src&#34;]), x, y, width, height, link=self.href
            )
            self.pdf.set_y(y + info.rendered_height)
        if tag == &#34;center&#34;:
            self._new_paragraph(align=&#34;C&#34;)
        if tag == &#34;toc&#34;:
            self._end_paragraph()
            self.pdf.insert_toc_placeholder(
                self.render_toc, pages=int(attrs.get(&#34;pages&#34;, 1))
            )
        if tag == &#34;sup&#34;:
            self.pdf.char_vpos = &#34;SUP&#34;
        if tag == &#34;sub&#34;:
            self.pdf.char_vpos = &#34;SUB&#34;

    def handle_endtag(self, tag):
        LOGGER.debug(&#34;ENDTAG %s&#34;, tag)
        while (
            self._tags_stack
            and tag != self._tags_stack[-1]
            and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS
        ):
            self._tags_stack.pop()
        if not self._tags_stack:
            if self.warn_on_tags_not_matching:
                LOGGER.warning(
                    &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag may be missing?&#34;, tag
                )
        elif tag == self._tags_stack[-1]:
            self._tags_stack.pop()
        elif self.warn_on_tags_not_matching:
            LOGGER.warning(
                &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag was &lt;%s&gt;&#34;,
                tag,
                self._tags_stack[-1],
            )
        if tag in self.heading_sizes:
            self.heading_level = None
            face, size, color = self.font_stack.pop()
            self.set_font(face, size)
            self.set_text_color(*color)
            self._end_paragraph()
            self.follows_heading = True  # We don&#39;t want extra space below a heading.
        if tag == &#34;code&#34;:
            face, size, color = self.font_stack.pop()
            self.set_font(face, size)
            self.set_text_color(*color)
        if tag == &#34;pre&#34;:
            self._end_paragraph()
            face, size, color = self.font_stack.pop()
            self.set_font(face, size)
            self.set_text_color(*color)
            self._pre_formatted = False
            self._pre_started = False
        if tag == &#34;blockquote&#34;:
            self._end_paragraph()
            self.set_text_color(*self.font_color)
            self.indent -= 1
        if tag in (&#34;strong&#34;, &#34;dt&#34;):
            tag = &#34;b&#34;
        if tag == &#34;em&#34;:
            tag = &#34;i&#34;
        if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
            if not self.td_th is not None:
                self.set_style(tag, False)
        if tag == &#34;a&#34;:
            self.href = &#34;&#34;
        if tag == &#34;p&#34;:
            self._end_paragraph()
            self.align = &#34;&#34;
        if tag in (&#34;ul&#34;, &#34;ol&#34;):
            self._end_paragraph()
            self.indent -= 1
            self.bullet.pop()
        if tag == &#34;table&#34;:
            self.table.render()
            self.table = None
            self._ln(self.h)
        if tag == &#34;tr&#34;:
            self.tr = None
            self.table_row = None
        if tag in (&#34;td&#34;, &#34;th&#34;):
            if &#34;inserted&#34; not in self.td_th:
                # handle_data() was not called =&gt; we call it to produce an empty cell:
                bgcolor = color_as_decimal(
                    self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
                )
                style = FontFace(fill_color=bgcolor) if bgcolor else None
                self.table_row.cell(text=&#34;&#34;, style=style)
            self.td_th = None
        if tag == &#34;font&#34;:
            # recover last font state
            face, size, color = self.font_stack.pop()
            self.font_color = color
            self.set_font(face, size)
            self.set_text_color(*self.font_color)
        if tag == &#34;center&#34;:
            self._end_paragraph()
        if tag == &#34;sup&#34;:
            self.pdf.char_vpos = &#34;LINE&#34;
        if tag == &#34;sub&#34;:
            self.pdf.char_vpos = &#34;LINE&#34;

    def feed(self, data):
        super().feed(data)
        while self._tags_stack and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS:
            self._tags_stack.pop()
        self._end_paragraph()  # render the final chunk of text and clean up our local context.
        self.pdf._pop_local_stack()  # pylint: disable=protected-access
        if self._prev_font[0]:  # restore previously defined font settings
            self.style = self._prev_font[2]
            self.set_font(self._prev_font[0], size=self._prev_font[1], set_default=True)
        if self._tags_stack and self.warn_on_tags_not_matching:
            LOGGER.warning(&#34;Missing HTML end tag for &lt;%s&gt;&#34;, self._tags_stack[-1])

    def set_font(self, face=None, size=None, set_default=False):
        if face:
            self.font_face = face
        if size:
            self.font_size = size
            self.h = size / self.pdf.k
        style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s)).upper()
        LOGGER.debug(f&#34;set_font: %s style=%s h={self.h:.2f}&#34;, self.font_face, style)
        prev_page = self.pdf.page
        if not set_default:  # make sure there&#39;s at least one font defined in the PDF.
            self.pdf.page = 0
        if (self.font_face, style) != (self.pdf.font_family, self.pdf.font_style):
            self.pdf.set_font(self.font_face, style, self.font_size)
        if self.font_size != self.pdf.font_size:
            self.pdf.set_font_size(self.font_size)
        self.pdf.page = prev_page

    def set_style(self, tag=None, enable=False):
        # Modify style and select corresponding font
        if tag:
            self.style[tag.lower()] = enable
        style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s))
        LOGGER.debug(&#34;SET_FONT_STYLE %s&#34;, style)
        prev_page = self.pdf.page
        self.pdf.page = 0
        self.pdf.set_font(style=style)
        self.pdf.page = prev_page

    def set_text_color(self, r=None, g=0, b=0):
        prev_page = self.pdf.page
        self.pdf.page = 0
        self.pdf.set_text_color(r, g, b)
        self.pdf.page = prev_page

    def put_link(self, text):
        # Put a hyperlink
        self.set_text_color(0, 0, 255)
        self.set_style(&#34;u&#34;, True)
        self._write_paragraph(text, link=self.href)
        self.set_style(&#34;u&#34;, False)
        self.set_text_color(*self.font_color)

    # pylint: disable=no-self-use
    def render_toc(self, pdf, outline):
        &#34;This method can be overriden by subclasses to customize the Table of Contents style.&#34;
        pdf.ln()
        for section in outline:
            link = pdf.add_link(page=section.page_number)
            text = f&#39;{&#34; &#34; * section.level * 2} {section.name}&#39;
            text += f&#39; {&#34;.&#34; * (60 - section.level*2 - len(section.name))} {section.page_number}&#39;
            pdf.multi_cell(
                w=pdf.epw,
                h=pdf.font_size,
                text=text,
                new_x=XPos.LMARGIN,
                new_y=YPos.NEXT,
                link=link,
            )

    # Subclasses of _markupbase.ParserBase must implement this:
    def error(self, message):
        raise RuntimeError(message)


class HTMLMixin:
    &#34;&#34;&#34;
    [**DEPRECATED since v2.6.0**]
    You can now directly use the `FPDF.write_html()` method
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        warnings.warn(
            (
                &#34;The HTMLMixin class is deprecated since v2.6.0. &#34;
                &#34;Simply use the FPDF class as a replacement.&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fpdf.html.color_as_decimal"><code class="name flex">
<span>def <span class="ident">color_as_decimal</span></span>(<span>color='#000000')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L212-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def color_as_decimal(color=&#34;#000000&#34;):
    if not color:
        return None

    # Checks if color is a name and gets the hex value
    hexcolor = COLOR_DICT.get(color.lower(), color)

    if len(hexcolor) == 4:
        r = int(hexcolor[1] * 2, 16)
        g = int(hexcolor[2] * 2, 16)
        b = int(hexcolor[3] * 2, 16)
        return r, g, b

    r = int(hexcolor[1:3], 16)
    g = int(hexcolor[3:5], 16)
    b = int(hexcolor[5:7], 16)
    return r, g, b</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.html.HTML2FPDF"><code class="flex name class">
<span>class <span class="ident">HTML2FPDF</span></span>
<span>(</span><span>pdf, image_map=None, li_tag_indent=5, dd_tag_indent=10, table_line_separators=False, ul_bullet_char='\x95', heading_sizes=None, pre_code_font='courier', warn_on_tags_not_matching=True, **_)</span>
</code></dt>
<dd>
<div class="desc"><p>Render basic HTML to FPDF</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pdf</code></strong> :&ensp;<code>FPDF</code></dt>
<dd>an instance of <code>fpdf.FPDF</code></dd>
<dt><strong><code>image_map</code></strong> :&ensp;<code>function</code></dt>
<dd>an optional one-argument function that map <img> "src"
to new image URLs</dd>
<dt><strong><code>li_tag_indent</code></strong> :&ensp;<code>int</code></dt>
<dd>numeric indentation of <li> elements</dd>
<dt><strong><code>dd_tag_indent</code></strong> :&ensp;<code>int</code></dt>
<dd>numeric indentation of <dd> elements</dd>
<dt><strong><code>table_line_separators</code></strong> :&ensp;<code>bool</code></dt>
<dd>enable horizontal line separators in <table></dd>
<dt><strong><code>ul_bullet_char</code></strong> :&ensp;<code>str</code></dt>
<dd>bullet character for <ul> elements</dd>
<dt><strong><code>heading_sizes</code></strong> :&ensp;<code>dict</code></dt>
<dd>font size per heading level names ("h1", "h2"&hellip;)</dd>
<dt><strong><code>pre_code_font</code></strong> :&ensp;<code>str</code></dt>
<dd>font to use for <pre> &amp; <code> blocks</dd>
<dt><strong><code>warn_on_tags_not_matching</code></strong> :&ensp;<code>bool</code></dt>
<dd>control warnings production for unmatched HTML tags</dd>
</dl></div>
  
    
      <details class="source">
        <summary>
            <span>Expand source code</span>
              <a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L231-L809" class="git-link">Browse git</a>
        </summary>
        <pre><code class="python">class HTML2FPDF(HTMLParser):
    &#34;Render basic HTML to FPDF&#34;

    HTML_UNCLOSED_TAGS = (&#34;br&#34;, &#34;dd&#34;, &#34;dt&#34;, &#34;hr&#34;, &#34;img&#34;, &#34;li&#34;, &#34;td&#34;, &#34;tr&#34;)

    def __init__(
        self,
        pdf,
        image_map=None,
        li_tag_indent=5,
        dd_tag_indent=10,
        table_line_separators=False,
        ul_bullet_char=BULLET_WIN1252,
        heading_sizes=None,
        pre_code_font=&#34;courier&#34;,
        warn_on_tags_not_matching=True,
        **_,
    ):
        &#34;&#34;&#34;
        Args:
            pdf (FPDF): an instance of `fpdf.FPDF`
            image_map (function): an optional one-argument function that map &lt;img&gt; &#34;src&#34;
                to new image URLs
            li_tag_indent (int): numeric indentation of &lt;li&gt; elements
            dd_tag_indent (int): numeric indentation of &lt;dd&gt; elements
            table_line_separators (bool): enable horizontal line separators in &lt;table&gt;
            ul_bullet_char (str): bullet character for &lt;ul&gt; elements
            heading_sizes (dict): font size per heading level names (&#34;h1&#34;, &#34;h2&#34;...)
            pre_code_font (str): font to use for &lt;pre&gt; &amp; &lt;code&gt; blocks
            warn_on_tags_not_matching (bool): control warnings production for unmatched HTML tags
        &#34;&#34;&#34;
        super().__init__()
        self.pdf = pdf
        self.image_map = image_map or (lambda src: src)
        self.li_tag_indent = li_tag_indent
        self.dd_tag_indent = dd_tag_indent
        self.ul_bullet_char = ul_bullet_char
        self.heading_sizes = dict(**DEFAULT_HEADING_SIZES)
        if heading_sizes:
            self.heading_sizes.update(heading_sizes)
        self.pre_code_font = pre_code_font
        self.warn_on_tags_not_matching = warn_on_tags_not_matching

        # We operate in a local context and will only temporarily switch to the outer one for rendering.
        # This is necessary because of the deferred execution of text region writes. Changing fonts and
        # colors in here must not affect the output and/or interfere with the settings during rendering.
        # The TOC gets rendered outside of our scope, so we need to set a font first, in order to
        # ensure that the TOC has one available.
        # If a font was defined previously, we reinstate that seperately after we&#39;re finished here.
        # In this case the TOC will be rendered with that font and not ours. But adding a TOC tag only
        # makes sense if the whole document gets converted from HTML, so this should be acceptable.
        self.style = dict(b=False, i=False, u=False)
        self.font_size = pdf.font_size_pt
        self.set_font(pdf.font_family or &#34;times&#34;, size=self.font_size, set_default=True)
        self._prev_font = (pdf.font_family, self.font_size, self.style)
        self.pdf._push_local_stack()  # xpylint: disable=protected-access

        self._pre_formatted = False  # preserve whitespace while True.
        self._pre_started = (
            False  # nothing written yet to &lt;pre&gt;, remove one initial nl.
        )
        self.follows_trailing_space = False  # The last write has ended with a space.
        self.follows_heading = False  # We don&#39;t want extra space below a heading.
        self.href = &#34;&#34;
        self.align = &#34;&#34;
        self.font_stack = []
        self.indent = 0
        self.bullet = []
        self.font_color = tuple((255 * v for v in pdf.text_color.colors))
        self.heading_level = None
        self.heading_above = 0.2  # extra space above heading, relative to font size
        self.heading_below = 0.4  # extra space below heading, relative to font size
        self._tags_stack = []
        self._column = self.pdf.text_columns(skip_leading_spaces=True)
        self._paragraph = self._column.paragraph()
        # &lt;table&gt;-related properties:
        self.table_line_separators = table_line_separators
        self.table = None  # becomes a Table instance when processing &lt;table&gt; tags
        self.table_row = None  # becomes a Row instance when processing &lt;tr&gt; tags
        self.tr = None  # becomes a dict of attributes when processing &lt;tr&gt; tags
        self.td_th = None  # becomes a dict of attributes when processing &lt;td&gt;/&lt;th&gt; tags
        # &#34;inserted&#34; is a special attribute indicating that a cell has be inserted in self.table_row

    def _new_paragraph(
        self, align=None, line_height=1.0, top_margin=0, bottom_margin=0
    ):
        self._end_paragraph()
        self.align = align or &#34;&#34;
        if not top_margin and not self.follows_heading:
            top_margin = self.font_size / self.pdf.k
        self._paragraph = self._column.paragraph(
            text_align=align,
            line_height=line_height,
            skip_leading_spaces=True,
            top_margin=top_margin,
            bottom_margin=bottom_margin,
        )
        self.follows_trailing_space = True
        self.follows_heading = False

    def _end_paragraph(self):
        self.align = &#34;&#34;
        if self._paragraph:
            self._column.end_paragraph()
            our_context = (
                self.pdf._pop_local_stack()  # pylint: disable=protected-access
            )
            self._column.render()
            self.pdf._push_local_stack(our_context)  # pylint: disable=protected-access
            self._paragraph = None
            self.follows_trailing_space = True

    def _write_paragraph(self, text, link=None):
        if not self._paragraph:
            self._new_paragraph()
        self._paragraph.write(text, link=link)

    def _ln(self, h=None):
        if self._paragraph:
            self._paragraph.ln(h=h)
        else:
            self._column.ln(h=h)
        self.follows_trailing_space = True

    def handle_data(self, data):
        if self.td_th is not None:
            data = data.strip()
            if not data:
                return
            if &#34;inserted&#34; in self.td_th:
                td_th_tag = self.td_th[&#34;tag&#34;]
                raise NotImplementedError(
                    f&#34;Unsupported nested HTML tags inside &lt;{td_th_tag}&gt; element: &lt;{self._tags_stack[-1]}&gt;&#34;
                )
                # We could potentially support nested &lt;b&gt; / &lt;em&gt; / &lt;font&gt; tags
                # by building a list of Fragment instances from the HTML cell content
                # and then passing those fragments to Row.cell().
                # However there should be an incoming refactoring of this code
                # dedicated to text layout, and we should probably wait for that
                # before supporting this feature.
            align = self.td_th.get(&#34;align&#34;, self.tr.get(&#34;align&#34;))
            if align:
                align = align.upper()
            bgcolor = color_as_decimal(
                self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
            )
            colspan = int(self.td_th.get(&#34;colspan&#34;, &#34;1&#34;))
            emphasis = 0
            if self.td_th.get(&#34;b&#34;):
                emphasis |= TextEmphasis.B
            if self.td_th.get(&#34;i&#34;):
                emphasis |= TextEmphasis.I
            if self.td_th.get(&#34;U&#34;):
                emphasis |= TextEmphasis.U
            style = None
            if bgcolor or emphasis:
                style = FontFace(
                    emphasis=emphasis, fill_color=bgcolor, color=self.pdf.text_color
                )
            self.table_row.cell(text=data, align=align, style=style, colspan=colspan)
            self.td_th[&#34;inserted&#34;] = True
        elif self.table is not None:
            # ignore anything else than td inside a table
            pass
        elif self._pre_formatted:  # pre blocks
            # If we want to mimick the exact HTML semantics about newlines at the
            # beginning and end of the block, then this needs some more thought.
            s_nl = data.startswith(&#34;\n&#34;) and self._pre_started
            self._pre_started = False
            e_nl = data.endswith(&#34;\n&#34;)
            if s_nl and e_nl:
                data = data[1:-1]
            elif s_nl:
                data = data[1:]
            # elif e_nl:
            #    data = data[:-1]
            self._write_data(data)
        else:
            data = _WS_SUB_PAT.sub(&#34; &#34;, data)
            if self.follows_trailing_space and data[0] == &#34; &#34;:
                self._write_data(data[1:])
            else:
                self._write_data(data)
            self.follows_trailing_space = data[-1] == &#34; &#34;

    def _write_data(self, data):
        if self.href:
            self.put_link(data)
        else:
            if self.heading_level:
                self.pdf.start_section(data, self.heading_level - 1, strict=False)
            LOGGER.debug(f&#34;write: &#39;%s&#39; h={self.h:.2f}&#34;, data)
            self._write_paragraph(data)

    def handle_starttag(self, tag, attrs):
        self._pre_started = False
        attrs = dict(attrs)
        LOGGER.debug(&#34;STARTTAG %s %s&#34;, tag, attrs)
        self._tags_stack.append(tag)
        if tag == &#34;dt&#34;:
            self._write_paragraph(&#34;\n&#34;)
            tag = &#34;b&#34;
        if tag == &#34;dd&#34;:
            self._write_paragraph(&#34;\n&#34; + &#34;\u00a0&#34; * self.dd_tag_indent)
        if tag == &#34;strong&#34;:
            tag = &#34;b&#34;
        if tag == &#34;em&#34;:
            tag = &#34;i&#34;
        if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
            if self.td_th is not None:
                self.td_th[tag] = True
            else:
                self.set_style(tag, True)
        if tag == &#34;a&#34;:
            self.href = attrs[&#34;href&#34;]
        if tag == &#34;br&#34;:
            self._write_paragraph(&#34;\n&#34;)
        if tag == &#34;p&#34;:
            if &#34;align&#34; in attrs:
                align = attrs.get(&#34;align&#34;)[0].upper()
                if not align in [&#34;L&#34;, &#34;R&#34;, &#34;J&#34;, &#34;C&#34;]:
                    align = None
            else:
                align = None
            if &#34;line-height&#34; in attrs:
                try:
                    # YYY parse and convert non-float line_height values
                    line_height = float(attrs.get(&#34;line-height&#34;))
                except ValueError:
                    line_height = None
            else:
                line_height = None
            self._new_paragraph(align=align, line_height=line_height)
        if tag in self.heading_sizes:
            prev_font_height = self.font_size / self.pdf.k
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.heading_level = int(tag[1:])
            hsize_pt = self.heading_sizes[tag]
            hsize = hsize_pt / self.pdf.k
            if attrs:
                align = attrs.get(&#34;align&#34;)
                if not align in [&#34;L&#34;, &#34;R&#34;, &#34;J&#34;, &#34;C&#34;]:
                    align = None
            else:
                align = None
            self._new_paragraph(
                align=align,
                top_margin=prev_font_height + self.heading_above * hsize,
                bottom_margin=self.heading_below * hsize,
            )
            color = (
                color_as_decimal(attrs[&#34;color&#34;]) if &#34;color&#34; in attrs else (150, 0, 0)
            )
            self.set_text_color(*color)
            self.set_font(size=hsize_pt)

        if tag == &#34;hr&#34;:
            self.pdf.add_page(same=True)
        if tag == &#34;code&#34;:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.set_font(self.pre_code_font, self.font_size)
        if tag == &#34;pre&#34;:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.set_font(self.pre_code_font, self.font_size)
            self._pre_formatted = True
            self._new_paragraph()
            self._pre_started = True
        if tag == &#34;blockquote&#34;:
            self.set_text_color(100, 0, 45)
            self.indent += 1
            self._new_paragraph(top_margin=3, bottom_margin=3)
        if tag == &#34;ul&#34;:
            self.indent += 1
            self.bullet.append(self.ul_bullet_char)
            self._new_paragraph()
        if tag == &#34;ol&#34;:
            self.indent += 1
            self.bullet.append(0)
            self._new_paragraph()
        if tag == &#34;li&#34;:
            self._ln(2)
            self.set_text_color(190, 0, 0)
            if self.bullet:
                bullet = self.bullet[self.indent - 1]
            else:
                # Allow &lt;li&gt; to be used outside of &lt;ul&gt; or &lt;ol&gt;.
                bullet = self.ul_bullet_char
            if not isinstance(bullet, str):
                bullet += 1
                self.bullet[self.indent - 1] = bullet
                bullet = f&#34;{bullet}. &#34;
            indent = &#34;\u00a0&#34; * self.li_tag_indent * self.indent
            self._write_paragraph(f&#34;{indent}{bullet} &#34;)
            self.set_text_color(*self.font_color)
        if tag == &#34;font&#34;:
            # save previous font state:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            if &#34;color&#34; in attrs:
                color = color_as_decimal(attrs[&#34;color&#34;])
                self.font_color = color
            if &#34;face&#34; in attrs:
                face = attrs.get(&#34;face&#34;).lower()
                # This may result in a FPDFException &#34;font not found&#34;.
                self.set_font(face)
                self.font_face = face
            if &#34;size&#34; in attrs:
                self.font_size = int(attrs.get(&#34;size&#34;))
            self.set_font()
            self.set_text_color(*self.font_color)
        if tag == &#34;table&#34;:
            width = attrs.get(&#34;width&#34;)
            if width:
                if width[-1] == &#34;%&#34;:
                    width = self.pdf.epw * int(width[:-1]) / 100
                else:
                    width = int(width) / self.pdf.k
            if &#34;border&#34; in attrs:
                borders_layout = (
                    &#34;ALL&#34; if self.table_line_separators else &#34;NO_HORIZONTAL_LINES&#34;
                )
            else:
                borders_layout = (
                    &#34;HORIZONTAL_LINES&#34;
                    if self.table_line_separators
                    else &#34;SINGLE_TOP_LINE&#34;
                )
            align = attrs.get(&#34;align&#34;, &#34;center&#34;).upper()
            self.table = Table(
                self.pdf,
                align=align,
                borders_layout=borders_layout,
                line_height=self.h * 1.30,
                width=width,
            )
            self._ln()
        if tag == &#34;tr&#34;:
            if not self.table:
                raise FPDFException(&#34;Invalid HTML: &lt;tr&gt; used outside any &lt;table&gt;&#34;)
            self.tr = {k.lower(): v for k, v in attrs.items()}
            self.table_row = self.table.row()
        if tag in (&#34;td&#34;, &#34;th&#34;):
            if not self.table_row:
                raise FPDFException(f&#34;Invalid HTML: &lt;{tag}&gt; used outside any &lt;tr&gt;&#34;)
            self.td_th = {k.lower(): v for k, v in attrs.items()}
            self.td_th[&#34;tag&#34;] = tag
            if tag == &#34;th&#34;:
                self.td_th[&#34;align&#34;] = &#34;CENTER&#34;
                self.td_th[&#34;b&#34;] = True
            elif len(self.table.rows) == 1 and not self.table_row.cells:
                # =&gt; we are in the 1st &lt;tr&gt;, and the 1st cell is a &lt;td&gt;
                # =&gt; we do not treat the first row as a header
                # pylint: disable=protected-access
                self.table._borders_layout = TableBordersLayout.NONE
                self.table._num_heading_rows = 0
            if &#34;height&#34; in attrs:
                LOGGER.warning(
                    &#39;Ignoring unsupported height=&#34;%s&#34; specified on a &lt;%s&gt;&#39;,
                    attrs[&#34;height&#34;],
                    tag,
                )
            if &#34;width&#34; in attrs:
                width = attrs[&#34;width&#34;]
                # pylint: disable=protected-access
                if len(self.table.rows) == 1:  # =&gt; first table row
                    if width[-1] == &#34;%&#34;:
                        width = width[:-1]
                    if not self.table._col_widths:
                        self.table._col_widths = []
                    self.table._col_widths.append(int(width))
                else:
                    LOGGER.warning(
                        &#39;Ignoring width=&#34;%s&#34; specified on a &lt;%s&gt; that is not in the first &lt;tr&gt;&#39;,
                        width,
                        tag,
                    )
        if tag == &#34;img&#34; and &#34;src&#34; in attrs:
            width = int(attrs.get(&#34;width&#34;, 0)) / self.pdf.k
            height = int(attrs.get(&#34;height&#34;, 0)) / self.pdf.k
            if self.table_row:  # =&gt; &lt;img&gt; in a &lt;table&gt;
                if width or height:
                    LOGGER.warning(
                        &#39;Ignoring unsupported &#34;width&#34; / &#34;height&#34; set on &lt;img&gt; element&#39;
                    )
                if self.align:
                    LOGGER.warning(&#34;Ignoring unsupported &lt;img&gt; alignment&#34;)
                self.table_row.cell(img=attrs[&#34;src&#34;], img_fill_width=True)
                self.td_th[&#34;inserted&#34;] = True
                return
            if self.pdf.y + height &gt; self.pdf.page_break_trigger:
                self.pdf.add_page(same=True)
            x, y = self.pdf.get_x(), self.pdf.get_y()
            if self.align and self.align[0].upper() == &#34;C&#34;:
                x = self.pdf.w / 2 - width / 2
            LOGGER.debug(
                &#39;image &#34;%s&#34; x=%d y=%d width=%d height=%d&#39;,
                attrs[&#34;src&#34;],
                x,
                y,
                width,
                height,
            )
            info = self.pdf.image(
                self.image_map(attrs[&#34;src&#34;]), x, y, width, height, link=self.href
            )
            self.pdf.set_y(y + info.rendered_height)
        if tag == &#34;center&#34;:
            self._new_paragraph(align=&#34;C&#34;)
        if tag == &#34;toc&#34;:
            self._end_paragraph()
            self.pdf.insert_toc_placeholder(
                self.render_toc, pages=int(attrs.get(&#34;pages&#34;, 1))
            )
        if tag == &#34;sup&#34;:
            self.pdf.char_vpos = &#34;SUP&#34;
        if tag == &#34;sub&#34;:
            self.pdf.char_vpos = &#34;SUB&#34;

    def handle_endtag(self, tag):
        LOGGER.debug(&#34;ENDTAG %s&#34;, tag)
        while (
            self._tags_stack
            and tag != self._tags_stack[-1]
            and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS
        ):
            self._tags_stack.pop()
        if not self._tags_stack:
            if self.warn_on_tags_not_matching:
                LOGGER.warning(
                    &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag may be missing?&#34;, tag
                )
        elif tag == self._tags_stack[-1]:
            self._tags_stack.pop()
        elif self.warn_on_tags_not_matching:
            LOGGER.warning(
                &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag was &lt;%s&gt;&#34;,
                tag,
                self._tags_stack[-1],
            )
        if tag in self.heading_sizes:
            self.heading_level = None
            face, size, color = self.font_stack.pop()
            self.set_font(face, size)
            self.set_text_color(*color)
            self._end_paragraph()
            self.follows_heading = True  # We don&#39;t want extra space below a heading.
        if tag == &#34;code&#34;:
            face, size, color = self.font_stack.pop()
            self.set_font(face, size)
            self.set_text_color(*color)
        if tag == &#34;pre&#34;:
            self._end_paragraph()
            face, size, color = self.font_stack.pop()
            self.set_font(face, size)
            self.set_text_color(*color)
            self._pre_formatted = False
            self._pre_started = False
        if tag == &#34;blockquote&#34;:
            self._end_paragraph()
            self.set_text_color(*self.font_color)
            self.indent -= 1
        if tag in (&#34;strong&#34;, &#34;dt&#34;):
            tag = &#34;b&#34;
        if tag == &#34;em&#34;:
            tag = &#34;i&#34;
        if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
            if not self.td_th is not None:
                self.set_style(tag, False)
        if tag == &#34;a&#34;:
            self.href = &#34;&#34;
        if tag == &#34;p&#34;:
            self._end_paragraph()
            self.align = &#34;&#34;
        if tag in (&#34;ul&#34;, &#34;ol&#34;):
            self._end_paragraph()
            self.indent -= 1
            self.bullet.pop()
        if tag == &#34;table&#34;:
            self.table.render()
            self.table = None
            self._ln(self.h)
        if tag == &#34;tr&#34;:
            self.tr = None
            self.table_row = None
        if tag in (&#34;td&#34;, &#34;th&#34;):
            if &#34;inserted&#34; not in self.td_th:
                # handle_data() was not called =&gt; we call it to produce an empty cell:
                bgcolor = color_as_decimal(
                    self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
                )
                style = FontFace(fill_color=bgcolor) if bgcolor else None
                self.table_row.cell(text=&#34;&#34;, style=style)
            self.td_th = None
        if tag == &#34;font&#34;:
            # recover last font state
            face, size, color = self.font_stack.pop()
            self.font_color = color
            self.set_font(face, size)
            self.set_text_color(*self.font_color)
        if tag == &#34;center&#34;:
            self._end_paragraph()
        if tag == &#34;sup&#34;:
            self.pdf.char_vpos = &#34;LINE&#34;
        if tag == &#34;sub&#34;:
            self.pdf.char_vpos = &#34;LINE&#34;

    def feed(self, data):
        super().feed(data)
        while self._tags_stack and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS:
            self._tags_stack.pop()
        self._end_paragraph()  # render the final chunk of text and clean up our local context.
        self.pdf._pop_local_stack()  # pylint: disable=protected-access
        if self._prev_font[0]:  # restore previously defined font settings
            self.style = self._prev_font[2]
            self.set_font(self._prev_font[0], size=self._prev_font[1], set_default=True)
        if self._tags_stack and self.warn_on_tags_not_matching:
            LOGGER.warning(&#34;Missing HTML end tag for &lt;%s&gt;&#34;, self._tags_stack[-1])

    def set_font(self, face=None, size=None, set_default=False):
        if face:
            self.font_face = face
        if size:
            self.font_size = size
            self.h = size / self.pdf.k
        style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s)).upper()
        LOGGER.debug(f&#34;set_font: %s style=%s h={self.h:.2f}&#34;, self.font_face, style)
        prev_page = self.pdf.page
        if not set_default:  # make sure there&#39;s at least one font defined in the PDF.
            self.pdf.page = 0
        if (self.font_face, style) != (self.pdf.font_family, self.pdf.font_style):
            self.pdf.set_font(self.font_face, style, self.font_size)
        if self.font_size != self.pdf.font_size:
            self.pdf.set_font_size(self.font_size)
        self.pdf.page = prev_page

    def set_style(self, tag=None, enable=False):
        # Modify style and select corresponding font
        if tag:
            self.style[tag.lower()] = enable
        style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s))
        LOGGER.debug(&#34;SET_FONT_STYLE %s&#34;, style)
        prev_page = self.pdf.page
        self.pdf.page = 0
        self.pdf.set_font(style=style)
        self.pdf.page = prev_page

    def set_text_color(self, r=None, g=0, b=0):
        prev_page = self.pdf.page
        self.pdf.page = 0
        self.pdf.set_text_color(r, g, b)
        self.pdf.page = prev_page

    def put_link(self, text):
        # Put a hyperlink
        self.set_text_color(0, 0, 255)
        self.set_style(&#34;u&#34;, True)
        self._write_paragraph(text, link=self.href)
        self.set_style(&#34;u&#34;, False)
        self.set_text_color(*self.font_color)

    # pylint: disable=no-self-use
    def render_toc(self, pdf, outline):
        &#34;This method can be overriden by subclasses to customize the Table of Contents style.&#34;
        pdf.ln()
        for section in outline:
            link = pdf.add_link(page=section.page_number)
            text = f&#39;{&#34; &#34; * section.level * 2} {section.name}&#39;
            text += f&#39; {&#34;.&#34; * (60 - section.level*2 - len(section.name))} {section.page_number}&#39;
            pdf.multi_cell(
                w=pdf.epw,
                h=pdf.font_size,
                text=text,
                new_x=XPos.LMARGIN,
                new_y=YPos.NEXT,
                link=link,
            )

    # Subclasses of _markupbase.ParserBase must implement this:
    def error(self, message):
        raise RuntimeError(message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>html.parser.HTMLParser</li>
<li>_markupbase.ParserBase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.html.HTML2FPDF.HTML_UNCLOSED_TAGS"><code class="name">var <span class="ident">HTML_UNCLOSED_TAGS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.html.HTML2FPDF.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L808-L809" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def error(self, message):
    raise RuntimeError(message)</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.feed"><code class="name flex">
<span>def <span class="ident">feed</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Feed data to the parser.</p>
<p>Call this as often as you want, with as little or as much text
as you want (may include '\n').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L736-L746" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def feed(self, data):
    super().feed(data)
    while self._tags_stack and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS:
        self._tags_stack.pop()
    self._end_paragraph()  # render the final chunk of text and clean up our local context.
    self.pdf._pop_local_stack()  # pylint: disable=protected-access
    if self._prev_font[0]:  # restore previously defined font settings
        self.style = self._prev_font[2]
        self.set_font(self._prev_font[0], size=self._prev_font[1], set_default=True)
    if self._tags_stack and self.warn_on_tags_not_matching:
        LOGGER.warning(&#34;Missing HTML end tag for &lt;%s&gt;&#34;, self._tags_stack[-1])</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.handle_data"><code class="name flex">
<span>def <span class="ident">handle_data</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L355-L414" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def handle_data(self, data):
    if self.td_th is not None:
        data = data.strip()
        if not data:
            return
        if &#34;inserted&#34; in self.td_th:
            td_th_tag = self.td_th[&#34;tag&#34;]
            raise NotImplementedError(
                f&#34;Unsupported nested HTML tags inside &lt;{td_th_tag}&gt; element: &lt;{self._tags_stack[-1]}&gt;&#34;
            )
            # We could potentially support nested &lt;b&gt; / &lt;em&gt; / &lt;font&gt; tags
            # by building a list of Fragment instances from the HTML cell content
            # and then passing those fragments to Row.cell().
            # However there should be an incoming refactoring of this code
            # dedicated to text layout, and we should probably wait for that
            # before supporting this feature.
        align = self.td_th.get(&#34;align&#34;, self.tr.get(&#34;align&#34;))
        if align:
            align = align.upper()
        bgcolor = color_as_decimal(
            self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
        )
        colspan = int(self.td_th.get(&#34;colspan&#34;, &#34;1&#34;))
        emphasis = 0
        if self.td_th.get(&#34;b&#34;):
            emphasis |= TextEmphasis.B
        if self.td_th.get(&#34;i&#34;):
            emphasis |= TextEmphasis.I
        if self.td_th.get(&#34;U&#34;):
            emphasis |= TextEmphasis.U
        style = None
        if bgcolor or emphasis:
            style = FontFace(
                emphasis=emphasis, fill_color=bgcolor, color=self.pdf.text_color
            )
        self.table_row.cell(text=data, align=align, style=style, colspan=colspan)
        self.td_th[&#34;inserted&#34;] = True
    elif self.table is not None:
        # ignore anything else than td inside a table
        pass
    elif self._pre_formatted:  # pre blocks
        # If we want to mimick the exact HTML semantics about newlines at the
        # beginning and end of the block, then this needs some more thought.
        s_nl = data.startswith(&#34;\n&#34;) and self._pre_started
        self._pre_started = False
        e_nl = data.endswith(&#34;\n&#34;)
        if s_nl and e_nl:
            data = data[1:-1]
        elif s_nl:
            data = data[1:]
        # elif e_nl:
        #    data = data[:-1]
        self._write_data(data)
    else:
        data = _WS_SUB_PAT.sub(&#34; &#34;, data)
        if self.follows_trailing_space and data[0] == &#34; &#34;:
            self._write_data(data[1:])
        else:
            self._write_data(data)
        self.follows_trailing_space = data[-1] == &#34; &#34;</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.handle_endtag"><code class="name flex">
<span>def <span class="ident">handle_endtag</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L648-L734" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def handle_endtag(self, tag):
    LOGGER.debug(&#34;ENDTAG %s&#34;, tag)
    while (
        self._tags_stack
        and tag != self._tags_stack[-1]
        and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS
    ):
        self._tags_stack.pop()
    if not self._tags_stack:
        if self.warn_on_tags_not_matching:
            LOGGER.warning(
                &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag may be missing?&#34;, tag
            )
    elif tag == self._tags_stack[-1]:
        self._tags_stack.pop()
    elif self.warn_on_tags_not_matching:
        LOGGER.warning(
            &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag was &lt;%s&gt;&#34;,
            tag,
            self._tags_stack[-1],
        )
    if tag in self.heading_sizes:
        self.heading_level = None
        face, size, color = self.font_stack.pop()
        self.set_font(face, size)
        self.set_text_color(*color)
        self._end_paragraph()
        self.follows_heading = True  # We don&#39;t want extra space below a heading.
    if tag == &#34;code&#34;:
        face, size, color = self.font_stack.pop()
        self.set_font(face, size)
        self.set_text_color(*color)
    if tag == &#34;pre&#34;:
        self._end_paragraph()
        face, size, color = self.font_stack.pop()
        self.set_font(face, size)
        self.set_text_color(*color)
        self._pre_formatted = False
        self._pre_started = False
    if tag == &#34;blockquote&#34;:
        self._end_paragraph()
        self.set_text_color(*self.font_color)
        self.indent -= 1
    if tag in (&#34;strong&#34;, &#34;dt&#34;):
        tag = &#34;b&#34;
    if tag == &#34;em&#34;:
        tag = &#34;i&#34;
    if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
        if not self.td_th is not None:
            self.set_style(tag, False)
    if tag == &#34;a&#34;:
        self.href = &#34;&#34;
    if tag == &#34;p&#34;:
        self._end_paragraph()
        self.align = &#34;&#34;
    if tag in (&#34;ul&#34;, &#34;ol&#34;):
        self._end_paragraph()
        self.indent -= 1
        self.bullet.pop()
    if tag == &#34;table&#34;:
        self.table.render()
        self.table = None
        self._ln(self.h)
    if tag == &#34;tr&#34;:
        self.tr = None
        self.table_row = None
    if tag in (&#34;td&#34;, &#34;th&#34;):
        if &#34;inserted&#34; not in self.td_th:
            # handle_data() was not called =&gt; we call it to produce an empty cell:
            bgcolor = color_as_decimal(
                self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
            )
            style = FontFace(fill_color=bgcolor) if bgcolor else None
            self.table_row.cell(text=&#34;&#34;, style=style)
        self.td_th = None
    if tag == &#34;font&#34;:
        # recover last font state
        face, size, color = self.font_stack.pop()
        self.font_color = color
        self.set_font(face, size)
        self.set_text_color(*self.font_color)
    if tag == &#34;center&#34;:
        self._end_paragraph()
    if tag == &#34;sup&#34;:
        self.pdf.char_vpos = &#34;LINE&#34;
    if tag == &#34;sub&#34;:
        self.pdf.char_vpos = &#34;LINE&#34;</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.handle_starttag"><code class="name flex">
<span>def <span class="ident">handle_starttag</span></span>(<span>self, tag, attrs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L425-L646" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def handle_starttag(self, tag, attrs):
    self._pre_started = False
    attrs = dict(attrs)
    LOGGER.debug(&#34;STARTTAG %s %s&#34;, tag, attrs)
    self._tags_stack.append(tag)
    if tag == &#34;dt&#34;:
        self._write_paragraph(&#34;\n&#34;)
        tag = &#34;b&#34;
    if tag == &#34;dd&#34;:
        self._write_paragraph(&#34;\n&#34; + &#34;\u00a0&#34; * self.dd_tag_indent)
    if tag == &#34;strong&#34;:
        tag = &#34;b&#34;
    if tag == &#34;em&#34;:
        tag = &#34;i&#34;
    if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
        if self.td_th is not None:
            self.td_th[tag] = True
        else:
            self.set_style(tag, True)
    if tag == &#34;a&#34;:
        self.href = attrs[&#34;href&#34;]
    if tag == &#34;br&#34;:
        self._write_paragraph(&#34;\n&#34;)
    if tag == &#34;p&#34;:
        if &#34;align&#34; in attrs:
            align = attrs.get(&#34;align&#34;)[0].upper()
            if not align in [&#34;L&#34;, &#34;R&#34;, &#34;J&#34;, &#34;C&#34;]:
                align = None
        else:
            align = None
        if &#34;line-height&#34; in attrs:
            try:
                # YYY parse and convert non-float line_height values
                line_height = float(attrs.get(&#34;line-height&#34;))
            except ValueError:
                line_height = None
        else:
            line_height = None
        self._new_paragraph(align=align, line_height=line_height)
    if tag in self.heading_sizes:
        prev_font_height = self.font_size / self.pdf.k
        self.font_stack.append((self.font_face, self.font_size, self.font_color))
        self.heading_level = int(tag[1:])
        hsize_pt = self.heading_sizes[tag]
        hsize = hsize_pt / self.pdf.k
        if attrs:
            align = attrs.get(&#34;align&#34;)
            if not align in [&#34;L&#34;, &#34;R&#34;, &#34;J&#34;, &#34;C&#34;]:
                align = None
        else:
            align = None
        self._new_paragraph(
            align=align,
            top_margin=prev_font_height + self.heading_above * hsize,
            bottom_margin=self.heading_below * hsize,
        )
        color = (
            color_as_decimal(attrs[&#34;color&#34;]) if &#34;color&#34; in attrs else (150, 0, 0)
        )
        self.set_text_color(*color)
        self.set_font(size=hsize_pt)

    if tag == &#34;hr&#34;:
        self.pdf.add_page(same=True)
    if tag == &#34;code&#34;:
        self.font_stack.append((self.font_face, self.font_size, self.font_color))
        self.set_font(self.pre_code_font, self.font_size)
    if tag == &#34;pre&#34;:
        self.font_stack.append((self.font_face, self.font_size, self.font_color))
        self.set_font(self.pre_code_font, self.font_size)
        self._pre_formatted = True
        self._new_paragraph()
        self._pre_started = True
    if tag == &#34;blockquote&#34;:
        self.set_text_color(100, 0, 45)
        self.indent += 1
        self._new_paragraph(top_margin=3, bottom_margin=3)
    if tag == &#34;ul&#34;:
        self.indent += 1
        self.bullet.append(self.ul_bullet_char)
        self._new_paragraph()
    if tag == &#34;ol&#34;:
        self.indent += 1
        self.bullet.append(0)
        self._new_paragraph()
    if tag == &#34;li&#34;:
        self._ln(2)
        self.set_text_color(190, 0, 0)
        if self.bullet:
            bullet = self.bullet[self.indent - 1]
        else:
            # Allow &lt;li&gt; to be used outside of &lt;ul&gt; or &lt;ol&gt;.
            bullet = self.ul_bullet_char
        if not isinstance(bullet, str):
            bullet += 1
            self.bullet[self.indent - 1] = bullet
            bullet = f&#34;{bullet}. &#34;
        indent = &#34;\u00a0&#34; * self.li_tag_indent * self.indent
        self._write_paragraph(f&#34;{indent}{bullet} &#34;)
        self.set_text_color(*self.font_color)
    if tag == &#34;font&#34;:
        # save previous font state:
        self.font_stack.append((self.font_face, self.font_size, self.font_color))
        if &#34;color&#34; in attrs:
            color = color_as_decimal(attrs[&#34;color&#34;])
            self.font_color = color
        if &#34;face&#34; in attrs:
            face = attrs.get(&#34;face&#34;).lower()
            # This may result in a FPDFException &#34;font not found&#34;.
            self.set_font(face)
            self.font_face = face
        if &#34;size&#34; in attrs:
            self.font_size = int(attrs.get(&#34;size&#34;))
        self.set_font()
        self.set_text_color(*self.font_color)
    if tag == &#34;table&#34;:
        width = attrs.get(&#34;width&#34;)
        if width:
            if width[-1] == &#34;%&#34;:
                width = self.pdf.epw * int(width[:-1]) / 100
            else:
                width = int(width) / self.pdf.k
        if &#34;border&#34; in attrs:
            borders_layout = (
                &#34;ALL&#34; if self.table_line_separators else &#34;NO_HORIZONTAL_LINES&#34;
            )
        else:
            borders_layout = (
                &#34;HORIZONTAL_LINES&#34;
                if self.table_line_separators
                else &#34;SINGLE_TOP_LINE&#34;
            )
        align = attrs.get(&#34;align&#34;, &#34;center&#34;).upper()
        self.table = Table(
            self.pdf,
            align=align,
            borders_layout=borders_layout,
            line_height=self.h * 1.30,
            width=width,
        )
        self._ln()
    if tag == &#34;tr&#34;:
        if not self.table:
            raise FPDFException(&#34;Invalid HTML: &lt;tr&gt; used outside any &lt;table&gt;&#34;)
        self.tr = {k.lower(): v for k, v in attrs.items()}
        self.table_row = self.table.row()
    if tag in (&#34;td&#34;, &#34;th&#34;):
        if not self.table_row:
            raise FPDFException(f&#34;Invalid HTML: &lt;{tag}&gt; used outside any &lt;tr&gt;&#34;)
        self.td_th = {k.lower(): v for k, v in attrs.items()}
        self.td_th[&#34;tag&#34;] = tag
        if tag == &#34;th&#34;:
            self.td_th[&#34;align&#34;] = &#34;CENTER&#34;
            self.td_th[&#34;b&#34;] = True
        elif len(self.table.rows) == 1 and not self.table_row.cells:
            # =&gt; we are in the 1st &lt;tr&gt;, and the 1st cell is a &lt;td&gt;
            # =&gt; we do not treat the first row as a header
            # pylint: disable=protected-access
            self.table._borders_layout = TableBordersLayout.NONE
            self.table._num_heading_rows = 0
        if &#34;height&#34; in attrs:
            LOGGER.warning(
                &#39;Ignoring unsupported height=&#34;%s&#34; specified on a &lt;%s&gt;&#39;,
                attrs[&#34;height&#34;],
                tag,
            )
        if &#34;width&#34; in attrs:
            width = attrs[&#34;width&#34;]
            # pylint: disable=protected-access
            if len(self.table.rows) == 1:  # =&gt; first table row
                if width[-1] == &#34;%&#34;:
                    width = width[:-1]
                if not self.table._col_widths:
                    self.table._col_widths = []
                self.table._col_widths.append(int(width))
            else:
                LOGGER.warning(
                    &#39;Ignoring width=&#34;%s&#34; specified on a &lt;%s&gt; that is not in the first &lt;tr&gt;&#39;,
                    width,
                    tag,
                )
    if tag == &#34;img&#34; and &#34;src&#34; in attrs:
        width = int(attrs.get(&#34;width&#34;, 0)) / self.pdf.k
        height = int(attrs.get(&#34;height&#34;, 0)) / self.pdf.k
        if self.table_row:  # =&gt; &lt;img&gt; in a &lt;table&gt;
            if width or height:
                LOGGER.warning(
                    &#39;Ignoring unsupported &#34;width&#34; / &#34;height&#34; set on &lt;img&gt; element&#39;
                )
            if self.align:
                LOGGER.warning(&#34;Ignoring unsupported &lt;img&gt; alignment&#34;)
            self.table_row.cell(img=attrs[&#34;src&#34;], img_fill_width=True)
            self.td_th[&#34;inserted&#34;] = True
            return
        if self.pdf.y + height &gt; self.pdf.page_break_trigger:
            self.pdf.add_page(same=True)
        x, y = self.pdf.get_x(), self.pdf.get_y()
        if self.align and self.align[0].upper() == &#34;C&#34;:
            x = self.pdf.w / 2 - width / 2
        LOGGER.debug(
            &#39;image &#34;%s&#34; x=%d y=%d width=%d height=%d&#39;,
            attrs[&#34;src&#34;],
            x,
            y,
            width,
            height,
        )
        info = self.pdf.image(
            self.image_map(attrs[&#34;src&#34;]), x, y, width, height, link=self.href
        )
        self.pdf.set_y(y + info.rendered_height)
    if tag == &#34;center&#34;:
        self._new_paragraph(align=&#34;C&#34;)
    if tag == &#34;toc&#34;:
        self._end_paragraph()
        self.pdf.insert_toc_placeholder(
            self.render_toc, pages=int(attrs.get(&#34;pages&#34;, 1))
        )
    if tag == &#34;sup&#34;:
        self.pdf.char_vpos = &#34;SUP&#34;
    if tag == &#34;sub&#34;:
        self.pdf.char_vpos = &#34;SUB&#34;</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.put_link"><code class="name flex">
<span>def <span class="ident">put_link</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L782-L788" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def put_link(self, text):
    # Put a hyperlink
    self.set_text_color(0, 0, 255)
    self.set_style(&#34;u&#34;, True)
    self._write_paragraph(text, link=self.href)
    self.set_style(&#34;u&#34;, False)
    self.set_text_color(*self.font_color)</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.render_toc"><code class="name flex">
<span>def <span class="ident">render_toc</span></span>(<span>self, pdf, outline)</span>
</code></dt>
<dd>
<div class="desc"><p>This method can be overriden by subclasses to customize the Table of Contents style.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L791-L805" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def render_toc(self, pdf, outline):
    &#34;This method can be overriden by subclasses to customize the Table of Contents style.&#34;
    pdf.ln()
    for section in outline:
        link = pdf.add_link(page=section.page_number)
        text = f&#39;{&#34; &#34; * section.level * 2} {section.name}&#39;
        text += f&#39; {&#34;.&#34; * (60 - section.level*2 - len(section.name))} {section.page_number}&#39;
        pdf.multi_cell(
            w=pdf.epw,
            h=pdf.font_size,
            text=text,
            new_x=XPos.LMARGIN,
            new_y=YPos.NEXT,
            link=link,
        )</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.set_font"><code class="name flex">
<span>def <span class="ident">set_font</span></span>(<span>self, face=None, size=None, set_default=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L748-L763" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_font(self, face=None, size=None, set_default=False):
    if face:
        self.font_face = face
    if size:
        self.font_size = size
        self.h = size / self.pdf.k
    style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s)).upper()
    LOGGER.debug(f&#34;set_font: %s style=%s h={self.h:.2f}&#34;, self.font_face, style)
    prev_page = self.pdf.page
    if not set_default:  # make sure there&#39;s at least one font defined in the PDF.
        self.pdf.page = 0
    if (self.font_face, style) != (self.pdf.font_family, self.pdf.font_style):
        self.pdf.set_font(self.font_face, style, self.font_size)
    if self.font_size != self.pdf.font_size:
        self.pdf.set_font_size(self.font_size)
    self.pdf.page = prev_page</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.set_style"><code class="name flex">
<span>def <span class="ident">set_style</span></span>(<span>self, tag=None, enable=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L765-L774" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_style(self, tag=None, enable=False):
    # Modify style and select corresponding font
    if tag:
        self.style[tag.lower()] = enable
    style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s))
    LOGGER.debug(&#34;SET_FONT_STYLE %s&#34;, style)
    prev_page = self.pdf.page
    self.pdf.page = 0
    self.pdf.set_font(style=style)
    self.pdf.page = prev_page</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.set_text_color"><code class="name flex">
<span>def <span class="ident">set_text_color</span></span>(<span>self, r=None, g=0, b=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L776-L780" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_text_color(self, r=None, g=0, b=0):
    prev_page = self.pdf.page
    self.pdf.page = 0
    self.pdf.set_text_color(r, g, b)
    self.pdf.page = prev_page</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.html.HTMLMixin"><code class="flex name class">
<span>class <span class="ident">HTMLMixin</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>[<strong>DEPRECATED since v2.6.0</strong>]
You can now directly use the <code>FPDF.write_html()</code> method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/f2496a78fb2616e61e5b73fce4a493f4e17f51b1/fpdf/html.py#L812-L827" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class HTMLMixin:
    &#34;&#34;&#34;
    [**DEPRECATED since v2.6.0**]
    You can now directly use the `FPDF.write_html()` method
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        warnings.warn(
            (
                &#34;The HTMLMixin class is deprecated since v2.6.0. &#34;
                &#34;Simply use the FPDF class as a replacement.&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fpdf.html.color_as_decimal" href="#fpdf.html.color_as_decimal">color_as_decimal</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.html.HTML2FPDF" href="#fpdf.html.HTML2FPDF">HTML2FPDF</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.html.HTML2FPDF.HTML_UNCLOSED_TAGS" href="#fpdf.html.HTML2FPDF.HTML_UNCLOSED_TAGS">HTML_UNCLOSED_TAGS</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.error" href="#fpdf.html.HTML2FPDF.error">error</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.feed" href="#fpdf.html.HTML2FPDF.feed">feed</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.handle_data" href="#fpdf.html.HTML2FPDF.handle_data">handle_data</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.handle_endtag" href="#fpdf.html.HTML2FPDF.handle_endtag">handle_endtag</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.handle_starttag" href="#fpdf.html.HTML2FPDF.handle_starttag">handle_starttag</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.put_link" href="#fpdf.html.HTML2FPDF.put_link">put_link</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.render_toc" href="#fpdf.html.HTML2FPDF.render_toc">render_toc</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.set_font" href="#fpdf.html.HTML2FPDF.set_font">set_font</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.set_style" href="#fpdf.html.HTML2FPDF.set_style">set_style</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.set_text_color" href="#fpdf.html.HTML2FPDF.set_text_color">set_text_color</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.html.HTMLMixin" href="#fpdf.html.HTMLMixin">HTMLMixin</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>