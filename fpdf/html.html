<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>fpdf.html API documentation</title>
<meta name="description" content="HTML renderer â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.html</code></h1>
</header>
<section id="section-intro">
<p>HTML renderer</p>
<p>The contents of this module are internal to fpdf2, and not part of the public API.
They may change at any time without prior warning or any deprecation period,
in non-backward-compatible ways.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fpdf.html.color_as_decimal"><code class="name flex">
<span>def <span class="ident">color_as_decimal</span></span>(<span>color='#000000')</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a web color name to a (R, G, B) color tuple.
cf. <a href="https://en.wikipedia.org/wiki/Web_colors#HTML_color_names">https://en.wikipedia.org/wiki/Web_colors#HTML_color_names</a></p></div>
</dd>
<dt id="fpdf.html.ol_prefix"><code class="name flex">
<span>def <span class="ident">ol_prefix</span></span>(<span>ol_type, index)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.html.parse_css_style"><code class="name flex">
<span>def <span class="ident">parse_css_style</span></span>(<span>style_attr)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse <code>style="..."</code> HTML attributes, and return a dict of key-value</p></div>
</dd>
<dt id="fpdf.html.ul_prefix"><code class="name flex">
<span>def <span class="ident">ul_prefix</span></span>(<span>ul_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.html.HTML2FPDF"><code class="flex name class">
<span>class <span class="ident">HTML2FPDF</span></span>
<span>(</span><span>pdf, image_map=None, li_tag_indent=None, dd_tag_indent=None, table_line_separators=False, ul_bullet_char='\x95', li_prefix_color=(190, 0, 0), heading_sizes=None, pre_code_font=None, warn_on_tags_not_matching=True, tag_indents=None, tag_styles=None, font_family='times')</span>
</code></dt>
<dd>
<div class="desc"><p>Render basic HTML to FPDF</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pdf</code></strong> :&ensp;<code>FPDF</code></dt>
<dd>an instance of <code>fpdf.FPDF</code></dd>
<dt><strong><code>image_map</code></strong> :&ensp;<code>function</code></dt>
<dd>an optional one-argument function that map <code>&lt;img&gt;</code> "src" to new image URLs</dd>
<dt><strong><code>li_tag_indent</code></strong> :&ensp;<code>int</code></dt>
<dd>[<strong>DEPRECATED since v2.7.9</strong>]
numeric indentation of <code>&lt;li&gt;</code> elements - Set <code>tag_styles</code> instead</dd>
<dt><strong><code>dd_tag_indent</code></strong> :&ensp;<code>int</code></dt>
<dd>[<strong>DEPRECATED since v2.7.9</strong>]
numeric indentation of <code>&lt;dd&gt;</code> elements - Set <code>tag_styles</code> instead</dd>
<dt><strong><code>table_line_separators</code></strong> :&ensp;<code>bool</code></dt>
<dd>enable horizontal line separators in <code>&lt;table&gt;</code>. Defaults to <code>False</code>.</dd>
<dt><strong><code>ul_bullet_char</code></strong> :&ensp;<code>str</code></dt>
<dd>bullet character preceding <code>&lt;li&gt;</code> items in <code>&lt;ul&gt;</code> lists.
Can also be configured using the HTML <code>type</code> attribute of <code>&lt;ul&gt;</code> tags.</dd>
<dt><strong><code>li_prefix_color</code></strong> :&ensp;<code>tuple, str, <a title="fpdf.drawing.DeviceCMYK" href="drawing.html#fpdf.drawing.DeviceCMYK">DeviceCMYK</a>, <a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a>, <a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a></code></dt>
<dd>color for bullets
or numbers preceding <code>&lt;li&gt;</code> tags. This applies to both <code>&lt;ul&gt;</code> &amp; <code>&lt;ol&gt;</code> lists.</dd>
<dt><strong><code>heading_sizes</code></strong> :&ensp;<code>dict</code></dt>
<dd>[<strong>DEPRECATED since v2.7.9</strong>]
font size per heading level names ("h1", "h2"&hellip;) - Set <code>tag_styles</code> instead</dd>
<dt><strong><code>pre_code_font</code></strong> :&ensp;<code>str</code></dt>
<dd>[<strong>DEPRECATED since v2.7.9</strong>]
font to use for <code>&lt;pre&gt;</code> &amp; <code>&lt;code&gt;</code> blocks - Set <code>tag_styles</code> instead</dd>
<dt><strong><code>warn_on_tags_not_matching</code></strong> :&ensp;<code>bool</code></dt>
<dd>control warnings production for unmatched HTML tags. Defaults to <code>True</code>.</dd>
<dt><strong><code>tag_indents</code></strong> :&ensp;<code>dict</code></dt>
<dd>[<strong>DEPRECATED since v2.8.0</strong>]
mapping of HTML tag names to numeric values representing their horizontal left identation. - Set <code>tag_styles</code> instead</dd>
<dt><strong><code>tag_styles</code></strong> :&ensp;<code>dict[str, <a title="fpdf.fonts.TextStyle" href="fonts.html#fpdf.fonts.TextStyle">TextStyle</a>]</code></dt>
<dd>mapping of HTML tag names to <code>fpdf.TextStyle</code> or <code>fpdf.FontFace</code> instances</dd>
<dt><strong><code>font_family</code></strong> :&ensp;<code>str</code></dt>
<dd>optional font family. Default to Times.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/26dfb934b332aac3543be36e1507c2f6e1c7f829/fpdf/html.py#L298-L1154" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class HTML2FPDF(HTMLParser):
    &#34;Render basic HTML to FPDF&#34;

    HTML_UNCLOSED_TAGS = (&#34;br&#34;, &#34;dd&#34;, &#34;dt&#34;, &#34;hr&#34;, &#34;img&#34;, &#34;li&#34;, &#34;td&#34;, &#34;tr&#34;)
    TABLE_LINE_HEIGHT = 1.3

    def __init__(
        self,
        pdf,
        image_map=None,
        li_tag_indent=None,
        dd_tag_indent=None,
        table_line_separators=False,
        ul_bullet_char=BULLET_WIN1252,
        li_prefix_color=(190, 0, 0),
        heading_sizes=None,
        pre_code_font=None,
        warn_on_tags_not_matching=True,
        tag_indents=None,
        tag_styles=None,
        font_family=&#34;times&#34;,
    ):
        &#34;&#34;&#34;
        Args:
            pdf (FPDF): an instance of `fpdf.FPDF`
            image_map (function): an optional one-argument function that map `&lt;img&gt;` &#34;src&#34; to new image URLs
            li_tag_indent (int): [**DEPRECATED since v2.7.9**]
                numeric indentation of `&lt;li&gt;` elements - Set `tag_styles` instead
            dd_tag_indent (int): [**DEPRECATED since v2.7.9**]
                numeric indentation of `&lt;dd&gt;` elements - Set `tag_styles` instead
            table_line_separators (bool): enable horizontal line separators in `&lt;table&gt;`. Defaults to `False`.
            ul_bullet_char (str): bullet character preceding `&lt;li&gt;` items in `&lt;ul&gt;` lists.
                Can also be configured using the HTML `type` attribute of `&lt;ul&gt;` tags.
            li_prefix_color (tuple, str, fpdf.drawing.DeviceCMYK, fpdf.drawing.DeviceGray, fpdf.drawing.DeviceRGB): color for bullets
                or numbers preceding `&lt;li&gt;` tags. This applies to both `&lt;ul&gt;` &amp; `&lt;ol&gt;` lists.
            heading_sizes (dict): [**DEPRECATED since v2.7.9**]
                font size per heading level names (&#34;h1&#34;, &#34;h2&#34;...) - Set `tag_styles` instead
            pre_code_font (str): [**DEPRECATED since v2.7.9**]
                font to use for `&lt;pre&gt;` &amp; `&lt;code&gt;` blocks - Set `tag_styles` instead
            warn_on_tags_not_matching (bool): control warnings production for unmatched HTML tags. Defaults to `True`.
            tag_indents (dict): [**DEPRECATED since v2.8.0**]
                mapping of HTML tag names to numeric values representing their horizontal left identation. - Set `tag_styles` instead
            tag_styles (dict[str, fpdf.fonts.TextStyle]): mapping of HTML tag names to `fpdf.TextStyle` or `fpdf.FontFace` instances
            font_family (str): optional font family. Default to Times.
        &#34;&#34;&#34;
        super().__init__()
        self.pdf = pdf
        self.image_map = image_map or (lambda src: src)
        self.ul_bullet_char = ul_bullet_char
        self.li_prefix_color = (
            color_as_decimal(li_prefix_color)
            if isinstance(li_prefix_color, str)
            else convert_to_device_color(li_prefix_color)
        )
        self.warn_on_tags_not_matching = warn_on_tags_not_matching
        # The following 4 attributes are there to serve as &#34;temporary state&#34;,
        # so that changes to those settings are saved,
        # but not reflected onto self.pdf yet,
        # and only &#34;effectively&#34; applied when self._write_paragraph() is called.
        # This way, we often avoid useless operators in the PDF content stream.
        self.font_family = pdf.font_family or font_family
        self.font_size_pt = pdf.font_size_pt
        self.font_emphasis = TextEmphasis.NONE
        self.font_color = pdf.text_color
        # For historical / backward-compatibility reasons,
        # write_html() sets an active font (Times by default):
        self.pdf.set_font(
            family=self.font_family,
            size=self.font_size_pt,
            style=self.font_emphasis.style,
        )
        self.style_stack = []  # list of FontFace
        self.h = pdf.font_size_pt / pdf.k
        self._page_break_after_paragraph = False
        self._pre_formatted = False  # preserve whitespace while True.
        # nothing written yet to &lt;pre&gt;, remove one initial nl:
        self._pre_started = False
        self.follows_trailing_space = False  # The last write has ended with a space.
        self.follows_heading = False  # We don&#39;t want extra space below a heading.
        self.href = &#34;&#34;
        self.align = &#34;&#34;
        self.indent = 0
        self.line_height_stack = []
        self.ol_type = []  # when inside a &lt;ol&gt; tag, can be &#34;a&#34;, &#34;A&#34;, &#34;i&#34;, &#34;I&#34; or &#34;1&#34;
        self.bullet = []
        self.heading_level = None
        self._tags_stack = []
        self._column = self.pdf.text_columns(skip_leading_spaces=True)
        self._paragraph = self._column.paragraph()
        # &lt;table&gt;-related properties:
        self.table_line_separators = table_line_separators
        self.table = None  # becomes a Table instance when processing &lt;table&gt; tags
        self.table_row = None  # becomes a Row instance when processing &lt;tr&gt; tags
        self.tr = None  # becomes a dict of attributes when processing &lt;tr&gt; tags
        self.td_th = None  # becomes a dict of attributes when processing &lt;td&gt;/&lt;th&gt; tags
        #                    &#34;inserted&#34; is a special attribute indicating that a cell has be inserted in self.table_row

        self.tag_styles = _scale_units(pdf, DEFAULT_TAG_STYLES)
        for tag, tag_style in (tag_styles or {}).items():
            if tag not in DEFAULT_TAG_STYLES:
                raise NotImplementedError(
                    f&#34;Cannot set style for HTML tag &lt;{tag}&gt; (contributions are welcome to add support for this)&#34;
                )
            if not isinstance(tag_style, FontFace):
                raise ValueError(
                    f&#34;tag_styles values must be instances of FontFace or TextStyle - received: {tag_style}&#34;
                )
            # We convert FontFace values provided for block tags into TextStyle values:
            if tag in BLOCK_TAGS and not isinstance(tag_style, TextStyle):
                # pylint: disable=redefined-loop-name
                tag_style = TextStyle(
                    font_family=tag_style.family,
                    font_style=(
                        &#34;&#34; if not tag_style.emphasis else tag_style.emphasis.style
                    ),
                    font_size_pt=tag_style.size_pt,
                    color=tag_style.color,
                    fill_color=tag_style.fill_color,
                    # Using default tag margins:
                    t_margin=self.tag_styles[tag].t_margin,
                    l_margin=self.tag_styles[tag].l_margin,
                    b_margin=self.tag_styles[tag].b_margin,
                )
            self.tag_styles[tag] = tag_style
        if heading_sizes is not None:
            warnings.warn(
                (
                    &#34;The heading_sizes parameter is deprecated since v2.7.9 &#34;
                    &#34;and will be removed in a future release. &#34;
                    &#34;Set the `tag_styles` parameter instead.&#34;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
            for tag, size in heading_sizes.items():
                self.tag_styles[tag] = self.tag_styles[tag].replace(font_size_pt=size)
        if pre_code_font is not None:
            warnings.warn(
                (
                    &#34;The pre_code_font parameter is deprecated since v2.7.9 &#34;
                    &#34;and will be removed in a future release. &#34;
                    &#34;Set the `tag_styles` parameter instead.&#34;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
            self.tag_styles[&#34;code&#34;] = self.tag_styles[&#34;code&#34;].replace(
                family=pre_code_font
            )
            self.tag_styles[&#34;pre&#34;] = self.tag_styles[&#34;pre&#34;].replace(
                font_family=pre_code_font
            )
        if dd_tag_indent is not None:
            warnings.warn(
                (
                    &#34;The dd_tag_indent parameter is deprecated since v2.7.9 &#34;
                    &#34;and will be removed in a future release. &#34;
                    &#34;Set the `tag_styles` parameter instead.&#34;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
            self.tag_styles[&#34;dd&#34;] = self.tag_styles[&#34;dd&#34;].replace(
                l_margin=dd_tag_indent
            )
        if li_tag_indent is not None:
            warnings.warn(
                (
                    &#34;The li_tag_indent parameter is deprecated since v2.7.9 &#34;
                    &#34;and will be removed in a future release. &#34;
                    &#34;Set the `tag_styles` parameter instead.&#34;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
            self.tag_styles[&#34;li&#34;] = self.tag_styles[&#34;li&#34;].replace(
                l_margin=li_tag_indent
            )
        if tag_indents:
            warnings.warn(
                (
                    &#34;The tag_indents parameter is deprecated since v2.8.0 &#34;
                    &#34;and will be removed in a future release. &#34;
                    &#34;Set the `tag_styles` parameter instead.&#34;
                ),
                DeprecationWarning,
                stacklevel=get_stack_level(),
            )
            for tag, indent in tag_indents.items():
                if tag not in self.tag_styles:
                    raise NotImplementedError(
                        f&#34;Cannot set style for HTML tag &lt;{tag}&gt; (contributions are welcome to add support for this)&#34;
                    )
                self.tag_styles[tag] = self.tag_styles[tag].replace(l_margin=indent)

    def _new_paragraph(
        self,
        align=None,
        line_height=1.0,
        top_margin=0,
        bottom_margin=0,
        indent=0,
        bullet=&#34;&#34;,
    ):
        # Note that currently top_margin is ignored if bullet is also provided,
        # due to the behaviour of TextRegion._render_column_lines()
        self._end_paragraph()
        self.align = align or &#34;&#34;
        if not top_margin and not self.follows_heading:
            top_margin = self.font_size_pt / self.pdf.k
        self._paragraph = self._column.paragraph(
            text_align=align,
            line_height=line_height,
            skip_leading_spaces=True,
            top_margin=top_margin,
            bottom_margin=bottom_margin,
            indent=indent,
            bullet_string=bullet,
        )
        self.follows_trailing_space = True
        self.follows_heading = False

    def _end_paragraph(self):
        self.align = &#34;&#34;
        if not self._paragraph:
            return
        self._column.end_paragraph()
        self._column.render()
        self._paragraph = None
        self.follows_trailing_space = True
        if self._page_break_after_paragraph:
            # pylint: disable=protected-access
            self.pdf._perform_page_break()
            self._page_break_after_paragraph = False

    def _write_paragraph(self, text, link=None):
        if not text:
            return
        if not self._paragraph:
            self._new_paragraph()
        # The following local stack is required
        # in order for FPDF._get_current_graphics_state()
        # to properly capture the current graphics state,
        # and then to be able to drop those temporary changes,
        # because they will only be &#34;effectively&#34; applied in .end_paragraph().
        # pylint: disable=protected-access
        self.pdf._push_local_stack()
        prev_page = self.pdf.page
        self.pdf.page = 0
        self.pdf.set_font(
            family=self.font_family,
            size=self.font_size_pt,
            style=self.font_emphasis.style,
        )
        if self.font_color != self.pdf.text_color:
            self.pdf.set_text_color(self.font_color)
        self._paragraph.write(text, link=link)
        self.pdf.page = prev_page
        self.pdf._pop_local_stack()

    def _ln(self, h=None):
        if self._paragraph:
            self._paragraph.ln(h=h)
        else:
            self._column.ln(h=h)
        self.follows_trailing_space = True

    def handle_data(self, data):
        if self.td_th is not None:
            data = data.strip()
            if not data:
                return
            if &#34;inserted&#34; in self.td_th:
                td_th_tag = self.td_th[&#34;tag&#34;]
                raise NotImplementedError(
                    f&#34;Unsupported nested HTML tags inside &lt;{td_th_tag}&gt; element: &lt;{self._tags_stack[-1]}&gt;&#34;
                )
                # We could potentially support nested &lt;b&gt; / &lt;em&gt; / &lt;font&gt; tags
                # by building a list of Fragment instances from the HTML cell content
                # and then passing those fragments to Row.cell().
                # However there should be an incoming refactoring of this code
                # dedicated to text layout, and we should probably wait for that
                # before supporting this feature.
            align = self.td_th.get(&#34;align&#34;, self.tr.get(&#34;align&#34;))
            if align:
                align = align.upper()
            bgcolor = color_as_decimal(
                self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
            )
            colspan = int(self.td_th.get(&#34;colspan&#34;, &#34;1&#34;))
            rowspan = int(self.td_th.get(&#34;rowspan&#34;, &#34;1&#34;))
            emphasis = 0
            if self.td_th.get(&#34;b&#34;):
                emphasis |= TextEmphasis.B
            if self.td_th.get(&#34;i&#34;):
                emphasis |= TextEmphasis.I
            if self.td_th.get(&#34;U&#34;):
                emphasis |= TextEmphasis.U
            font_style = None
            if bgcolor or emphasis:
                font_style = FontFace(
                    emphasis=emphasis, fill_color=bgcolor, color=self.pdf.text_color
                )
            self.table_row.cell(
                text=data,
                align=align,
                style=font_style,
                colspan=colspan,
                rowspan=rowspan,
            )
            self.td_th[&#34;inserted&#34;] = True
        elif self.table is not None:
            # ignore anything else than td inside a table
            pass
        elif self._pre_formatted:  # pre blocks
            # If we want to mimick the exact HTML semantics about newlines at the
            # beginning and end of the block, then this needs some more thought.
            if data.startswith(&#34;\n&#34;) and self._pre_started:
                if data.endswith(&#34;\n&#34;):
                    data = data[1:-1]
                else:
                    data = data[1:]
            self._pre_started = False
            self._write_data(data)
        else:
            data = _WS_SUB_PAT.sub(&#34; &#34;, data)
            if self.follows_trailing_space and data[0] == &#34; &#34;:
                self._write_data(data[1:])
            else:
                self._write_data(data)
            self.follows_trailing_space = data[-1] == &#34; &#34;
        if self._page_break_after_paragraph:
            self._end_paragraph()

    def _write_data(self, data):
        if self.href:
            self.put_link(data)
        else:
            if self.heading_level:
                if self.pdf.section_title_styles:
                    raise NotImplementedError(
                        &#34;Combining write_html() &amp; section styles is currently not supported.&#34;
                        &#34; You can open up an issue on github.com/py-pdf/fpdf2 if this is something you would like to see implemented.&#34;
                    )
                self.pdf.start_section(data, self.heading_level - 1, strict=False)
            self._write_paragraph(data)

    def handle_starttag(self, tag, attrs):
        self._pre_started = False
        attrs = dict(attrs)
        css_style = parse_css_style(attrs.get(&#34;style&#34;, &#34;&#34;))
        self._tags_stack.append(tag)
        if css_style.get(&#34;break-before&#34;) == &#34;page&#34;:
            self._end_paragraph()
            # pylint: disable=protected-access
            self.pdf._perform_page_break()
        if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) and self.td_th is not None:
            self.td_th[tag] = True
        if tag == &#34;a&#34;:
            self.href = attrs[&#34;href&#34;]
            try:
                page = int(self.href)
                self.href = self.pdf.add_link(page=page)
            except ValueError:
                pass
        if tag == &#34;br&#34;:
            self._write_paragraph(&#34;\n&#34;)
        if tag == &#34;hr&#34;:
            self._end_paragraph()
            width = css_style.get(&#34;width&#34;, attrs.get(&#34;width&#34;))
            if width:
                if width[-1] == &#34;%&#34;:
                    width = self.pdf.epw * int(width[:-1]) / 100
                else:
                    width = int(width) / self.pdf.k
            else:
                width = self.pdf.epw
            # Centering:
            x_start = self.pdf.l_margin + (self.pdf.epw - width) / 2
            self.pdf.line(
                x1=x_start,
                y1=self.pdf.y,
                x2=x_start + width,
                y2=self.pdf.y,
            )
            self._write_paragraph(&#34;\n&#34;)
        if tag == &#34;p&#34;:
            self.style_stack.append(
                FontFace(
                    family=self.font_family,
                    emphasis=self.font_emphasis,
                    size_pt=self.font_size_pt,
                    color=self.font_color,
                )
            )
            align = None
            if &#34;align&#34; in attrs:
                align = attrs.get(&#34;align&#34;)[0].upper()
                if not align in [&#34;L&#34;, &#34;R&#34;, &#34;J&#34;, &#34;C&#34;]:
                    align = None
            line_height = css_style.get(&#34;line-height&#34;, attrs.get(&#34;line-height&#34;))
            # &#34;line-height&#34; attributes are not valid in HTML,
            # but we support it for backward compatibility,
            # because fpdf2 honors it since 2.6.1 and PR #629
            if line_height:
                try:
                    # YYY parse and convert non-float line_height values
                    line_height = float(line_height)
                except ValueError:
                    line_height = None
            tag_style = self.tag_styles[tag]
            self._new_paragraph(
                align=align,
                line_height=line_height,
                top_margin=tag_style.t_margin,
                bottom_margin=tag_style.b_margin,
                indent=tag_style.l_margin,
            )
        if tag in HEADING_TAGS:
            self.style_stack.append(
                FontFace(
                    family=self.font_family,
                    emphasis=self.font_emphasis,
                    size_pt=self.font_size_pt,
                    color=self.font_color,
                )
            )
            self.heading_level = int(tag[1:])
            tag_style = self.tag_styles[tag]
            hsize = (tag_style.size_pt or self.font_size_pt) / self.pdf.k
            if attrs:
                align = attrs.get(&#34;align&#34;)
                if not align in [&#34;L&#34;, &#34;R&#34;, &#34;J&#34;, &#34;C&#34;]:
                    align = None
            else:
                align = None
            self._new_paragraph(
                align=align,
                top_margin=tag_style.t_margin,
                bottom_margin=tag_style.b_margin * hsize,
                indent=tag_style.l_margin,
            )
            if &#34;color&#34; in css_style:
                self.font_color = color_as_decimal(css_style[&#34;color&#34;])
            elif &#34;color&#34; in attrs:
                # &#34;color&#34; attributes are not valid in HTML,
                # but we support it for backward compatibility:
                self.font_color = color_as_decimal(attrs[&#34;color&#34;])
            elif tag_style.color:
                self.font_color = tag_style.color
            self.font_family = tag_style.family or self.font_family
            self.font_size_pt = tag_style.size_pt or self.font_size_pt
            if tag_style.emphasis:
                self.font_emphasis |= tag_style.emphasis
        if tag in (
            &#34;b&#34;,
            &#34;blockquote&#34;,
            &#34;center&#34;,
            &#34;code&#34;,
            &#34;em&#34;,
            &#34;i&#34;,
            &#34;dd&#34;,
            &#34;dt&#34;,
            &#34;pre&#34;,
            &#34;strong&#34;,
            &#34;u&#34;,
        ):
            if tag in BLOCK_TAGS:
                self._end_paragraph()
            self.style_stack.append(
                FontFace(
                    family=self.font_family,
                    emphasis=self.font_emphasis,
                    size_pt=self.font_size_pt,
                    color=self.font_color,
                )
            )
            tag_style = self.tag_styles[tag]
            if tag_style.color:
                self.font_color = tag_style.color
            self.font_family = tag_style.family or self.font_family
            self.font_size_pt = tag_style.size_pt or self.font_size_pt
            if tag_style.emphasis:
                self.font_emphasis |= tag_style.emphasis
            if tag == &#34;pre&#34;:
                self._pre_formatted = True
                self._pre_started = True
            if tag in BLOCK_TAGS:
                if tag == &#34;dd&#34;:
                    # Not compliant with the HTML spec, but backward-compatible
                    # cf. https://github.com/py-pdf/fpdf2/pull/1217#discussion_r1666643777
                    self.follows_heading = True
                self._new_paragraph(
                    align=&#34;C&#34; if tag == &#34;center&#34; else None,
                    line_height=(
                        self.line_height_stack[-1] if self.line_height_stack else None
                    ),
                    top_margin=tag_style.t_margin,
                    bottom_margin=tag_style.b_margin,
                    indent=tag_style.l_margin,
                )
        if tag == &#34;ul&#34;:
            self.indent += 1
            bullet_char = (
                ul_prefix(attrs[&#34;type&#34;]) if &#34;type&#34; in attrs else self.ul_bullet_char
            )
            self.bullet.append(bullet_char)
            line_height = css_style.get(&#34;line-height&#34;, attrs.get(&#34;line-height&#34;))
            # &#34;line-height&#34; attributes are not valid in HTML,
            # but we support it for backward compatibility,
            # because fpdf2 honors it since 2.6.1 and PR #629
            if line_height:
                try:
                    # YYY parse and convert non-float line_height values
                    self.line_height_stack.append(float(line_height))
                except ValueError:
                    pass
            else:
                self.line_height_stack.append(None)
            if self.indent == 1:
                tag_style = self.tag_styles[tag]
                self._new_paragraph(
                    line_height=0,
                    top_margin=tag_style.t_margin,
                    bottom_margin=tag_style.b_margin,
                    indent=tag_style.l_margin,
                )
                self._write_paragraph(&#34;\u00a0&#34;)
            self._end_paragraph()
        if tag == &#34;ol&#34;:
            self.indent += 1
            start = int(attrs[&#34;start&#34;]) if &#34;start&#34; in attrs else 1
            self.bullet.append(start - 1)
            self.ol_type.append(attrs.get(&#34;type&#34;, &#34;1&#34;))
            line_height = css_style.get(&#34;line-height&#34;, attrs.get(&#34;line-height&#34;))
            # &#34;line-height&#34; attributes are not valid in HTML,
            # but we support it for backward compatibility,
            # because fpdf2 honors it since 2.6.1 and PR #629
            if line_height:
                try:
                    # YYY parse and convert non-float line_height values
                    self.line_height_stack.append(float(line_height))
                except ValueError:
                    pass
            else:
                self.line_height_stack.append(None)
            if self.indent == 1:
                tag_style = self.tag_styles[tag]
                self._new_paragraph(
                    line_height=0,
                    top_margin=tag_style.t_margin,
                    bottom_margin=tag_style.b_margin,
                    indent=tag_style.l_margin,
                )
                self._write_paragraph(&#34;\u00a0&#34;)
            self._end_paragraph()
        if tag == &#34;li&#34;:
            prev_text_color = self.pdf.text_color
            self.pdf.text_color = self.li_prefix_color
            if self.bullet:
                bullet = self.bullet[self.indent - 1]
            else:
                # Allow &lt;li&gt; to be used outside of &lt;ul&gt; or &lt;ol&gt;.
                bullet = self.ul_bullet_char
            if not isinstance(bullet, str):
                bullet += 1
                self.bullet[self.indent - 1] = bullet
                ol_type = self.ol_type[self.indent - 1]
                bullet = f&#34;{ol_prefix(ol_type, bullet)}.&#34;
            tag_style = self.tag_styles[tag]
            self._ln(tag_style.t_margin)
            self._new_paragraph(
                line_height=(
                    self.line_height_stack[-1] if self.line_height_stack else None
                ),
                indent=tag_style.l_margin * self.indent,
                bottom_margin=tag_style.b_margin,
                bullet=bullet,
            )
            self.pdf.text_color = prev_text_color
        if tag == &#34;font&#34;:
            self.style_stack.append(
                FontFace(
                    family=self.font_family,
                    emphasis=self.font_emphasis,
                    size_pt=self.font_size_pt,
                    color=self.font_color,
                )
            )
            if &#34;color&#34; in attrs:
                self.font_color = color_as_decimal(attrs[&#34;color&#34;])
            if &#34;font-size&#34; in css_style:
                self.font_size_pt = int(css_style.get(&#34;font-size&#34;))
            elif &#34;size&#34; in attrs:
                self.font_size_pt = int(attrs.get(&#34;size&#34;))
            if &#34;face&#34; in attrs:
                self.font_family = attrs.get(&#34;face&#34;).lower()
        if tag == &#34;table&#34;:
            width = css_style.get(&#34;width&#34;, attrs.get(&#34;width&#34;))
            if width:
                if width[-1] == &#34;%&#34;:
                    width = self.pdf.epw * int(width[:-1]) / 100
                else:
                    width = int(width) / self.pdf.k
            if &#34;border&#34; not in attrs:  # default borders
                borders_layout = (
                    &#34;HORIZONTAL_LINES&#34;
                    if self.table_line_separators
                    else &#34;SINGLE_TOP_LINE&#34;
                )
            elif int(attrs[&#34;border&#34;]):  # explicitly enabled borders
                borders_layout = (
                    &#34;ALL&#34; if self.table_line_separators else &#34;NO_HORIZONTAL_LINES&#34;
                )
            else:  # explicitly disabled borders
                borders_layout = &#34;NONE&#34;
            align = attrs.get(&#34;align&#34;, &#34;center&#34;).upper()
            padding = float(attrs[&#34;cellpadding&#34;]) if &#34;cellpadding&#34; in attrs else None
            spacing = float(attrs.get(&#34;cellspacing&#34;, 0))
            self.table = Table(
                self.pdf,
                align=align,
                borders_layout=borders_layout,
                line_height=self.h * self.TABLE_LINE_HEIGHT,
                width=width,
                padding=padding,
                gutter_width=spacing,
                gutter_height=spacing,
            )
            self._ln()
        if tag == &#34;tr&#34;:
            if not self.table:
                raise FPDFException(&#34;Invalid HTML: &lt;tr&gt; used outside any &lt;table&gt;&#34;)
            self.tr = {k.lower(): v for k, v in attrs.items()}
            self.table_row = self.table.row()
        if tag in (&#34;td&#34;, &#34;th&#34;):
            if not self.table_row:
                raise FPDFException(f&#34;Invalid HTML: &lt;{tag}&gt; used outside any &lt;tr&gt;&#34;)
            self.td_th = {k.lower(): v for k, v in attrs.items()}
            self.td_th[&#34;tag&#34;] = tag
            if tag == &#34;th&#34;:
                if &#34;align&#34; not in self.td_th:
                    self.td_th[&#34;align&#34;] = &#34;CENTER&#34;
                self.td_th[&#34;b&#34;] = True
            elif len(self.table.rows) == 1 and not self.table_row.cells:
                # =&gt; we are in the 1st &lt;tr&gt;, and the 1st cell is a &lt;td&gt;
                # =&gt; we do not treat the first row as a header
                # pylint: disable=protected-access
                self.table._first_row_as_headings = False
                self.table._num_heading_rows = 0
            if &#34;height&#34; in attrs:
                LOGGER.warning(
                    &#39;Ignoring unsupported height=&#34;%s&#34; specified on a &lt;%s&gt;&#39;,
                    attrs[&#34;height&#34;],
                    tag,
                )
            if &#34;width&#34; in attrs:
                width = attrs[&#34;width&#34;]
                # pylint: disable=protected-access
                if len(self.table.rows) == 1:  # =&gt; first table row
                    if width[-1] == &#34;%&#34;:
                        width = width[:-1]
                    if not self.table._col_widths:
                        self.table._col_widths = []
                    self.table._col_widths.append(int(width))
                else:
                    LOGGER.warning(
                        &#39;Ignoring width=&#34;%s&#34; specified on a &lt;%s&gt; that is not in the first &lt;tr&gt;&#39;,
                        width,
                        tag,
                    )
        if tag == &#34;img&#34; and &#34;src&#34; in attrs:
            width = int(attrs.get(&#34;width&#34;, 0)) / self.pdf.k
            height = int(attrs.get(&#34;height&#34;, 0)) / self.pdf.k
            if self.table_row:  # =&gt; &lt;img&gt; in a &lt;table&gt;
                if width or height:
                    LOGGER.warning(
                        &#39;Ignoring unsupported &#34;width&#34; / &#34;height&#34; set on &lt;img&gt; element&#39;
                    )
                if self.align:
                    LOGGER.warning(&#34;Ignoring unsupported &lt;img&gt; alignment&#34;)
                self.table_row.cell(img=attrs[&#34;src&#34;], img_fill_width=True)
                self.td_th[&#34;inserted&#34;] = True
                return
            x = self.pdf.get_x()
            if self.align and self.align[0].upper() == &#34;C&#34;:
                x = Align.C
            self.pdf.image(
                self.image_map(attrs[&#34;src&#34;]), x=x, w=width, h=height, link=self.href
            )
        if tag == &#34;toc&#34;:
            self._end_paragraph()
            self.pdf.insert_toc_placeholder(
                self.render_toc, pages=int(attrs.get(&#34;pages&#34;, 1))
            )
        if tag == &#34;sup&#34;:
            self.pdf.char_vpos = &#34;SUP&#34;
        if tag == &#34;sub&#34;:
            self.pdf.char_vpos = &#34;SUB&#34;
        if css_style.get(&#34;break-after&#34;) == &#34;page&#34;:
            if tag in (&#34;br&#34;, &#34;hr&#34;, &#34;img&#34;):
                self._end_paragraph()
                # pylint: disable=protected-access
                self.pdf._perform_page_break()
            else:
                self._page_break_after_paragraph = True

    def handle_endtag(self, tag):
        while (
            self._tags_stack
            and tag != self._tags_stack[-1]
            and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS
        ):
            self._tags_stack.pop()
        if not self._tags_stack:
            if self.warn_on_tags_not_matching:
                LOGGER.warning(
                    &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag may be missing?&#34;, tag
                )
        elif tag == self._tags_stack[-1]:
            self._tags_stack.pop()
        elif self.warn_on_tags_not_matching:
            LOGGER.warning(
                &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag was &lt;%s&gt;&#34;,
                tag,
                self._tags_stack[-1],
            )
        if tag == &#34;a&#34;:
            self.href = &#34;&#34;
        if tag == &#34;p&#34;:
            if self.style_stack:
                font_face = self.style_stack.pop()
                self.font_family = font_face.family or self.font_family
                self.font_size_pt = font_face.size_pt or self.font_size_pt
                self.font_emphasis = font_face.emphasis
                self.font_color = font_face.color
            self._end_paragraph()
            self.align = &#34;&#34;
        if tag in HEADING_TAGS:
            self.heading_level = None
            if self.style_stack:
                font_face = self.style_stack.pop()
                self.font_family = font_face.family or self.font_family
                self.font_size_pt = font_face.size_pt or self.font_size_pt
                self.font_emphasis = font_face.emphasis
                self.font_color = font_face.color
            self._end_paragraph()
            self.follows_heading = True  # We don&#39;t want extra space below a heading.
        if tag in (
            &#34;b&#34;,
            &#34;blockquote&#34;,
            &#34;center&#34;,
            &#34;code&#34;,
            &#34;em&#34;,
            &#34;i&#34;,
            &#34;dd&#34;,
            &#34;dt&#34;,
            &#34;pre&#34;,
            &#34;strong&#34;,
            &#34;u&#34;,
        ):
            if self.style_stack:
                font_face = self.style_stack.pop()
                self.font_family = font_face.family or self.font_family
                self.font_size_pt = font_face.size_pt or self.font_size_pt
                self.font_emphasis = font_face.emphasis
                self.font_color = font_face.color
            if tag == &#34;pre&#34;:
                self._pre_formatted = False
                self._pre_started = False
            if tag in BLOCK_TAGS:
                self._end_paragraph()
        if tag in (&#34;ul&#34;, &#34;ol&#34;):
            self._end_paragraph()
            self.indent -= 1
            if tag == &#34;ol&#34;:
                self.ol_type.pop()
            self.line_height_stack.pop()
            self.bullet.pop()
        if tag == &#34;table&#34;:
            self.table.render()
            self.table = None
            self._ln(self.h)
        if tag == &#34;tr&#34;:
            self.tr = None
            self.table_row = None
        if tag in (&#34;td&#34;, &#34;th&#34;):
            if &#34;inserted&#34; not in self.td_th:
                # handle_data() was not called =&gt; we call it to produce an empty cell:
                bgcolor = color_as_decimal(
                    self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
                )
                style = FontFace(fill_color=bgcolor) if bgcolor else None
                self.table_row.cell(text=&#34;&#34;, style=style)
            self.td_th = None
        if tag == &#34;font&#34;:
            if self.style_stack:
                font_face = self.style_stack.pop()
                self.font_family = font_face.family or self.font_family
                self.font_size_pt = font_face.size_pt or self.font_size_pt
                self.font_emphasis = font_face.emphasis
                self.font_color = font_face.color
        if tag == &#34;sup&#34;:
            self.pdf.char_vpos = &#34;LINE&#34;
        if tag == &#34;sub&#34;:
            self.pdf.char_vpos = &#34;LINE&#34;

    def feed(self, data):
        super().feed(data)
        while self._tags_stack and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS:
            self._tags_stack.pop()
        self._end_paragraph()  # render the final chunk of text and clean up our local context.
        if self._tags_stack and self.warn_on_tags_not_matching:
            LOGGER.warning(&#34;Missing HTML end tag for &lt;%s&gt;&#34;, self._tags_stack[-1])

    def put_link(self, text):
        &#34;Put a hyperlink&#34;
        prev_style = FontFace(
            family=self.font_family,
            emphasis=self.font_emphasis,
            size_pt=self.font_size_pt,
            color=self.font_color,
        )
        tag_style = self.tag_styles[&#34;a&#34;]
        if tag_style.color:
            self.font_color = tag_style.color
        self.font_family = tag_style.family or self.font_family
        self.font_size_pt = tag_style.size_pt or self.font_size_pt
        if tag_style.emphasis:
            self.font_emphasis |= tag_style.emphasis
        self._write_paragraph(text, link=self.href)
        # Restore previous style:
        self.font_family = prev_style.family or self.font_family
        self.font_size_pt = prev_style.size_pt or self.font_size_pt
        self.font_emphasis |= prev_style.emphasis
        self.font_color = prev_style.color

    # pylint: disable=no-self-use
    def render_toc(self, pdf, outline):
        &#34;This method can be overriden by subclasses to customize the Table of Contents style.&#34;
        pdf.ln()
        for section in outline:
            link = pdf.add_link(page=section.page_number)
            text = f&#39;{&#34; &#34; * section.level * 2} {section.name}&#39;
            text += f&#39; {&#34;.&#34; * (60 - section.level*2 - len(section.name))} {section.page_number}&#39;
            pdf.multi_cell(
                w=pdf.epw,
                h=pdf.font_size,
                text=text,
                new_x=XPos.LMARGIN,
                new_y=YPos.NEXT,
                link=link,
            )

    # Subclasses of _markupbase.ParserBase must implement this:
    def error(self, message):
        raise RuntimeError(message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>html.parser.HTMLParser</li>
<li>_markupbase.ParserBase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.html.HTML2FPDF.HTML_UNCLOSED_TAGS"><code class="name">var <span class="ident">HTML_UNCLOSED_TAGS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.html.HTML2FPDF.TABLE_LINE_HEIGHT"><code class="name">var <span class="ident">TABLE_LINE_HEIGHT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.html.HTML2FPDF.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.html.HTML2FPDF.feed"><code class="name flex">
<span>def <span class="ident">feed</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Feed data to the parser.</p>
<p>Call this as often as you want, with as little or as much text
as you want (may include '\n').</p></div>
</dd>
<dt id="fpdf.html.HTML2FPDF.handle_data"><code class="name flex">
<span>def <span class="ident">handle_data</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.html.HTML2FPDF.handle_endtag"><code class="name flex">
<span>def <span class="ident">handle_endtag</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.html.HTML2FPDF.handle_starttag"><code class="name flex">
<span>def <span class="ident">handle_starttag</span></span>(<span>self, tag, attrs)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.html.HTML2FPDF.put_link"><code class="name flex">
<span>def <span class="ident">put_link</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Put a hyperlink</p></div>
</dd>
<dt id="fpdf.html.HTML2FPDF.render_toc"><code class="name flex">
<span>def <span class="ident">render_toc</span></span>(<span>self, pdf, outline)</span>
</code></dt>
<dd>
<div class="desc"><p>This method can be overriden by subclasses to customize the Table of Contents style.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.html.HTMLMixin"><code class="flex name class">
<span>class <span class="ident">HTMLMixin</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>[<strong>DEPRECATED since v2.6.0</strong>]
You can now directly use the <code>FPDF.write_html()</code> method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/26dfb934b332aac3543be36e1507c2f6e1c7f829/fpdf/html.py#L1196-L1211" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class HTMLMixin:
    &#34;&#34;&#34;
    [**DEPRECATED since v2.6.0**]
    You can now directly use the `FPDF.write_html()` method
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        warnings.warn(
            (
                &#34;The HTMLMixin class is deprecated since v2.6.0. &#34;
                &#34;Simply use the FPDF class as a replacement.&#34;
            ),
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fpdf.html.color_as_decimal" href="#fpdf.html.color_as_decimal">color_as_decimal</a></code></li>
<li><code><a title="fpdf.html.ol_prefix" href="#fpdf.html.ol_prefix">ol_prefix</a></code></li>
<li><code><a title="fpdf.html.parse_css_style" href="#fpdf.html.parse_css_style">parse_css_style</a></code></li>
<li><code><a title="fpdf.html.ul_prefix" href="#fpdf.html.ul_prefix">ul_prefix</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.html.HTML2FPDF" href="#fpdf.html.HTML2FPDF">HTML2FPDF</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.html.HTML2FPDF.HTML_UNCLOSED_TAGS" href="#fpdf.html.HTML2FPDF.HTML_UNCLOSED_TAGS">HTML_UNCLOSED_TAGS</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.TABLE_LINE_HEIGHT" href="#fpdf.html.HTML2FPDF.TABLE_LINE_HEIGHT">TABLE_LINE_HEIGHT</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.error" href="#fpdf.html.HTML2FPDF.error">error</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.feed" href="#fpdf.html.HTML2FPDF.feed">feed</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.handle_data" href="#fpdf.html.HTML2FPDF.handle_data">handle_data</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.handle_endtag" href="#fpdf.html.HTML2FPDF.handle_endtag">handle_endtag</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.handle_starttag" href="#fpdf.html.HTML2FPDF.handle_starttag">handle_starttag</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.put_link" href="#fpdf.html.HTML2FPDF.put_link">put_link</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.render_toc" href="#fpdf.html.HTML2FPDF.render_toc">render_toc</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.html.HTMLMixin" href="#fpdf.html.HTMLMixin">HTMLMixin</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
