<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fpdf.html API documentation</title>
<meta name="description" content="HTML renderer" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.html</code></h1>
</header>
<section id="section-intro">
<p>HTML renderer</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L1-L738" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;HTML renderer&#34;

import logging, warnings
from html.parser import HTMLParser

from .enums import TextEmphasis, XPos, YPos
from .errors import FPDFException
from .deprecation import get_stack_level
from .fonts import FontFace
from .table import Table, TableBordersLayout

import re

LOGGER = logging.getLogger(__name__)
BULLET_WIN1252 = &#34;\x95&#34;  # BULLET character in Windows-1252 encoding
DEFAULT_HEADING_SIZES = dict(h1=24, h2=18, h3=14, h4=12, h5=10, h6=8)
LEADING_SPACE = re.compile(r&#34;^\s+&#34;)
WHITESPACE = re.compile(r&#34;(\s)(\s*)&#34;)
TRAILING_SPACE = re.compile(r&#34;\s$&#34;)

COLOR_DICT = {
    &#34;black&#34;: &#34;#000000&#34;,
    &#34;navy&#34;: &#34;#000080&#34;,
    &#34;darkblue&#34;: &#34;#00008b&#34;,
    &#34;mediumblue&#34;: &#34;#0000cd&#34;,
    &#34;blue&#34;: &#34;#0000ff&#34;,
    &#34;darkgreen&#34;: &#34;#006400&#34;,
    &#34;green&#34;: &#34;#008000&#34;,
    &#34;teal&#34;: &#34;#008080&#34;,
    &#34;darkcyan&#34;: &#34;#008b8b&#34;,
    &#34;deepskyblue&#34;: &#34;#00bfff&#34;,
    &#34;darkturquoise&#34;: &#34;#00ced1&#34;,
    &#34;mediumspringgreen&#34;: &#34;#00fa9a&#34;,
    &#34;lime&#34;: &#34;#00ff00&#34;,
    &#34;springgreen&#34;: &#34;#00ff7f&#34;,
    &#34;aqua&#34;: &#34;#00ffff&#34;,
    &#34;cyan&#34;: &#34;#00ffff&#34;,
    &#34;midnightblue&#34;: &#34;#191970&#34;,
    &#34;dodgerblue&#34;: &#34;#1e90ff&#34;,
    &#34;lightseagreen&#34;: &#34;#20b2aa&#34;,
    &#34;forestgreen&#34;: &#34;#228b22&#34;,
    &#34;seagreen&#34;: &#34;#2e8b57&#34;,
    &#34;darkslategray&#34;: &#34;#2f4f4f&#34;,
    &#34;darkslategrey&#34;: &#34;#2f4f4f&#34;,
    &#34;limegreen&#34;: &#34;#32cd32&#34;,
    &#34;mediumseagreen&#34;: &#34;#3cb371&#34;,
    &#34;turquoise&#34;: &#34;#40e0d0&#34;,
    &#34;royalblue&#34;: &#34;#4169e1&#34;,
    &#34;steelblue&#34;: &#34;#4682b4&#34;,
    &#34;darkslateblue&#34;: &#34;#483d8b&#34;,
    &#34;mediumturquoise&#34;: &#34;#48d1cc&#34;,
    &#34;indigo&#34;: &#34;#4b0082&#34;,
    &#34;darkolivegreen&#34;: &#34;#556b2f&#34;,
    &#34;cadetblue&#34;: &#34;#5f9ea0&#34;,
    &#34;cornflowerblue&#34;: &#34;#6495ed&#34;,
    &#34;rebeccapurple&#34;: &#34;#663399&#34;,
    &#34;mediumaquamarine&#34;: &#34;#66cdaa&#34;,
    &#34;dimgray&#34;: &#34;#696969&#34;,
    &#34;dimgrey&#34;: &#34;#696969&#34;,
    &#34;slateblue&#34;: &#34;#6a5acd&#34;,
    &#34;olivedrab&#34;: &#34;#6b8e23&#34;,
    &#34;slategray&#34;: &#34;#708090&#34;,
    &#34;slategrey&#34;: &#34;#708090&#34;,
    &#34;lightslategray&#34;: &#34;#778899&#34;,
    &#34;lightslategrey&#34;: &#34;#778899&#34;,
    &#34;mediumslateblue&#34;: &#34;#7b68ee&#34;,
    &#34;lawngreen&#34;: &#34;#7cfc00&#34;,
    &#34;chartreuse&#34;: &#34;#7fff00&#34;,
    &#34;aquamarine&#34;: &#34;#7fffd4&#34;,
    &#34;maroon&#34;: &#34;#800000&#34;,
    &#34;purple&#34;: &#34;#800080&#34;,
    &#34;olive&#34;: &#34;#808000&#34;,
    &#34;gray&#34;: &#34;#808080&#34;,
    &#34;grey&#34;: &#34;#808080&#34;,
    &#34;skyblue&#34;: &#34;#87ceeb&#34;,
    &#34;lightskyblue&#34;: &#34;#87cefa&#34;,
    &#34;blueviolet&#34;: &#34;#8a2be2&#34;,
    &#34;darkred&#34;: &#34;#8b0000&#34;,
    &#34;darkmagenta&#34;: &#34;#8b008b&#34;,
    &#34;saddlebrown&#34;: &#34;#8b4513&#34;,
    &#34;darkseagreen&#34;: &#34;#8fbc8f&#34;,
    &#34;lightgreen&#34;: &#34;#90ee90&#34;,
    &#34;mediumpurple&#34;: &#34;#9370db&#34;,
    &#34;darkviolet&#34;: &#34;#9400d3&#34;,
    &#34;palegreen&#34;: &#34;#98fb98&#34;,
    &#34;darkorchid&#34;: &#34;#9932cc&#34;,
    &#34;yellowgreen&#34;: &#34;#9acd32&#34;,
    &#34;sienna&#34;: &#34;#a0522d&#34;,
    &#34;brown&#34;: &#34;#a52a2a&#34;,
    &#34;darkgray&#34;: &#34;#a9a9a9&#34;,
    &#34;darkgrey&#34;: &#34;#a9a9a9&#34;,
    &#34;lightblue&#34;: &#34;#add8e6&#34;,
    &#34;greenyellow&#34;: &#34;#adff2f&#34;,
    &#34;paleturquoise&#34;: &#34;#afeeee&#34;,
    &#34;lightsteelblue&#34;: &#34;#b0c4de&#34;,
    &#34;powderblue&#34;: &#34;#b0e0e6&#34;,
    &#34;firebrick&#34;: &#34;#b22222&#34;,
    &#34;darkgoldenrod&#34;: &#34;#b8860b&#34;,
    &#34;mediumorchid&#34;: &#34;#ba55d3&#34;,
    &#34;rosybrown&#34;: &#34;#bc8f8f&#34;,
    &#34;darkkhaki&#34;: &#34;#bdb76b&#34;,
    &#34;silver&#34;: &#34;#c0c0c0&#34;,
    &#34;mediumvioletred&#34;: &#34;#c71585&#34;,
    &#34;indianred&#34;: &#34;#cd5c5c&#34;,
    &#34;peru&#34;: &#34;#cd853f&#34;,
    &#34;chocolate&#34;: &#34;#d2691e&#34;,
    &#34;tan&#34;: &#34;#d2b48c&#34;,
    &#34;lightgray&#34;: &#34;#d3d3d3&#34;,
    &#34;lightgrey&#34;: &#34;#d3d3d3&#34;,
    &#34;thistle&#34;: &#34;#d8bfd8&#34;,
    &#34;orchid&#34;: &#34;#da70d6&#34;,
    &#34;goldenrod&#34;: &#34;#daa520&#34;,
    &#34;palevioletred&#34;: &#34;#db7093&#34;,
    &#34;crimson&#34;: &#34;#dc143c&#34;,
    &#34;gainsboro&#34;: &#34;#dcdcdc&#34;,
    &#34;plum&#34;: &#34;#dda0dd&#34;,
    &#34;burlywood&#34;: &#34;#deb887&#34;,
    &#34;lightcyan&#34;: &#34;#e0ffff&#34;,
    &#34;lavender&#34;: &#34;#e6e6fa&#34;,
    &#34;darksalmon&#34;: &#34;#e9967a&#34;,
    &#34;violet&#34;: &#34;#ee82ee&#34;,
    &#34;palegoldenrod&#34;: &#34;#eee8aa&#34;,
    &#34;lightcoral&#34;: &#34;#f08080&#34;,
    &#34;khaki&#34;: &#34;#f0e68c&#34;,
    &#34;aliceblue&#34;: &#34;#f0f8ff&#34;,
    &#34;honeydew&#34;: &#34;#f0fff0&#34;,
    &#34;azure&#34;: &#34;#f0ffff&#34;,
    &#34;sandybrown&#34;: &#34;#f4a460&#34;,
    &#34;wheat&#34;: &#34;#f5deb3&#34;,
    &#34;beige&#34;: &#34;#f5f5dc&#34;,
    &#34;whitesmoke&#34;: &#34;#f5f5f5&#34;,
    &#34;mintcream&#34;: &#34;#f5fffa&#34;,
    &#34;ghostwhite&#34;: &#34;#f8f8ff&#34;,
    &#34;salmon&#34;: &#34;#fa8072&#34;,
    &#34;antiquewhite&#34;: &#34;#faebd7&#34;,
    &#34;linen&#34;: &#34;#faf0e6&#34;,
    &#34;lightgoldenrodyellow&#34;: &#34;#fafad2&#34;,
    &#34;oldlace&#34;: &#34;#fdf5e6&#34;,
    &#34;red&#34;: &#34;#ff0000&#34;,
    &#34;fuchsia&#34;: &#34;#ff00ff&#34;,
    &#34;magenta&#34;: &#34;#ff00ff&#34;,
    &#34;deeppink&#34;: &#34;#ff1493&#34;,
    &#34;orangered&#34;: &#34;#ff4500&#34;,
    &#34;tomato&#34;: &#34;#ff6347&#34;,
    &#34;hotpink&#34;: &#34;#ff69b4&#34;,
    &#34;coral&#34;: &#34;#ff7f50&#34;,
    &#34;darkorange&#34;: &#34;#ff8c00&#34;,
    &#34;lightsalmon&#34;: &#34;#ffa07a&#34;,
    &#34;orange&#34;: &#34;#ffa500&#34;,
    &#34;lightpink&#34;: &#34;#ffb6c1&#34;,
    &#34;pink&#34;: &#34;#ffc0cb&#34;,
    &#34;gold&#34;: &#34;#ffd700&#34;,
    &#34;peachpuff&#34;: &#34;#ffdab9&#34;,
    &#34;navajowhite&#34;: &#34;#ffdead&#34;,
    &#34;moccasin&#34;: &#34;#ffe4b5&#34;,
    &#34;bisque&#34;: &#34;#ffe4c4&#34;,
    &#34;mistyrose&#34;: &#34;#ffe4e1&#34;,
    &#34;blanchedalmond&#34;: &#34;#ffebcd&#34;,
    &#34;papayawhip&#34;: &#34;#ffefd5&#34;,
    &#34;lavenderblush&#34;: &#34;#fff0f5&#34;,
    &#34;seashell&#34;: &#34;#fff5ee&#34;,
    &#34;cornsilk&#34;: &#34;#fff8dc&#34;,
    &#34;lemonchiffon&#34;: &#34;#fffacd&#34;,
    &#34;floralwhite&#34;: &#34;#fffaf0&#34;,
    &#34;snow&#34;: &#34;#fffafa&#34;,
    &#34;yellow&#34;: &#34;#ffff00&#34;,
    &#34;lightyellow&#34;: &#34;#ffffe0&#34;,
    &#34;ivory&#34;: &#34;#fffff0&#34;,
    &#34;white&#34;: &#34;#ffffff&#34;,
}


def px2mm(px):
    return px * 25.4 / 72


def color_as_decimal(color=&#34;#000000&#34;):
    if not color:
        return None

    # Checks if color is a name and gets the hex value
    hexcolor = COLOR_DICT.get(color.lower(), color)

    if len(hexcolor) == 4:
        r = int(hexcolor[1] * 2, 16)
        g = int(hexcolor[2] * 2, 16)
        b = int(hexcolor[3] * 2, 16)
        return r, g, b

    r = int(hexcolor[1:3], 16)
    g = int(hexcolor[3:5], 16)
    b = int(hexcolor[5:7], 16)
    return r, g, b


class HTML2FPDF(HTMLParser):
    &#34;Render basic HTML to FPDF&#34;

    HTML_UNCLOSED_TAGS = (&#34;br&#34;, &#34;dd&#34;, &#34;dt&#34;, &#34;hr&#34;, &#34;img&#34;, &#34;li&#34;, &#34;td&#34;, &#34;tr&#34;)

    def __init__(
        self,
        pdf,
        image_map=None,
        li_tag_indent=5,
        dd_tag_indent=10,
        table_line_separators=False,
        ul_bullet_char=BULLET_WIN1252,
        heading_sizes=None,
        pre_code_font=&#34;courier&#34;,
        warn_on_tags_not_matching=True,
        **_,
    ):
        &#34;&#34;&#34;
        Args:
            pdf (FPDF): an instance of `fpdf.FPDF`
            image_map (function): an optional one-argument function that map &lt;img&gt; &#34;src&#34;
                to new image URLs
            li_tag_indent (int): numeric indentation of &lt;li&gt; elements
            dd_tag_indent (int): numeric indentation of &lt;dd&gt; elements
            table_line_separators (bool): enable horizontal line separators in &lt;table&gt;
            ul_bullet_char (str): bullet character for &lt;ul&gt; elements
            heading_sizes (dict): font size per heading level names (&#34;h1&#34;, &#34;h2&#34;...)
            pre_code_font (str): font to use for &lt;pre&gt; &amp; &lt;code&gt; blocks
            warn_on_tags_not_matching (bool): control warnings production for unmatched HTML tags
        &#34;&#34;&#34;
        super().__init__()
        self.pdf = pdf
        self.image_map = image_map or (lambda src: src)
        self.li_tag_indent = li_tag_indent
        self.dd_tag_indent = dd_tag_indent
        self.ul_bullet_char = ul_bullet_char
        self.style = dict(b=False, i=False, u=False)
        self.pre_formatted = False
        self.follows_fmt_tag = False
        self.follows_trailing_space = False
        self.href = &#34;&#34;
        self.align = &#34;&#34;
        self.page_links = {}
        self.font_stack = []
        self.indent = 0
        self.bullet = []
        self.font_size = pdf.font_size_pt
        self.set_font(pdf.font_family or &#34;times&#34;, size=self.font_size)
        self.font_color = tuple((255 * v for v in pdf.text_color.colors))
        self.heading_level = None
        self.heading_sizes = dict(**DEFAULT_HEADING_SIZES)
        self.heading_above = 0.2  # extra space above heading, relative to font size
        self.heading_below = 0.2  # extra space below heading, relative to font size
        if heading_sizes:
            self.heading_sizes.update(heading_sizes)
        self.pre_code_font = pre_code_font
        self.warn_on_tags_not_matching = warn_on_tags_not_matching
        self._tags_stack = []
        # &lt;table&gt;-related properties:
        self.table_line_separators = table_line_separators
        self.table = None  # becomes a Table instance when processing &lt;table&gt; tags
        self.table_row = None  # becomes a Row instance when processing &lt;tr&gt; tags
        self.tr = None  # becomes a dict of attributes when processing &lt;tr&gt; tags
        self.td_th = None  # becomes a dict of attributes when processing &lt;td&gt;/&lt;th&gt; tags
        # &#34;inserted&#34; is a special attribute indicating that a cell has be inserted in self.table_row

    def handle_data(self, data):
        trailing_space_flag = TRAILING_SPACE.search(data)
        if self.td_th is not None:
            data = data.strip()
            if not data:
                return
            if &#34;inserted&#34; in self.td_th:
                td_th_tag = self.td_th[&#34;tag&#34;]
                raise NotImplementedError(
                    f&#34;Unsupported nested HTML tags inside &lt;{td_th_tag}&gt; element: &lt;{self._tags_stack[-1]}&gt;&#34;
                )
                # We could potentially support nested &lt;b&gt; / &lt;em&gt; / &lt;font&gt; tags
                # by building a list of Fragment instances from the HTML cell content
                # and then passing those fragments to Row.cell().
                # However there should be an incoming refactoring of this code
                # dedicated to text layout, and we should probably wait for that
                # before supporting this feature.
            align = self.td_th.get(&#34;align&#34;, self.tr.get(&#34;align&#34;))
            if align:
                align = align.upper()
            bgcolor = color_as_decimal(
                self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
            )
            colspan = int(self.td_th.get(&#34;colspan&#34;, &#34;1&#34;))
            emphasis = 0
            if self.td_th.get(&#34;b&#34;):
                emphasis |= TextEmphasis.B
            if self.td_th.get(&#34;i&#34;):
                emphasis |= TextEmphasis.I
            if self.td_th.get(&#34;U&#34;):
                emphasis |= TextEmphasis.U
            style = None
            if bgcolor or emphasis:
                style = FontFace(emphasis=emphasis, fill_color=bgcolor)
            self.table_row.cell(text=data, align=align, style=style, colspan=colspan)
            self.td_th[&#34;inserted&#34;] = True
        elif self.table is not None:
            # ignore anything else than td inside a table
            pass
        elif self.align:
            LOGGER.debug(&#34;align &#39;%s&#39;&#34;, data.replace(&#34;\n&#34;, &#34;\\n&#34;))
            self.pdf.multi_cell(
                0,
                self.h,
                data,
                border=0,
                new_x=XPos.LMARGIN,
                new_y=YPos.NEXT,
                align=self.align[0].upper(),
                link=self.href,
            )
        elif self.pre_formatted:  # for pre blocks
            self.pdf.write(self.h, data)

        elif self.follows_fmt_tag and not self.follows_trailing_space:
            # don&#39;t trim leading whitespace if following a format tag with no trailing whitespace
            data = WHITESPACE.sub(whitespace_repl, data)
            if trailing_space_flag:
                self.follows_trailing_space = True
            if self.href:
                self.put_link(data)
            else:
                if self.heading_level:
                    self.pdf.start_section(data, self.heading_level - 1, strict=False)
                LOGGER.debug(
                    &#34;write &#39;%s&#39; h=%d&#34;,
                    WHITESPACE.sub(whitespace_repl, data),
                    self.h,
                )
                self.pdf.write(self.h, data)
            self.follows_fmt_tag = False

        else:
            data = LEADING_SPACE.sub(leading_whitespace_repl, data)
            data = WHITESPACE.sub(whitespace_repl, data)
            self.follows_trailing_space = trailing_space_flag
            if self.href:
                self.put_link(data)
            else:
                if self.heading_level:
                    self.pdf.start_section(data, self.heading_level - 1, strict=False)
                LOGGER.debug(
                    f&#34;write: &#39;%s&#39; h={self.h:.2f}&#34;,
                    WHITESPACE.sub(whitespace_repl, data),
                )
                self.pdf.write(self.h, data)
            self.follows_fmt_tag = False

    def handle_starttag(self, tag, attrs):
        attrs = dict(attrs)
        LOGGER.debug(&#34;STARTTAG %s %s&#34;, tag, attrs)
        self._tags_stack.append(tag)
        if tag == &#34;dt&#34;:
            self.pdf.ln(self.h)
            tag = &#34;b&#34;
        if tag == &#34;dd&#34;:
            self.pdf.ln(self.h)
            self.pdf.write(self.h, &#34; &#34; * self.dd_tag_indent)
        if tag == &#34;strong&#34;:
            tag = &#34;b&#34;
        if tag == &#34;em&#34;:
            tag = &#34;i&#34;
        if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
            if self.td_th is not None:
                self.td_th[tag] = True
            else:
                self.set_style(tag, True)
        if tag == &#34;a&#34;:
            self.href = attrs[&#34;href&#34;]
        if tag == &#34;br&#34;:
            self.pdf.ln(self.h)
        if tag == &#34;p&#34;:
            self.pdf.ln(self.h)
            if &#34;align&#34; in attrs:
                self.align = attrs.get(&#34;align&#34;)
            if &#34;line-height&#34; in attrs:
                line_height = float(attrs.get(&#34;line-height&#34;))
                self.h = px2mm(self.font_size) * line_height
        if tag in self.heading_sizes:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.heading_level = int(tag[1:])
            hsize = self.heading_sizes[tag]
            color = (
                color_as_decimal(attrs[&#34;color&#34;]) if &#34;color&#34; in attrs else (150, 0, 0)
            )
            self.pdf.set_text_color(*color)
            self.pdf.ln(self.h + self.heading_above * hsize)  # more space above heading
            self.set_font(size=hsize)
            if attrs:
                self.align = attrs.get(&#34;align&#34;)
        if tag == &#34;hr&#34;:
            self.pdf.add_page(same=True)
        if tag == &#34;code&#34;:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.set_font(self.pre_code_font, 11)
        if tag == &#34;pre&#34;:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.set_font(self.pre_code_font, 11)
            self.pre_formatted = True
        if tag == &#34;blockquote&#34;:
            self.pdf.set_text_color(100, 0, 45)
            self.indent += 1
            self.pdf.ln(3)
        if tag == &#34;ul&#34;:
            self.indent += 1
            self.bullet.append(self.ul_bullet_char)
        if tag == &#34;ol&#34;:
            self.indent += 1
            self.bullet.append(0)
        if tag == &#34;li&#34;:
            self.pdf.ln(self.h + 2)
            self.pdf.set_text_color(190, 0, 0)
            bullet = self.bullet[self.indent - 1]
            if not isinstance(bullet, str):
                bullet += 1
                self.bullet[self.indent - 1] = bullet
                bullet = f&#34;{bullet}. &#34;
            self.pdf.write(self.h, f&#34;{&#39; &#39; * self.li_tag_indent * self.indent}{bullet} &#34;)
            self.set_text_color(*self.font_color)
        if tag == &#34;font&#34;:
            # save previous font state:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            if &#34;color&#34; in attrs:
                color = color_as_decimal(attrs[&#34;color&#34;])
                self.font_color = color
            if &#34;face&#34; in attrs:
                face = attrs.get(&#34;face&#34;).lower()
                try:
                    self.pdf.set_font(face)
                    self.font_face = face
                except RuntimeError:
                    pass  # font not found, ignore
            if &#34;size&#34; in attrs:
                self.font_size = int(attrs.get(&#34;size&#34;))
            self.set_font()
            self.set_text_color(*self.font_color)
        if tag == &#34;table&#34;:
            width = attrs.get(&#34;width&#34;)
            if width:
                if width[-1] == &#34;%&#34;:
                    width = self.pdf.epw * int(width[:-1]) / 100
                else:
                    width = px2mm(int(width))
            if &#34;border&#34; in attrs:
                borders_layout = (
                    &#34;ALL&#34; if self.table_line_separators else &#34;NO_HORIZONTAL_LINES&#34;
                )
            else:
                borders_layout = (
                    &#34;HORIZONTAL_LINES&#34;
                    if self.table_line_separators
                    else &#34;SINGLE_TOP_LINE&#34;
                )
            align = attrs.get(&#34;align&#34;, &#34;center&#34;).upper()
            self.table = Table(
                self.pdf,
                align=align,
                borders_layout=borders_layout,
                line_height=self.h * 1.30,
                width=width,
            )
            self.pdf.ln()
        if tag == &#34;tr&#34;:
            if not self.table:
                raise FPDFException(&#34;Invalid HTML: &lt;tr&gt; used outside any &lt;table&gt;&#34;)
            self.tr = {k.lower(): v for k, v in attrs.items()}
            self.table_row = self.table.row()
        if tag in (&#34;td&#34;, &#34;th&#34;):
            if not self.table_row:
                raise FPDFException(f&#34;Invalid HTML: &lt;{tag}&gt; used outside any &lt;tr&gt;&#34;)
            self.td_th = {k.lower(): v for k, v in attrs.items()}
            self.td_th[&#34;tag&#34;] = tag
            if tag == &#34;th&#34;:
                self.td_th[&#34;align&#34;] = &#34;CENTER&#34;
                self.td_th[&#34;b&#34;] = True
            elif len(self.table.rows) == 1 and not self.table_row.cells:
                # =&gt; we are in the 1st &lt;tr&gt;, and the 1st cell is a &lt;td&gt;
                # =&gt; we do not treat the first row as a header
                # pylint: disable=protected-access
                self.table._borders_layout = TableBordersLayout.NONE
                self.table._first_row_as_headings = False
            if &#34;height&#34; in attrs:
                LOGGER.warning(
                    &#39;Ignoring unsupported height=&#34;%s&#34; specified on a &lt;%s&gt;&#39;,
                    attrs[&#34;height&#34;],
                    tag,
                )
            if &#34;width&#34; in attrs:
                width = attrs[&#34;width&#34;]
                # pylint: disable=protected-access
                if len(self.table.rows) == 1:  # =&gt; first table row
                    if width[-1] == &#34;%&#34;:
                        width = width[:-1]
                    if not self.table._col_widths:
                        self.table._col_widths = []
                    self.table._col_widths.append(int(width))
                else:
                    LOGGER.warning(
                        &#39;Ignoring width=&#34;%s&#34; specified on a &lt;%s&gt; that is not in the first &lt;tr&gt;&#39;,
                        width,
                        tag,
                    )
        if tag == &#34;img&#34; and &#34;src&#34; in attrs:
            width = px2mm(int(attrs.get(&#34;width&#34;, 0)))
            height = px2mm(int(attrs.get(&#34;height&#34;, 0)))
            if self.table_row:  # =&gt; &lt;img&gt; in a &lt;table&gt;
                if width or height:
                    LOGGER.warning(
                        &#39;Ignoring unsupported &#34;width&#34; / &#34;height&#34; set on &lt;img&gt; element&#39;
                    )
                if self.align:
                    LOGGER.warning(&#34;Ignoring unsupported &lt;img&gt; alignment&#34;)
                self.table_row.cell(img=attrs[&#34;src&#34;], img_fill_width=True)
                self.td_th[&#34;inserted&#34;] = True
                return
            if self.pdf.y + height &gt; self.pdf.page_break_trigger:
                self.pdf.add_page(same=True)
            x, y = self.pdf.get_x(), self.pdf.get_y()
            if self.align and self.align[0].upper() == &#34;C&#34;:
                x = self.pdf.w / 2 - width / 2
            LOGGER.debug(
                &#39;image &#34;%s&#34; x=%d y=%d width=%d height=%d&#39;,
                attrs[&#34;src&#34;],
                x,
                y,
                width,
                height,
            )
            info = self.pdf.image(
                self.image_map(attrs[&#34;src&#34;]), x, y, width, height, link=self.href
            )
            self.pdf.set_y(y + info.rendered_height)
        if tag == &#34;center&#34;:
            self.align = &#34;Center&#34;
        if tag == &#34;toc&#34;:
            self.pdf.insert_toc_placeholder(
                self.render_toc, pages=int(attrs.get(&#34;pages&#34;, 1))
            )
        if tag == &#34;sup&#34;:
            self.pdf.char_vpos = &#34;SUP&#34;
        if tag == &#34;sub&#34;:
            self.pdf.char_vpos = &#34;SUB&#34;

    def handle_endtag(self, tag):
        LOGGER.debug(&#34;ENDTAG %s&#34;, tag)
        while (
            self._tags_stack
            and tag != self._tags_stack[-1]
            and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS
        ):
            self._tags_stack.pop()
        if not self._tags_stack:
            if self.warn_on_tags_not_matching:
                LOGGER.warning(
                    &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag may be missing?&#34;, tag
                )
        elif tag == self._tags_stack[-1]:
            self._tags_stack.pop()
        elif self.warn_on_tags_not_matching:
            LOGGER.warning(
                &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag was &lt;%s&gt;&#34;,
                tag,
                self._tags_stack[-1],
            )
        if tag in self.heading_sizes:
            self.heading_level = None
            face, size, color = self.font_stack.pop()
            # more space below heading:
            self.pdf.ln(self.h + self.h * self.heading_below)
            self.set_font(face, size)
            self.set_text_color(*color)
            self.align = None
        if tag == &#34;code&#34;:
            face, size, color = self.font_stack.pop()
            self.set_font(face, size)
            self.set_text_color(*color)
        if tag == &#34;pre&#34;:
            face, size, color = self.font_stack.pop()
            self.set_font(face, size)
            self.set_text_color(*color)
            self.pre_formatted = False
        if tag == &#34;blockquote&#34;:
            self.set_text_color(*self.font_color)
            self.indent -= 1
            self.pdf.ln(3)
        if tag in (&#34;strong&#34;, &#34;dt&#34;):
            tag = &#34;b&#34;
        if tag == &#34;em&#34;:
            tag = &#34;i&#34;
        if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
            if not self.td_th is not None:
                self.set_style(tag, False)
            self.follows_fmt_tag = True
        if tag == &#34;a&#34;:
            self.href = &#34;&#34;
        if tag == &#34;p&#34;:
            self.pdf.ln(self.h)
            self.align = &#34;&#34;
            self.h = px2mm(self.font_size)
        if tag in (&#34;ul&#34;, &#34;ol&#34;):
            self.indent -= 1
            self.bullet.pop()
        if tag == &#34;table&#34;:
            self.table.render()
            self.table = None
            self.pdf.ln(self.h)
        if tag == &#34;tr&#34;:
            self.tr = None
            self.table_row = None
        if tag in (&#34;td&#34;, &#34;th&#34;):
            if &#34;inserted&#34; not in self.td_th:
                # handle_data() was not called =&gt; we call it to produce an empty cell:
                bgcolor = color_as_decimal(
                    self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
                )
                style = FontFace(fill_color=bgcolor) if bgcolor else None
                self.table_row.cell(text=&#34;&#34;, style=style)
            self.td_th = None
        if tag == &#34;font&#34;:
            # recover last font state
            face, size, color = self.font_stack.pop()
            self.font_color = color
            self.set_font(face, size)
            self.set_text_color(*self.font_color)
        if tag == &#34;center&#34;:
            self.align = None
        if tag == &#34;sup&#34;:
            self.pdf.char_vpos = &#34;LINE&#34;
            self.follows_fmt_tag = True
        if tag == &#34;sub&#34;:
            self.pdf.char_vpos = &#34;LINE&#34;
            self.follows_fmt_tag = True

    def feed(self, data):
        super().feed(data)
        while self._tags_stack and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS:
            self._tags_stack.pop()
        if self._tags_stack and self.warn_on_tags_not_matching:
            LOGGER.warning(&#34;Missing HTML end tag for &lt;%s&gt;&#34;, self._tags_stack[-1])

    def set_font(self, face=None, size=None):
        if face:
            self.font_face = face
        if size:
            self.font_size = size
            self.h = px2mm(size)
        style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s)).upper()
        LOGGER.debug(f&#34;set_font: %s style=%s h={self.h:.2f}&#34;, self.font_face, style)
        if (self.font_face, style) != (self.pdf.font_family, self.pdf.font_style):
            self.pdf.set_font(self.font_face, style, self.font_size)
        if self.font_size != self.pdf.font_size:
            self.pdf.set_font_size(self.font_size)

    def set_style(self, tag=None, enable=False):
        # Modify style and select corresponding font
        if tag:
            self.style[tag.lower()] = enable
        style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s))
        LOGGER.debug(&#34;SET_FONT_STYLE %s&#34;, style)
        self.pdf.set_font(style=style)

    def set_text_color(self, r=None, g=0, b=0):
        self.pdf.set_text_color(r, g, b)

    def put_link(self, txt):
        # Put a hyperlink
        self.set_text_color(0, 0, 255)
        self.set_style(&#34;u&#34;, True)
        self.pdf.write(self.h, txt, self.href)
        self.set_style(&#34;u&#34;, False)
        self.set_text_color(*self.font_color)

    # pylint: disable=no-self-use
    def render_toc(self, pdf, outline):
        &#34;This method can be overriden by subclasses to customize the Table of Contents style.&#34;
        pdf.ln()
        for section in outline:
            link = pdf.add_link(page=section.page_number)
            text = f&#39;{&#34; &#34; * section.level * 2} {section.name}&#39;
            text += f&#39; {&#34;.&#34; * (60 - section.level*2 - len(section.name))} {section.page_number}&#39;
            pdf.multi_cell(
                w=pdf.epw,
                h=pdf.font_size,
                txt=text,
                new_x=XPos.LMARGIN,
                new_y=YPos.NEXT,
                link=link,
            )

    # Subclasses of _markupbase.ParserBase must implement this:
    def error(self, message):
        raise RuntimeError(message)


def leading_whitespace_repl(matchobj):
    trimmed_str = &#34;&#34;
    for char in matchobj.group(0):  # check if leading whitespace contains nbsp
        if char == &#34;\u00a0&#34;:
            trimmed_str += &#34;\u00a0&#34;
        elif char == &#34;\u202f&#34;:
            trimmed_str += &#34;\u202f&#34;
    return trimmed_str


def whitespace_repl(matchobj):
    trimmed_str = &#34;&#34;
    for char in matchobj.group(
        1
    ):  # allow 1 whitespace char, check for narrow no-break space
        if char == &#34;\u202f&#34;:
            trimmed_str += &#34;\u202f&#34;
        else:
            trimmed_str += &#34; &#34;
    for char in matchobj.group(2):  # remove following whitespace char unless nbsp
        if char == &#34;\u00a0&#34;:
            trimmed_str += &#34;\u00a0&#34;
        elif char == &#34;\u202f&#34;:
            trimmed_str += &#34;\u202f&#34;
    return trimmed_str


class HTMLMixin:
    &#34;&#34;&#34;
    [**DEPRECATED since v2.6.0**]
    You can now directly use the `FPDF.write_html()` method
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        warnings.warn(
            # pylint: disable=implicit-str-concat
            &#34;The HTMLMixin class is deprecated. &#34;
            &#34;Simply use the FPDF class as a replacement.&#34;,
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fpdf.html.color_as_decimal"><code class="name flex">
<span>def <span class="ident">color_as_decimal</span></span>(<span>color='#000000')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L177-L193" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def color_as_decimal(color=&#34;#000000&#34;):
    if not color:
        return None

    # Checks if color is a name and gets the hex value
    hexcolor = COLOR_DICT.get(color.lower(), color)

    if len(hexcolor) == 4:
        r = int(hexcolor[1] * 2, 16)
        g = int(hexcolor[2] * 2, 16)
        b = int(hexcolor[3] * 2, 16)
        return r, g, b

    r = int(hexcolor[1:3], 16)
    g = int(hexcolor[3:5], 16)
    b = int(hexcolor[5:7], 16)
    return r, g, b</code></pre>
</details>
</dd>
<dt id="fpdf.html.leading_whitespace_repl"><code class="name flex">
<span>def <span class="ident">leading_whitespace_repl</span></span>(<span>matchobj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L697-L704" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def leading_whitespace_repl(matchobj):
    trimmed_str = &#34;&#34;
    for char in matchobj.group(0):  # check if leading whitespace contains nbsp
        if char == &#34;\u00a0&#34;:
            trimmed_str += &#34;\u00a0&#34;
        elif char == &#34;\u202f&#34;:
            trimmed_str += &#34;\u202f&#34;
    return trimmed_str</code></pre>
</details>
</dd>
<dt id="fpdf.html.px2mm"><code class="name flex">
<span>def <span class="ident">px2mm</span></span>(<span>px)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L173-L174" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def px2mm(px):
    return px * 25.4 / 72</code></pre>
</details>
</dd>
<dt id="fpdf.html.whitespace_repl"><code class="name flex">
<span>def <span class="ident">whitespace_repl</span></span>(<span>matchobj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L707-L721" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def whitespace_repl(matchobj):
    trimmed_str = &#34;&#34;
    for char in matchobj.group(
        1
    ):  # allow 1 whitespace char, check for narrow no-break space
        if char == &#34;\u202f&#34;:
            trimmed_str += &#34;\u202f&#34;
        else:
            trimmed_str += &#34; &#34;
    for char in matchobj.group(2):  # remove following whitespace char unless nbsp
        if char == &#34;\u00a0&#34;:
            trimmed_str += &#34;\u00a0&#34;
        elif char == &#34;\u202f&#34;:
            trimmed_str += &#34;\u202f&#34;
    return trimmed_str</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.html.HTML2FPDF"><code class="flex name class">
<span>class <span class="ident">HTML2FPDF</span></span>
<span>(</span><span>pdf, image_map=None, li_tag_indent=5, dd_tag_indent=10, table_line_separators=False, ul_bullet_char='\x95', heading_sizes=None, pre_code_font='courier', warn_on_tags_not_matching=True, **_)</span>
</code></dt>
<dd>
<div class="desc"><p>Render basic HTML to FPDF</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pdf</code></strong> :&ensp;<code>FPDF</code></dt>
<dd>an instance of <code><a title="fpdf.FPDF" href="index.html#fpdf.FPDF">FPDF</a></code></dd>
<dt><strong><code>image_map</code></strong> :&ensp;<code>function</code></dt>
<dd>an optional one-argument function that map <img> "src"
to new image URLs</dd>
<dt><strong><code>li_tag_indent</code></strong> :&ensp;<code>int</code></dt>
<dd>numeric indentation of <li> elements</dd>
<dt><strong><code>dd_tag_indent</code></strong> :&ensp;<code>int</code></dt>
<dd>numeric indentation of <dd> elements</dd>
<dt><strong><code>table_line_separators</code></strong> :&ensp;<code>bool</code></dt>
<dd>enable horizontal line separators in <table></dd>
<dt><strong><code>ul_bullet_char</code></strong> :&ensp;<code>str</code></dt>
<dd>bullet character for <ul> elements</dd>
<dt><strong><code>heading_sizes</code></strong> :&ensp;<code>dict</code></dt>
<dd>font size per heading level names ("h1", "h2"&hellip;)</dd>
<dt><strong><code>pre_code_font</code></strong> :&ensp;<code>str</code></dt>
<dd>font to use for <pre> &amp; <code> blocks</dd>
<dt><strong><code>warn_on_tags_not_matching</code></strong> :&ensp;<code>bool</code></dt>
<dd>control warnings production for unmatched HTML tags</dd>
</dl></div>
  
    
      <details class="source">
        <summary>
            <span>Expand source code</span>
              <a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L196-L694" class="git-link">Browse git</a>
        </summary>
        <pre><code class="python">class HTML2FPDF(HTMLParser):
    &#34;Render basic HTML to FPDF&#34;

    HTML_UNCLOSED_TAGS = (&#34;br&#34;, &#34;dd&#34;, &#34;dt&#34;, &#34;hr&#34;, &#34;img&#34;, &#34;li&#34;, &#34;td&#34;, &#34;tr&#34;)

    def __init__(
        self,
        pdf,
        image_map=None,
        li_tag_indent=5,
        dd_tag_indent=10,
        table_line_separators=False,
        ul_bullet_char=BULLET_WIN1252,
        heading_sizes=None,
        pre_code_font=&#34;courier&#34;,
        warn_on_tags_not_matching=True,
        **_,
    ):
        &#34;&#34;&#34;
        Args:
            pdf (FPDF): an instance of `fpdf.FPDF`
            image_map (function): an optional one-argument function that map &lt;img&gt; &#34;src&#34;
                to new image URLs
            li_tag_indent (int): numeric indentation of &lt;li&gt; elements
            dd_tag_indent (int): numeric indentation of &lt;dd&gt; elements
            table_line_separators (bool): enable horizontal line separators in &lt;table&gt;
            ul_bullet_char (str): bullet character for &lt;ul&gt; elements
            heading_sizes (dict): font size per heading level names (&#34;h1&#34;, &#34;h2&#34;...)
            pre_code_font (str): font to use for &lt;pre&gt; &amp; &lt;code&gt; blocks
            warn_on_tags_not_matching (bool): control warnings production for unmatched HTML tags
        &#34;&#34;&#34;
        super().__init__()
        self.pdf = pdf
        self.image_map = image_map or (lambda src: src)
        self.li_tag_indent = li_tag_indent
        self.dd_tag_indent = dd_tag_indent
        self.ul_bullet_char = ul_bullet_char
        self.style = dict(b=False, i=False, u=False)
        self.pre_formatted = False
        self.follows_fmt_tag = False
        self.follows_trailing_space = False
        self.href = &#34;&#34;
        self.align = &#34;&#34;
        self.page_links = {}
        self.font_stack = []
        self.indent = 0
        self.bullet = []
        self.font_size = pdf.font_size_pt
        self.set_font(pdf.font_family or &#34;times&#34;, size=self.font_size)
        self.font_color = tuple((255 * v for v in pdf.text_color.colors))
        self.heading_level = None
        self.heading_sizes = dict(**DEFAULT_HEADING_SIZES)
        self.heading_above = 0.2  # extra space above heading, relative to font size
        self.heading_below = 0.2  # extra space below heading, relative to font size
        if heading_sizes:
            self.heading_sizes.update(heading_sizes)
        self.pre_code_font = pre_code_font
        self.warn_on_tags_not_matching = warn_on_tags_not_matching
        self._tags_stack = []
        # &lt;table&gt;-related properties:
        self.table_line_separators = table_line_separators
        self.table = None  # becomes a Table instance when processing &lt;table&gt; tags
        self.table_row = None  # becomes a Row instance when processing &lt;tr&gt; tags
        self.tr = None  # becomes a dict of attributes when processing &lt;tr&gt; tags
        self.td_th = None  # becomes a dict of attributes when processing &lt;td&gt;/&lt;th&gt; tags
        # &#34;inserted&#34; is a special attribute indicating that a cell has be inserted in self.table_row

    def handle_data(self, data):
        trailing_space_flag = TRAILING_SPACE.search(data)
        if self.td_th is not None:
            data = data.strip()
            if not data:
                return
            if &#34;inserted&#34; in self.td_th:
                td_th_tag = self.td_th[&#34;tag&#34;]
                raise NotImplementedError(
                    f&#34;Unsupported nested HTML tags inside &lt;{td_th_tag}&gt; element: &lt;{self._tags_stack[-1]}&gt;&#34;
                )
                # We could potentially support nested &lt;b&gt; / &lt;em&gt; / &lt;font&gt; tags
                # by building a list of Fragment instances from the HTML cell content
                # and then passing those fragments to Row.cell().
                # However there should be an incoming refactoring of this code
                # dedicated to text layout, and we should probably wait for that
                # before supporting this feature.
            align = self.td_th.get(&#34;align&#34;, self.tr.get(&#34;align&#34;))
            if align:
                align = align.upper()
            bgcolor = color_as_decimal(
                self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
            )
            colspan = int(self.td_th.get(&#34;colspan&#34;, &#34;1&#34;))
            emphasis = 0
            if self.td_th.get(&#34;b&#34;):
                emphasis |= TextEmphasis.B
            if self.td_th.get(&#34;i&#34;):
                emphasis |= TextEmphasis.I
            if self.td_th.get(&#34;U&#34;):
                emphasis |= TextEmphasis.U
            style = None
            if bgcolor or emphasis:
                style = FontFace(emphasis=emphasis, fill_color=bgcolor)
            self.table_row.cell(text=data, align=align, style=style, colspan=colspan)
            self.td_th[&#34;inserted&#34;] = True
        elif self.table is not None:
            # ignore anything else than td inside a table
            pass
        elif self.align:
            LOGGER.debug(&#34;align &#39;%s&#39;&#34;, data.replace(&#34;\n&#34;, &#34;\\n&#34;))
            self.pdf.multi_cell(
                0,
                self.h,
                data,
                border=0,
                new_x=XPos.LMARGIN,
                new_y=YPos.NEXT,
                align=self.align[0].upper(),
                link=self.href,
            )
        elif self.pre_formatted:  # for pre blocks
            self.pdf.write(self.h, data)

        elif self.follows_fmt_tag and not self.follows_trailing_space:
            # don&#39;t trim leading whitespace if following a format tag with no trailing whitespace
            data = WHITESPACE.sub(whitespace_repl, data)
            if trailing_space_flag:
                self.follows_trailing_space = True
            if self.href:
                self.put_link(data)
            else:
                if self.heading_level:
                    self.pdf.start_section(data, self.heading_level - 1, strict=False)
                LOGGER.debug(
                    &#34;write &#39;%s&#39; h=%d&#34;,
                    WHITESPACE.sub(whitespace_repl, data),
                    self.h,
                )
                self.pdf.write(self.h, data)
            self.follows_fmt_tag = False

        else:
            data = LEADING_SPACE.sub(leading_whitespace_repl, data)
            data = WHITESPACE.sub(whitespace_repl, data)
            self.follows_trailing_space = trailing_space_flag
            if self.href:
                self.put_link(data)
            else:
                if self.heading_level:
                    self.pdf.start_section(data, self.heading_level - 1, strict=False)
                LOGGER.debug(
                    f&#34;write: &#39;%s&#39; h={self.h:.2f}&#34;,
                    WHITESPACE.sub(whitespace_repl, data),
                )
                self.pdf.write(self.h, data)
            self.follows_fmt_tag = False

    def handle_starttag(self, tag, attrs):
        attrs = dict(attrs)
        LOGGER.debug(&#34;STARTTAG %s %s&#34;, tag, attrs)
        self._tags_stack.append(tag)
        if tag == &#34;dt&#34;:
            self.pdf.ln(self.h)
            tag = &#34;b&#34;
        if tag == &#34;dd&#34;:
            self.pdf.ln(self.h)
            self.pdf.write(self.h, &#34; &#34; * self.dd_tag_indent)
        if tag == &#34;strong&#34;:
            tag = &#34;b&#34;
        if tag == &#34;em&#34;:
            tag = &#34;i&#34;
        if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
            if self.td_th is not None:
                self.td_th[tag] = True
            else:
                self.set_style(tag, True)
        if tag == &#34;a&#34;:
            self.href = attrs[&#34;href&#34;]
        if tag == &#34;br&#34;:
            self.pdf.ln(self.h)
        if tag == &#34;p&#34;:
            self.pdf.ln(self.h)
            if &#34;align&#34; in attrs:
                self.align = attrs.get(&#34;align&#34;)
            if &#34;line-height&#34; in attrs:
                line_height = float(attrs.get(&#34;line-height&#34;))
                self.h = px2mm(self.font_size) * line_height
        if tag in self.heading_sizes:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.heading_level = int(tag[1:])
            hsize = self.heading_sizes[tag]
            color = (
                color_as_decimal(attrs[&#34;color&#34;]) if &#34;color&#34; in attrs else (150, 0, 0)
            )
            self.pdf.set_text_color(*color)
            self.pdf.ln(self.h + self.heading_above * hsize)  # more space above heading
            self.set_font(size=hsize)
            if attrs:
                self.align = attrs.get(&#34;align&#34;)
        if tag == &#34;hr&#34;:
            self.pdf.add_page(same=True)
        if tag == &#34;code&#34;:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.set_font(self.pre_code_font, 11)
        if tag == &#34;pre&#34;:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            self.set_font(self.pre_code_font, 11)
            self.pre_formatted = True
        if tag == &#34;blockquote&#34;:
            self.pdf.set_text_color(100, 0, 45)
            self.indent += 1
            self.pdf.ln(3)
        if tag == &#34;ul&#34;:
            self.indent += 1
            self.bullet.append(self.ul_bullet_char)
        if tag == &#34;ol&#34;:
            self.indent += 1
            self.bullet.append(0)
        if tag == &#34;li&#34;:
            self.pdf.ln(self.h + 2)
            self.pdf.set_text_color(190, 0, 0)
            bullet = self.bullet[self.indent - 1]
            if not isinstance(bullet, str):
                bullet += 1
                self.bullet[self.indent - 1] = bullet
                bullet = f&#34;{bullet}. &#34;
            self.pdf.write(self.h, f&#34;{&#39; &#39; * self.li_tag_indent * self.indent}{bullet} &#34;)
            self.set_text_color(*self.font_color)
        if tag == &#34;font&#34;:
            # save previous font state:
            self.font_stack.append((self.font_face, self.font_size, self.font_color))
            if &#34;color&#34; in attrs:
                color = color_as_decimal(attrs[&#34;color&#34;])
                self.font_color = color
            if &#34;face&#34; in attrs:
                face = attrs.get(&#34;face&#34;).lower()
                try:
                    self.pdf.set_font(face)
                    self.font_face = face
                except RuntimeError:
                    pass  # font not found, ignore
            if &#34;size&#34; in attrs:
                self.font_size = int(attrs.get(&#34;size&#34;))
            self.set_font()
            self.set_text_color(*self.font_color)
        if tag == &#34;table&#34;:
            width = attrs.get(&#34;width&#34;)
            if width:
                if width[-1] == &#34;%&#34;:
                    width = self.pdf.epw * int(width[:-1]) / 100
                else:
                    width = px2mm(int(width))
            if &#34;border&#34; in attrs:
                borders_layout = (
                    &#34;ALL&#34; if self.table_line_separators else &#34;NO_HORIZONTAL_LINES&#34;
                )
            else:
                borders_layout = (
                    &#34;HORIZONTAL_LINES&#34;
                    if self.table_line_separators
                    else &#34;SINGLE_TOP_LINE&#34;
                )
            align = attrs.get(&#34;align&#34;, &#34;center&#34;).upper()
            self.table = Table(
                self.pdf,
                align=align,
                borders_layout=borders_layout,
                line_height=self.h * 1.30,
                width=width,
            )
            self.pdf.ln()
        if tag == &#34;tr&#34;:
            if not self.table:
                raise FPDFException(&#34;Invalid HTML: &lt;tr&gt; used outside any &lt;table&gt;&#34;)
            self.tr = {k.lower(): v for k, v in attrs.items()}
            self.table_row = self.table.row()
        if tag in (&#34;td&#34;, &#34;th&#34;):
            if not self.table_row:
                raise FPDFException(f&#34;Invalid HTML: &lt;{tag}&gt; used outside any &lt;tr&gt;&#34;)
            self.td_th = {k.lower(): v for k, v in attrs.items()}
            self.td_th[&#34;tag&#34;] = tag
            if tag == &#34;th&#34;:
                self.td_th[&#34;align&#34;] = &#34;CENTER&#34;
                self.td_th[&#34;b&#34;] = True
            elif len(self.table.rows) == 1 and not self.table_row.cells:
                # =&gt; we are in the 1st &lt;tr&gt;, and the 1st cell is a &lt;td&gt;
                # =&gt; we do not treat the first row as a header
                # pylint: disable=protected-access
                self.table._borders_layout = TableBordersLayout.NONE
                self.table._first_row_as_headings = False
            if &#34;height&#34; in attrs:
                LOGGER.warning(
                    &#39;Ignoring unsupported height=&#34;%s&#34; specified on a &lt;%s&gt;&#39;,
                    attrs[&#34;height&#34;],
                    tag,
                )
            if &#34;width&#34; in attrs:
                width = attrs[&#34;width&#34;]
                # pylint: disable=protected-access
                if len(self.table.rows) == 1:  # =&gt; first table row
                    if width[-1] == &#34;%&#34;:
                        width = width[:-1]
                    if not self.table._col_widths:
                        self.table._col_widths = []
                    self.table._col_widths.append(int(width))
                else:
                    LOGGER.warning(
                        &#39;Ignoring width=&#34;%s&#34; specified on a &lt;%s&gt; that is not in the first &lt;tr&gt;&#39;,
                        width,
                        tag,
                    )
        if tag == &#34;img&#34; and &#34;src&#34; in attrs:
            width = px2mm(int(attrs.get(&#34;width&#34;, 0)))
            height = px2mm(int(attrs.get(&#34;height&#34;, 0)))
            if self.table_row:  # =&gt; &lt;img&gt; in a &lt;table&gt;
                if width or height:
                    LOGGER.warning(
                        &#39;Ignoring unsupported &#34;width&#34; / &#34;height&#34; set on &lt;img&gt; element&#39;
                    )
                if self.align:
                    LOGGER.warning(&#34;Ignoring unsupported &lt;img&gt; alignment&#34;)
                self.table_row.cell(img=attrs[&#34;src&#34;], img_fill_width=True)
                self.td_th[&#34;inserted&#34;] = True
                return
            if self.pdf.y + height &gt; self.pdf.page_break_trigger:
                self.pdf.add_page(same=True)
            x, y = self.pdf.get_x(), self.pdf.get_y()
            if self.align and self.align[0].upper() == &#34;C&#34;:
                x = self.pdf.w / 2 - width / 2
            LOGGER.debug(
                &#39;image &#34;%s&#34; x=%d y=%d width=%d height=%d&#39;,
                attrs[&#34;src&#34;],
                x,
                y,
                width,
                height,
            )
            info = self.pdf.image(
                self.image_map(attrs[&#34;src&#34;]), x, y, width, height, link=self.href
            )
            self.pdf.set_y(y + info.rendered_height)
        if tag == &#34;center&#34;:
            self.align = &#34;Center&#34;
        if tag == &#34;toc&#34;:
            self.pdf.insert_toc_placeholder(
                self.render_toc, pages=int(attrs.get(&#34;pages&#34;, 1))
            )
        if tag == &#34;sup&#34;:
            self.pdf.char_vpos = &#34;SUP&#34;
        if tag == &#34;sub&#34;:
            self.pdf.char_vpos = &#34;SUB&#34;

    def handle_endtag(self, tag):
        LOGGER.debug(&#34;ENDTAG %s&#34;, tag)
        while (
            self._tags_stack
            and tag != self._tags_stack[-1]
            and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS
        ):
            self._tags_stack.pop()
        if not self._tags_stack:
            if self.warn_on_tags_not_matching:
                LOGGER.warning(
                    &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag may be missing?&#34;, tag
                )
        elif tag == self._tags_stack[-1]:
            self._tags_stack.pop()
        elif self.warn_on_tags_not_matching:
            LOGGER.warning(
                &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag was &lt;%s&gt;&#34;,
                tag,
                self._tags_stack[-1],
            )
        if tag in self.heading_sizes:
            self.heading_level = None
            face, size, color = self.font_stack.pop()
            # more space below heading:
            self.pdf.ln(self.h + self.h * self.heading_below)
            self.set_font(face, size)
            self.set_text_color(*color)
            self.align = None
        if tag == &#34;code&#34;:
            face, size, color = self.font_stack.pop()
            self.set_font(face, size)
            self.set_text_color(*color)
        if tag == &#34;pre&#34;:
            face, size, color = self.font_stack.pop()
            self.set_font(face, size)
            self.set_text_color(*color)
            self.pre_formatted = False
        if tag == &#34;blockquote&#34;:
            self.set_text_color(*self.font_color)
            self.indent -= 1
            self.pdf.ln(3)
        if tag in (&#34;strong&#34;, &#34;dt&#34;):
            tag = &#34;b&#34;
        if tag == &#34;em&#34;:
            tag = &#34;i&#34;
        if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
            if not self.td_th is not None:
                self.set_style(tag, False)
            self.follows_fmt_tag = True
        if tag == &#34;a&#34;:
            self.href = &#34;&#34;
        if tag == &#34;p&#34;:
            self.pdf.ln(self.h)
            self.align = &#34;&#34;
            self.h = px2mm(self.font_size)
        if tag in (&#34;ul&#34;, &#34;ol&#34;):
            self.indent -= 1
            self.bullet.pop()
        if tag == &#34;table&#34;:
            self.table.render()
            self.table = None
            self.pdf.ln(self.h)
        if tag == &#34;tr&#34;:
            self.tr = None
            self.table_row = None
        if tag in (&#34;td&#34;, &#34;th&#34;):
            if &#34;inserted&#34; not in self.td_th:
                # handle_data() was not called =&gt; we call it to produce an empty cell:
                bgcolor = color_as_decimal(
                    self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
                )
                style = FontFace(fill_color=bgcolor) if bgcolor else None
                self.table_row.cell(text=&#34;&#34;, style=style)
            self.td_th = None
        if tag == &#34;font&#34;:
            # recover last font state
            face, size, color = self.font_stack.pop()
            self.font_color = color
            self.set_font(face, size)
            self.set_text_color(*self.font_color)
        if tag == &#34;center&#34;:
            self.align = None
        if tag == &#34;sup&#34;:
            self.pdf.char_vpos = &#34;LINE&#34;
            self.follows_fmt_tag = True
        if tag == &#34;sub&#34;:
            self.pdf.char_vpos = &#34;LINE&#34;
            self.follows_fmt_tag = True

    def feed(self, data):
        super().feed(data)
        while self._tags_stack and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS:
            self._tags_stack.pop()
        if self._tags_stack and self.warn_on_tags_not_matching:
            LOGGER.warning(&#34;Missing HTML end tag for &lt;%s&gt;&#34;, self._tags_stack[-1])

    def set_font(self, face=None, size=None):
        if face:
            self.font_face = face
        if size:
            self.font_size = size
            self.h = px2mm(size)
        style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s)).upper()
        LOGGER.debug(f&#34;set_font: %s style=%s h={self.h:.2f}&#34;, self.font_face, style)
        if (self.font_face, style) != (self.pdf.font_family, self.pdf.font_style):
            self.pdf.set_font(self.font_face, style, self.font_size)
        if self.font_size != self.pdf.font_size:
            self.pdf.set_font_size(self.font_size)

    def set_style(self, tag=None, enable=False):
        # Modify style and select corresponding font
        if tag:
            self.style[tag.lower()] = enable
        style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s))
        LOGGER.debug(&#34;SET_FONT_STYLE %s&#34;, style)
        self.pdf.set_font(style=style)

    def set_text_color(self, r=None, g=0, b=0):
        self.pdf.set_text_color(r, g, b)

    def put_link(self, txt):
        # Put a hyperlink
        self.set_text_color(0, 0, 255)
        self.set_style(&#34;u&#34;, True)
        self.pdf.write(self.h, txt, self.href)
        self.set_style(&#34;u&#34;, False)
        self.set_text_color(*self.font_color)

    # pylint: disable=no-self-use
    def render_toc(self, pdf, outline):
        &#34;This method can be overriden by subclasses to customize the Table of Contents style.&#34;
        pdf.ln()
        for section in outline:
            link = pdf.add_link(page=section.page_number)
            text = f&#39;{&#34; &#34; * section.level * 2} {section.name}&#39;
            text += f&#39; {&#34;.&#34; * (60 - section.level*2 - len(section.name))} {section.page_number}&#39;
            pdf.multi_cell(
                w=pdf.epw,
                h=pdf.font_size,
                txt=text,
                new_x=XPos.LMARGIN,
                new_y=YPos.NEXT,
                link=link,
            )

    # Subclasses of _markupbase.ParserBase must implement this:
    def error(self, message):
        raise RuntimeError(message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>html.parser.HTMLParser</li>
<li>_markupbase.ParserBase</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.html.HTML2FPDF.HTML_UNCLOSED_TAGS"><code class="name">var <span class="ident">HTML_UNCLOSED_TAGS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.html.HTML2FPDF.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L693-L694" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def error(self, message):
    raise RuntimeError(message)</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.feed"><code class="name flex">
<span>def <span class="ident">feed</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Feed data to the parser.</p>
<p>Call this as often as you want, with as little or as much text
as you want (may include '\n').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L636-L641" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def feed(self, data):
    super().feed(data)
    while self._tags_stack and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS:
        self._tags_stack.pop()
    if self._tags_stack and self.warn_on_tags_not_matching:
        LOGGER.warning(&#34;Missing HTML end tag for &lt;%s&gt;&#34;, self._tags_stack[-1])</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.handle_data"><code class="name flex">
<span>def <span class="ident">handle_data</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L263-L349" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def handle_data(self, data):
    trailing_space_flag = TRAILING_SPACE.search(data)
    if self.td_th is not None:
        data = data.strip()
        if not data:
            return
        if &#34;inserted&#34; in self.td_th:
            td_th_tag = self.td_th[&#34;tag&#34;]
            raise NotImplementedError(
                f&#34;Unsupported nested HTML tags inside &lt;{td_th_tag}&gt; element: &lt;{self._tags_stack[-1]}&gt;&#34;
            )
            # We could potentially support nested &lt;b&gt; / &lt;em&gt; / &lt;font&gt; tags
            # by building a list of Fragment instances from the HTML cell content
            # and then passing those fragments to Row.cell().
            # However there should be an incoming refactoring of this code
            # dedicated to text layout, and we should probably wait for that
            # before supporting this feature.
        align = self.td_th.get(&#34;align&#34;, self.tr.get(&#34;align&#34;))
        if align:
            align = align.upper()
        bgcolor = color_as_decimal(
            self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
        )
        colspan = int(self.td_th.get(&#34;colspan&#34;, &#34;1&#34;))
        emphasis = 0
        if self.td_th.get(&#34;b&#34;):
            emphasis |= TextEmphasis.B
        if self.td_th.get(&#34;i&#34;):
            emphasis |= TextEmphasis.I
        if self.td_th.get(&#34;U&#34;):
            emphasis |= TextEmphasis.U
        style = None
        if bgcolor or emphasis:
            style = FontFace(emphasis=emphasis, fill_color=bgcolor)
        self.table_row.cell(text=data, align=align, style=style, colspan=colspan)
        self.td_th[&#34;inserted&#34;] = True
    elif self.table is not None:
        # ignore anything else than td inside a table
        pass
    elif self.align:
        LOGGER.debug(&#34;align &#39;%s&#39;&#34;, data.replace(&#34;\n&#34;, &#34;\\n&#34;))
        self.pdf.multi_cell(
            0,
            self.h,
            data,
            border=0,
            new_x=XPos.LMARGIN,
            new_y=YPos.NEXT,
            align=self.align[0].upper(),
            link=self.href,
        )
    elif self.pre_formatted:  # for pre blocks
        self.pdf.write(self.h, data)

    elif self.follows_fmt_tag and not self.follows_trailing_space:
        # don&#39;t trim leading whitespace if following a format tag with no trailing whitespace
        data = WHITESPACE.sub(whitespace_repl, data)
        if trailing_space_flag:
            self.follows_trailing_space = True
        if self.href:
            self.put_link(data)
        else:
            if self.heading_level:
                self.pdf.start_section(data, self.heading_level - 1, strict=False)
            LOGGER.debug(
                &#34;write &#39;%s&#39; h=%d&#34;,
                WHITESPACE.sub(whitespace_repl, data),
                self.h,
            )
            self.pdf.write(self.h, data)
        self.follows_fmt_tag = False

    else:
        data = LEADING_SPACE.sub(leading_whitespace_repl, data)
        data = WHITESPACE.sub(whitespace_repl, data)
        self.follows_trailing_space = trailing_space_flag
        if self.href:
            self.put_link(data)
        else:
            if self.heading_level:
                self.pdf.start_section(data, self.heading_level - 1, strict=False)
            LOGGER.debug(
                f&#34;write: &#39;%s&#39; h={self.h:.2f}&#34;,
                WHITESPACE.sub(whitespace_repl, data),
            )
            self.pdf.write(self.h, data)
        self.follows_fmt_tag = False</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.handle_endtag"><code class="name flex">
<span>def <span class="ident">handle_endtag</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L546-L634" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def handle_endtag(self, tag):
    LOGGER.debug(&#34;ENDTAG %s&#34;, tag)
    while (
        self._tags_stack
        and tag != self._tags_stack[-1]
        and self._tags_stack[-1] in self.HTML_UNCLOSED_TAGS
    ):
        self._tags_stack.pop()
    if not self._tags_stack:
        if self.warn_on_tags_not_matching:
            LOGGER.warning(
                &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag may be missing?&#34;, tag
            )
    elif tag == self._tags_stack[-1]:
        self._tags_stack.pop()
    elif self.warn_on_tags_not_matching:
        LOGGER.warning(
            &#34;Unexpected HTML end tag &lt;/%s&gt;, start tag was &lt;%s&gt;&#34;,
            tag,
            self._tags_stack[-1],
        )
    if tag in self.heading_sizes:
        self.heading_level = None
        face, size, color = self.font_stack.pop()
        # more space below heading:
        self.pdf.ln(self.h + self.h * self.heading_below)
        self.set_font(face, size)
        self.set_text_color(*color)
        self.align = None
    if tag == &#34;code&#34;:
        face, size, color = self.font_stack.pop()
        self.set_font(face, size)
        self.set_text_color(*color)
    if tag == &#34;pre&#34;:
        face, size, color = self.font_stack.pop()
        self.set_font(face, size)
        self.set_text_color(*color)
        self.pre_formatted = False
    if tag == &#34;blockquote&#34;:
        self.set_text_color(*self.font_color)
        self.indent -= 1
        self.pdf.ln(3)
    if tag in (&#34;strong&#34;, &#34;dt&#34;):
        tag = &#34;b&#34;
    if tag == &#34;em&#34;:
        tag = &#34;i&#34;
    if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
        if not self.td_th is not None:
            self.set_style(tag, False)
        self.follows_fmt_tag = True
    if tag == &#34;a&#34;:
        self.href = &#34;&#34;
    if tag == &#34;p&#34;:
        self.pdf.ln(self.h)
        self.align = &#34;&#34;
        self.h = px2mm(self.font_size)
    if tag in (&#34;ul&#34;, &#34;ol&#34;):
        self.indent -= 1
        self.bullet.pop()
    if tag == &#34;table&#34;:
        self.table.render()
        self.table = None
        self.pdf.ln(self.h)
    if tag == &#34;tr&#34;:
        self.tr = None
        self.table_row = None
    if tag in (&#34;td&#34;, &#34;th&#34;):
        if &#34;inserted&#34; not in self.td_th:
            # handle_data() was not called =&gt; we call it to produce an empty cell:
            bgcolor = color_as_decimal(
                self.td_th.get(&#34;bgcolor&#34;, self.tr.get(&#34;bgcolor&#34;, None))
            )
            style = FontFace(fill_color=bgcolor) if bgcolor else None
            self.table_row.cell(text=&#34;&#34;, style=style)
        self.td_th = None
    if tag == &#34;font&#34;:
        # recover last font state
        face, size, color = self.font_stack.pop()
        self.font_color = color
        self.set_font(face, size)
        self.set_text_color(*self.font_color)
    if tag == &#34;center&#34;:
        self.align = None
    if tag == &#34;sup&#34;:
        self.pdf.char_vpos = &#34;LINE&#34;
        self.follows_fmt_tag = True
    if tag == &#34;sub&#34;:
        self.pdf.char_vpos = &#34;LINE&#34;
        self.follows_fmt_tag = True</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.handle_starttag"><code class="name flex">
<span>def <span class="ident">handle_starttag</span></span>(<span>self, tag, attrs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L351-L544" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def handle_starttag(self, tag, attrs):
    attrs = dict(attrs)
    LOGGER.debug(&#34;STARTTAG %s %s&#34;, tag, attrs)
    self._tags_stack.append(tag)
    if tag == &#34;dt&#34;:
        self.pdf.ln(self.h)
        tag = &#34;b&#34;
    if tag == &#34;dd&#34;:
        self.pdf.ln(self.h)
        self.pdf.write(self.h, &#34; &#34; * self.dd_tag_indent)
    if tag == &#34;strong&#34;:
        tag = &#34;b&#34;
    if tag == &#34;em&#34;:
        tag = &#34;i&#34;
    if tag in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;):
        if self.td_th is not None:
            self.td_th[tag] = True
        else:
            self.set_style(tag, True)
    if tag == &#34;a&#34;:
        self.href = attrs[&#34;href&#34;]
    if tag == &#34;br&#34;:
        self.pdf.ln(self.h)
    if tag == &#34;p&#34;:
        self.pdf.ln(self.h)
        if &#34;align&#34; in attrs:
            self.align = attrs.get(&#34;align&#34;)
        if &#34;line-height&#34; in attrs:
            line_height = float(attrs.get(&#34;line-height&#34;))
            self.h = px2mm(self.font_size) * line_height
    if tag in self.heading_sizes:
        self.font_stack.append((self.font_face, self.font_size, self.font_color))
        self.heading_level = int(tag[1:])
        hsize = self.heading_sizes[tag]
        color = (
            color_as_decimal(attrs[&#34;color&#34;]) if &#34;color&#34; in attrs else (150, 0, 0)
        )
        self.pdf.set_text_color(*color)
        self.pdf.ln(self.h + self.heading_above * hsize)  # more space above heading
        self.set_font(size=hsize)
        if attrs:
            self.align = attrs.get(&#34;align&#34;)
    if tag == &#34;hr&#34;:
        self.pdf.add_page(same=True)
    if tag == &#34;code&#34;:
        self.font_stack.append((self.font_face, self.font_size, self.font_color))
        self.set_font(self.pre_code_font, 11)
    if tag == &#34;pre&#34;:
        self.font_stack.append((self.font_face, self.font_size, self.font_color))
        self.set_font(self.pre_code_font, 11)
        self.pre_formatted = True
    if tag == &#34;blockquote&#34;:
        self.pdf.set_text_color(100, 0, 45)
        self.indent += 1
        self.pdf.ln(3)
    if tag == &#34;ul&#34;:
        self.indent += 1
        self.bullet.append(self.ul_bullet_char)
    if tag == &#34;ol&#34;:
        self.indent += 1
        self.bullet.append(0)
    if tag == &#34;li&#34;:
        self.pdf.ln(self.h + 2)
        self.pdf.set_text_color(190, 0, 0)
        bullet = self.bullet[self.indent - 1]
        if not isinstance(bullet, str):
            bullet += 1
            self.bullet[self.indent - 1] = bullet
            bullet = f&#34;{bullet}. &#34;
        self.pdf.write(self.h, f&#34;{&#39; &#39; * self.li_tag_indent * self.indent}{bullet} &#34;)
        self.set_text_color(*self.font_color)
    if tag == &#34;font&#34;:
        # save previous font state:
        self.font_stack.append((self.font_face, self.font_size, self.font_color))
        if &#34;color&#34; in attrs:
            color = color_as_decimal(attrs[&#34;color&#34;])
            self.font_color = color
        if &#34;face&#34; in attrs:
            face = attrs.get(&#34;face&#34;).lower()
            try:
                self.pdf.set_font(face)
                self.font_face = face
            except RuntimeError:
                pass  # font not found, ignore
        if &#34;size&#34; in attrs:
            self.font_size = int(attrs.get(&#34;size&#34;))
        self.set_font()
        self.set_text_color(*self.font_color)
    if tag == &#34;table&#34;:
        width = attrs.get(&#34;width&#34;)
        if width:
            if width[-1] == &#34;%&#34;:
                width = self.pdf.epw * int(width[:-1]) / 100
            else:
                width = px2mm(int(width))
        if &#34;border&#34; in attrs:
            borders_layout = (
                &#34;ALL&#34; if self.table_line_separators else &#34;NO_HORIZONTAL_LINES&#34;
            )
        else:
            borders_layout = (
                &#34;HORIZONTAL_LINES&#34;
                if self.table_line_separators
                else &#34;SINGLE_TOP_LINE&#34;
            )
        align = attrs.get(&#34;align&#34;, &#34;center&#34;).upper()
        self.table = Table(
            self.pdf,
            align=align,
            borders_layout=borders_layout,
            line_height=self.h * 1.30,
            width=width,
        )
        self.pdf.ln()
    if tag == &#34;tr&#34;:
        if not self.table:
            raise FPDFException(&#34;Invalid HTML: &lt;tr&gt; used outside any &lt;table&gt;&#34;)
        self.tr = {k.lower(): v for k, v in attrs.items()}
        self.table_row = self.table.row()
    if tag in (&#34;td&#34;, &#34;th&#34;):
        if not self.table_row:
            raise FPDFException(f&#34;Invalid HTML: &lt;{tag}&gt; used outside any &lt;tr&gt;&#34;)
        self.td_th = {k.lower(): v for k, v in attrs.items()}
        self.td_th[&#34;tag&#34;] = tag
        if tag == &#34;th&#34;:
            self.td_th[&#34;align&#34;] = &#34;CENTER&#34;
            self.td_th[&#34;b&#34;] = True
        elif len(self.table.rows) == 1 and not self.table_row.cells:
            # =&gt; we are in the 1st &lt;tr&gt;, and the 1st cell is a &lt;td&gt;
            # =&gt; we do not treat the first row as a header
            # pylint: disable=protected-access
            self.table._borders_layout = TableBordersLayout.NONE
            self.table._first_row_as_headings = False
        if &#34;height&#34; in attrs:
            LOGGER.warning(
                &#39;Ignoring unsupported height=&#34;%s&#34; specified on a &lt;%s&gt;&#39;,
                attrs[&#34;height&#34;],
                tag,
            )
        if &#34;width&#34; in attrs:
            width = attrs[&#34;width&#34;]
            # pylint: disable=protected-access
            if len(self.table.rows) == 1:  # =&gt; first table row
                if width[-1] == &#34;%&#34;:
                    width = width[:-1]
                if not self.table._col_widths:
                    self.table._col_widths = []
                self.table._col_widths.append(int(width))
            else:
                LOGGER.warning(
                    &#39;Ignoring width=&#34;%s&#34; specified on a &lt;%s&gt; that is not in the first &lt;tr&gt;&#39;,
                    width,
                    tag,
                )
    if tag == &#34;img&#34; and &#34;src&#34; in attrs:
        width = px2mm(int(attrs.get(&#34;width&#34;, 0)))
        height = px2mm(int(attrs.get(&#34;height&#34;, 0)))
        if self.table_row:  # =&gt; &lt;img&gt; in a &lt;table&gt;
            if width or height:
                LOGGER.warning(
                    &#39;Ignoring unsupported &#34;width&#34; / &#34;height&#34; set on &lt;img&gt; element&#39;
                )
            if self.align:
                LOGGER.warning(&#34;Ignoring unsupported &lt;img&gt; alignment&#34;)
            self.table_row.cell(img=attrs[&#34;src&#34;], img_fill_width=True)
            self.td_th[&#34;inserted&#34;] = True
            return
        if self.pdf.y + height &gt; self.pdf.page_break_trigger:
            self.pdf.add_page(same=True)
        x, y = self.pdf.get_x(), self.pdf.get_y()
        if self.align and self.align[0].upper() == &#34;C&#34;:
            x = self.pdf.w / 2 - width / 2
        LOGGER.debug(
            &#39;image &#34;%s&#34; x=%d y=%d width=%d height=%d&#39;,
            attrs[&#34;src&#34;],
            x,
            y,
            width,
            height,
        )
        info = self.pdf.image(
            self.image_map(attrs[&#34;src&#34;]), x, y, width, height, link=self.href
        )
        self.pdf.set_y(y + info.rendered_height)
    if tag == &#34;center&#34;:
        self.align = &#34;Center&#34;
    if tag == &#34;toc&#34;:
        self.pdf.insert_toc_placeholder(
            self.render_toc, pages=int(attrs.get(&#34;pages&#34;, 1))
        )
    if tag == &#34;sup&#34;:
        self.pdf.char_vpos = &#34;SUP&#34;
    if tag == &#34;sub&#34;:
        self.pdf.char_vpos = &#34;SUB&#34;</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.put_link"><code class="name flex">
<span>def <span class="ident">put_link</span></span>(<span>self, txt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L667-L673" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def put_link(self, txt):
    # Put a hyperlink
    self.set_text_color(0, 0, 255)
    self.set_style(&#34;u&#34;, True)
    self.pdf.write(self.h, txt, self.href)
    self.set_style(&#34;u&#34;, False)
    self.set_text_color(*self.font_color)</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.render_toc"><code class="name flex">
<span>def <span class="ident">render_toc</span></span>(<span>self, pdf, outline)</span>
</code></dt>
<dd>
<div class="desc"><p>This method can be overriden by subclasses to customize the Table of Contents style.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L676-L690" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def render_toc(self, pdf, outline):
    &#34;This method can be overriden by subclasses to customize the Table of Contents style.&#34;
    pdf.ln()
    for section in outline:
        link = pdf.add_link(page=section.page_number)
        text = f&#39;{&#34; &#34; * section.level * 2} {section.name}&#39;
        text += f&#39; {&#34;.&#34; * (60 - section.level*2 - len(section.name))} {section.page_number}&#39;
        pdf.multi_cell(
            w=pdf.epw,
            h=pdf.font_size,
            txt=text,
            new_x=XPos.LMARGIN,
            new_y=YPos.NEXT,
            link=link,
        )</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.set_font"><code class="name flex">
<span>def <span class="ident">set_font</span></span>(<span>self, face=None, size=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L643-L654" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_font(self, face=None, size=None):
    if face:
        self.font_face = face
    if size:
        self.font_size = size
        self.h = px2mm(size)
    style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s)).upper()
    LOGGER.debug(f&#34;set_font: %s style=%s h={self.h:.2f}&#34;, self.font_face, style)
    if (self.font_face, style) != (self.pdf.font_family, self.pdf.font_style):
        self.pdf.set_font(self.font_face, style, self.font_size)
    if self.font_size != self.pdf.font_size:
        self.pdf.set_font_size(self.font_size)</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.set_style"><code class="name flex">
<span>def <span class="ident">set_style</span></span>(<span>self, tag=None, enable=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L656-L662" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_style(self, tag=None, enable=False):
    # Modify style and select corresponding font
    if tag:
        self.style[tag.lower()] = enable
    style = &#34;&#34;.join(s for s in (&#34;b&#34;, &#34;i&#34;, &#34;u&#34;) if self.style.get(s))
    LOGGER.debug(&#34;SET_FONT_STYLE %s&#34;, style)
    self.pdf.set_font(style=style)</code></pre>
</details>
</dd>
<dt id="fpdf.html.HTML2FPDF.set_text_color"><code class="name flex">
<span>def <span class="ident">set_text_color</span></span>(<span>self, r=None, g=0, b=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L664-L665" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_text_color(self, r=None, g=0, b=0):
    self.pdf.set_text_color(r, g, b)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.html.HTMLMixin"><code class="flex name class">
<span>class <span class="ident">HTMLMixin</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>[<strong>DEPRECATED since v2.6.0</strong>]
You can now directly use the <code>FPDF.write_html()</code> method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/5451b3b3bb50f9e023c1af1405a3fa91fa57c18c/fpdf/html.py#L724-L738" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class HTMLMixin:
    &#34;&#34;&#34;
    [**DEPRECATED since v2.6.0**]
    You can now directly use the `FPDF.write_html()` method
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        warnings.warn(
            # pylint: disable=implicit-str-concat
            &#34;The HTMLMixin class is deprecated. &#34;
            &#34;Simply use the FPDF class as a replacement.&#34;,
            DeprecationWarning,
            stacklevel=get_stack_level(),
        )</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fpdf.html.color_as_decimal" href="#fpdf.html.color_as_decimal">color_as_decimal</a></code></li>
<li><code><a title="fpdf.html.leading_whitespace_repl" href="#fpdf.html.leading_whitespace_repl">leading_whitespace_repl</a></code></li>
<li><code><a title="fpdf.html.px2mm" href="#fpdf.html.px2mm">px2mm</a></code></li>
<li><code><a title="fpdf.html.whitespace_repl" href="#fpdf.html.whitespace_repl">whitespace_repl</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.html.HTML2FPDF" href="#fpdf.html.HTML2FPDF">HTML2FPDF</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.html.HTML2FPDF.HTML_UNCLOSED_TAGS" href="#fpdf.html.HTML2FPDF.HTML_UNCLOSED_TAGS">HTML_UNCLOSED_TAGS</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.error" href="#fpdf.html.HTML2FPDF.error">error</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.feed" href="#fpdf.html.HTML2FPDF.feed">feed</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.handle_data" href="#fpdf.html.HTML2FPDF.handle_data">handle_data</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.handle_endtag" href="#fpdf.html.HTML2FPDF.handle_endtag">handle_endtag</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.handle_starttag" href="#fpdf.html.HTML2FPDF.handle_starttag">handle_starttag</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.put_link" href="#fpdf.html.HTML2FPDF.put_link">put_link</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.render_toc" href="#fpdf.html.HTML2FPDF.render_toc">render_toc</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.set_font" href="#fpdf.html.HTML2FPDF.set_font">set_font</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.set_style" href="#fpdf.html.HTML2FPDF.set_style">set_style</a></code></li>
<li><code><a title="fpdf.html.HTML2FPDF.set_text_color" href="#fpdf.html.HTML2FPDF.set_text_color">set_text_color</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.html.HTMLMixin" href="#fpdf.html.HTMLMixin">HTMLMixin</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>