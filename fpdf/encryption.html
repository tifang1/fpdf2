<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fpdf.encryption API documentation</title>
<meta name="description" content="Utilities to perform encryption following the PDF standards …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.encryption</code></h1>
</header>
<section id="section-intro">
<p>Utilities to perform encryption following the PDF standards.</p>
<p>The contents of this module are internal to fpdf2, and not part of the public API.
They may change at any time without prior warning or any deprecation period,
in non-backward-compatible ways.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L1-L562" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Utilities to perform encryption following the PDF standards.

The contents of this module are internal to fpdf2, and not part of the public API.
They may change at any time without prior warning or any deprecation period,
in non-backward-compatible ways.
&#34;&#34;&#34;

import hashlib
import logging
import math
import stringprep
import unicodedata
from binascii import hexlify
from codecs import BOM_UTF16_BE
from os import urandom
from typing import Callable, Iterable, Type, Union

from .enums import AccessPermission, EncryptionMethod
from .errors import FPDFException
from .syntax import Name, PDFObject, PDFString, build_obj_dict
from .syntax import create_dictionary_string as pdf_dict

# try to use cryptography for AES encryption
try:
    from cryptography.hazmat.primitives.ciphers import Cipher, modes
    from cryptography.hazmat.primitives.ciphers.algorithms import AES128, AES256
    from cryptography.hazmat.primitives.padding import PKCS7

    import_error = None
except ImportError as error:
    import_error = error


LOGGER = logging.getLogger(__name__)


class ARC4:
    &#34;&#34;&#34;
    This is a simplified version of the ARC4 (alleged RC4) algorithm,
    created based on the following sources:
    * Wikipedia article on RC4
    * github.com/manojpandey/rc4 (MIT License)
    * http://people.csail.mit.edu/rivest/pubs/RS14.pdf

    Having this ARC4 implementation makes it possible to have basic
    encryption functions without additional dependencies
    &#34;&#34;&#34;

    MOD = 256

    def KSA(self, key: bytes) -&gt; list:
        key_length = len(key)
        S = list(range(self.MOD))
        j = 0
        for i in range(self.MOD):
            j = (j + S[i] + key[i % key_length]) % self.MOD
            S[i], S[j] = S[j], S[i]
        return S

    def PRGA(self, S: list) -&gt; Iterable[int]:
        i = 0
        j = 0
        while True:
            i = (i + 1) % self.MOD
            j = (j + S[i]) % self.MOD
            S[i], S[j] = S[j], S[i]
            K = S[(S[i] + S[j]) % self.MOD]
            yield K

    def encrypt(self, key: bytes, text: Union[bytes, bytearray]) -&gt; list:
        keystream = self.PRGA(self.KSA(key))
        res = []
        for c in text:
            res.append(c ^ next(keystream))
        return res


class CryptFilter:
    &#34;&#34;&#34;Represents one crypt filter, listed under CF inside the encryption dictionary&#34;&#34;&#34;

    def __init__(self, mode: str, length: int) -&gt; None:
        super().__init__()
        self.type = Name(&#34;CryptFilter&#34;)
        self.c_f_m = Name(mode)
        self.length = int(length / 8)

    def serialize(self) -&gt; str:
        obj_dict = build_obj_dict({key: getattr(self, key) for key in dir(self)})
        return pdf_dict(obj_dict)


class EncryptionDictionary(PDFObject):
    &#34;&#34;&#34;
    This class represents an encryption dictionary
    PDF 32000 reference - Table 20
    The PDF trailer must reference this object (/Encrypt)
    &#34;&#34;&#34;

    def __init__(self, security_handler: &#34;StandardSecurityHandler&#34;) -&gt; None:
        super().__init__()
        self.filter = Name(&#34;Standard&#34;)
        self.length = security_handler.key_length
        self.r = security_handler.revision
        self.o = f&#34;&lt;{security_handler.o.upper()}&gt;&#34;
        self.u = f&#34;&lt;{security_handler.u.upper()}&gt;&#34;
        if security_handler.revision == 6:
            self.o_e = f&#34;&lt;{security_handler.oe.upper()}&gt;&#34;
            self.u_e = f&#34;&lt;{security_handler.ue.upper()}&gt;&#34;
            self.perms = f&#34;&lt;{security_handler.perms.upper()}&gt;&#34;
        self.v = security_handler.version
        self.p = int32(security_handler.access_permission)
        if not security_handler.encrypt_metadata:
            self.encrypt_metadata = &#34;false&#34;
        if security_handler.cf:
            self.c_f = pdf_dict({&#34;/StdCF&#34;: security_handler.cf.serialize()})
        if security_handler.encryption_method == EncryptionMethod.NO_ENCRYPTION:
            self.stm_f = Name(&#34;Identity&#34;)  # crypt filter for streams
            self.str_f = Name(&#34;Identity&#34;)  # crypt filter for strings
        else:
            self.stm_f = Name(&#34;StdCF&#34;)  # crypt filter for streams
            self.str_f = Name(&#34;StdCF&#34;)  # crypt filter for strings


class StandardSecurityHandler:
    &#34;&#34;&#34;
    This class is referenced in the main PDF class and is used to handle all encryption functions
        * Calculate password and hashes
        * Provide encrypt method to be called by stream and strings
        * Set the access permissions on the document
    &#34;&#34;&#34;

    DEFAULT_PADDING = (
        b&#34;(\xbfN^Nu\x8aAd\x00NV\xff\xfa\x01\x08..\x00\xb6\xd0h&gt;\x80/\x0c\xa9\xfedSiz&#34;
    )

    def __init__(
        self,
        fpdf,
        owner_password: str,
        user_password: Union[str, None] = None,
        permission: AccessPermission = AccessPermission.all(),
        encryption_method: EncryptionMethod = EncryptionMethod.RC4,
        encrypt_metadata: bool = False,
    ):
        self.fpdf = fpdf
        self.access_permission = (
            0b11111111111111111111000011000000
            if permission is None
            else (0b11111111111111111111000011000000 | permission)
        )
        self.owner_password = owner_password
        self.user_password = user_password if user_password else &#34;&#34;
        self.encryption_method = encryption_method
        self.cf = None
        self.key_length = 128

        if import_error and self.encryption_method in (
            EncryptionMethod.AES_128,
            EncryptionMethod.AES_256,
        ):
            raise EnvironmentError(
                &#34;cryptography module not available&#34;
                &#34; - Try: &#39;pip install cryptography&#39; or use RC4 encryption method&#34;
                f&#34; - Import error was: {import_error}&#34;
            )
        if self.encryption_method == EncryptionMethod.AES_128:
            self.version = 4
            self.revision = 4
            fpdf._set_min_pdf_version(&#34;1.6&#34;)
            self.cf = CryptFilter(mode=&#34;AESV2&#34;, length=self.key_length)
        elif self.encryption_method == EncryptionMethod.AES_256:
            self.version = 5
            self.revision = 6
            fpdf._set_min_pdf_version(&#34;2.0&#34;)
            self.key_length = 256
            self.cf = CryptFilter(mode=&#34;AESV3&#34;, length=self.key_length)
        elif self.encryption_method == EncryptionMethod.NO_ENCRYPTION:
            self.version = 4
            self.revision = 4
            fpdf._set_min_pdf_version(&#34;1.6&#34;)
            self.cf = CryptFilter(mode=&#34;V2&#34;, length=self.key_length)
        else:
            self.version = 2
            self.revision = 3
            fpdf._set_min_pdf_version(&#34;1.5&#34;)
            # not including crypt filter because it&#39;s only required on V=4
            # if needed, it would be CryptFilter(mode=V2)

        self.encrypt_metadata = encrypt_metadata

    def generate_passwords(self, file_id: str) -&gt; None:
        &#34;&#34;&#34;File_id is the first hash of the PDF file id&#34;&#34;&#34;
        self.file_id = file_id
        self.info_id = file_id[1:33]
        if self.revision == 6:
            self.k = self.get_random_bytes(32)
            self.generate_user_password_rev6()
            self.generate_owner_password_rev6()
            self.generate_perms_rev6()
        else:
            self.o = self.generate_owner_password()
            self.k = self.generate_encryption_key()
            self.u = self.generate_user_password()

    def get_encryption_obj(self) -&gt; EncryptionDictionary:
        &#34;&#34;&#34;Return an encryption dictionary&#34;&#34;&#34;
        return EncryptionDictionary(self)

    def encrypt(
        self, text: Union[str, bytearray, bytes], obj_id: int
    ) -&gt; Union[str, bytes]:
        &#34;&#34;&#34;Method invoked by PDFObject and PDFContentStream to encrypt strings and streams&#34;&#34;&#34;
        LOGGER.debug(&#34;Encrypting %s&#34;, text)
        return (
            self.encrypt_stream(text, obj_id)
            if isinstance(text, (bytearray, bytes))
            else self.encrypt_string(text, obj_id)
        )

    def encrypt_string(self, string: str, obj_id: int) -&gt; str:
        if self.encryption_method == EncryptionMethod.NO_ENCRYPTION:
            return PDFString(string, encrypt=False).serialize()
        LOGGER.debug(&#34;Encrypting string: %s&#34;, string)
        try:
            string.encode(&#34;latin-1&#34;)
            return f&#34;&lt;{bytes(self.encrypt_bytes(string.encode(&#39;latin-1&#39;), obj_id)).hex().upper()}&gt;&#34;
        except UnicodeEncodeError:
            return f&#39;&lt;{hexlify(bytearray(self.encrypt_bytes(BOM_UTF16_BE + string.encode(&#34;utf-16-be&#34;), obj_id))).decode(&#34;latin-1&#34;)}&gt;&#39;

    def encrypt_stream(self, stream: bytes, obj_id: int) -&gt; bytes:
        if self.encryption_method == EncryptionMethod.NO_ENCRYPTION:
            return stream
        return bytes(self.encrypt_bytes(stream, obj_id))

    def is_aes_algorithm(self) -&gt; bool:
        return self.encryption_method in (
            EncryptionMethod.AES_128,
            EncryptionMethod.AES_256,
        )

    def encrypt_bytes(self, data: bytes, obj_id: int):
        &#34;&#34;&#34;
        PDF32000 reference - Algorithm 1: Encryption of data using the RC4 or AES algorithms
        Append object ID and generation ID to the key and encrypt the data
        Generation ID is fixed as 0. Will need to revisit if the application start changing generation ID
        &#34;&#34;&#34;
        h = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
        h.update(self.k)
        h.update(
            (obj_id &amp; 0xFFFFFF).to_bytes(3, byteorder=&#34;little&#34;, signed=False)
        )  # object id
        h.update(
            (0 &amp; 0xFFFF).to_bytes(2, byteorder=&#34;little&#34;, signed=False)
        )  # generation id
        if self.is_aes_algorithm():
            h.update(bytes([0x73, 0x41, 0x6C, 0x54]))  # add salt (sAlT) for AES
        key = h.digest()

        if self.is_aes_algorithm():
            return self.encrypt_AES_cryptography(key, data)
        return ARC4().encrypt(key, data)

    def encrypt_AES_cryptography(self, key: bytes, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypts an array of bytes using AES algorithms (AES 128 or AES 256)&#34;&#34;&#34;
        iv = bytearray(self.get_random_bytes(16))
        padder = PKCS7(128).padder()
        padded_data = padder.update(data)
        padded_data += padder.finalize()
        cipher = (
            Cipher(AES128(key), modes.CBC(iv))
            if self.encryption_method == EncryptionMethod.AES_128
            else Cipher(AES256(self.k), modes.CBC(iv))
        )
        encryptor = cipher.encryptor()
        data = encryptor.update(padded_data) + encryptor.finalize()
        iv.extend(data)
        return iv

    @classmethod
    def get_random_bytes(cls: Type[&#34;StandardSecurityHandler&#34;], size: int) -&gt; bytes:
        &#34;&#34;&#34;
        https://docs.python.org/3/library/os.html#os.urandom
        os.urandom will use OS-specific sources to generate random bytes
        suitable for cryptographic use
        &#34;&#34;&#34;
        return urandom(size)

    @classmethod
    def prepare_string(cls: Type[&#34;StandardSecurityHandler&#34;], string: str) -&gt; bytes:
        &#34;&#34;&#34;
        PDF2.0 - ISO 32000-2:2020
        All passwords for revision 6 shall be based on Unicode. Preprocessing of a user-provided password
        consists first of normalizing its representation by applying the &#34;SASLPrep&#34; profile (Internet RFC 4013)
        of the &#34;stringprep&#34; algorithm (Internet RFC 3454) to the supplied password using the Normalize and BiDi
        options. Next, the password string shall be converted to UTF-8 encoding, and then truncated to the
        first 127 bytes if the string is longer than 127 bytes

        Python offers a stringprep module with the tables mapped in methods
        &#34;&#34;&#34;

        # Mapping
        def char_map(char: str) -&gt; str:
            if not char:
                return &#34;&#34;
            # Commonly mapped to nothing
            if stringprep.in_table_b1(char):
                return &#34;&#34;
            # Map non-ascii space characters to space
            if stringprep.in_table_c12(char):
                return &#34;\u0020&#34;
            return char

        if len(string) &lt; 1:
            return bytes()

        prepared_string = &#34;&#34;.join(char_map(c) for c in string)

        # Normalization - applies Unicode normalization form KC
        prepared_string = unicodedata.ucd_3_2_0.normalize(&#34;NFKC&#34;, prepared_string)

        # Prohibited output - RCF4013 2.3
        def is_prohibited(char: str) -&gt; bool:
            return (
                stringprep.in_table_c12(char)  # Non-ASCII space characters
                or stringprep.in_table_c21_c22(char)  # Control characters
                or stringprep.in_table_c3(char)  # Private use
                or stringprep.in_table_c4(char)  # Non-character code points
                or stringprep.in_table_c5(char)  # Surrogate codes
                or stringprep.in_table_c6(char)  # Inappropriate for plain text
                or stringprep.in_table_c7(
                    char
                )  # Inappropriate for canonical representation
                or stringprep.in_table_c8(
                    char
                )  # Change display properties or are deprecated
                or stringprep.in_table_c9(char)  # Tagging characters
            )

        for char in prepared_string:
            if is_prohibited(char):
                raise FPDFException(
                    f&#34;The password {string} contains prohibited characters&#34;
                )

        # Bidirectional characters
        def has_character(string: str, fun: Callable) -&gt; bool:
            return any(fun(char) for char in string)

        if has_character(prepared_string, stringprep.in_table_d1):
            # If a string contains any RandALCat character, the string MUST NOT contain any LCat character.
            if has_character(prepared_string, stringprep.in_table_d2):
                raise FPDFException(
                    f&#34;The password {string} contains invalid bidirectional characters.&#34;
                )
            # If a string contains any RandALCat character, a RandALCat character MUST be the first character
            # of the string, and a RandALCat character MUST be the last character of the string.
            if not (
                stringprep.in_table_d1(prepared_string[0])
                and stringprep.in_table_d1(prepared_string[-1])
            ):
                raise FPDFException(
                    f&#34;The password {string} contains invalid bidirectional characters.&#34;
                )

        if len(prepared_string) &gt; 127:
            prepared_string = prepared_string[:127]

        return prepared_string.encode(&#34;UTF-8&#34;)

    def padded_password(self, password: str) -&gt; bytearray:
        &#34;&#34;&#34;
        PDF32000 reference - Algorithm 2: Computing an encryption key
        Step (a) - Add the default padding at the end of provided password to make it 32 bit long
        &#34;&#34;&#34;
        if len(password) &gt; 32:
            password = password[:32]
        p = bytearray(password.encode(&#34;latin1&#34;))
        p.extend(self.DEFAULT_PADDING[: (32 - len(p))])
        return p

    def generate_owner_password(self) -&gt; str:
        &#34;&#34;&#34;
        PDF32000 reference - Algorithm 3: Computing the encryption dictionary&#39;s O (owner password) value
        The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here
        &#34;&#34;&#34;
        m = self.padded_password(self.owner_password)
        for _ in range(51):
            m = md5(m)
        rc4key = m[: (math.ceil(self.key_length / 8))]
        result = self.padded_password(self.user_password)
        for i in range(20):
            new_key = []
            for k in rc4key:
                new_key.append(k ^ i)
            result = ARC4().encrypt(bytes(new_key), result)
        return bytes(result).hex()

    def generate_user_password(self) -&gt; str:
        &#34;&#34;&#34;
        PDF32000 reference - Algorithm 5: Computing the encryption dictionary&#39;s U (user password) value
        The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here
        &#34;&#34;&#34;
        m = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
        m.update(bytearray(self.DEFAULT_PADDING))
        m.update(bytes.fromhex(self.info_id))
        result = bytearray(m.digest())
        key = self.k
        for i in range(20):
            new_key = []
            for k in key:
                new_key.append(k ^ i)
            result = ARC4().encrypt(bytes(new_key), result)
        result.extend(
            (result[x] ^ self.DEFAULT_PADDING[x]) for x in range(16)
        )  # add 16 bytes of random padding
        return bytes(result).hex()

    @classmethod
    def compute_hash(
        cls: Type[&#34;StandardSecurityHandler&#34;],
        input_password: bytes,
        salt: bytes,
        user_key: bytes = bytearray(),
    ) -&gt; bytes:
        &#34;&#34;&#34;
        Algorithm 2B - section 7.6.4.3.4 of the ISO 32000-2:2020
        Applied on Security handlers revision 6
        &#34;&#34;&#34;
        k = hashlib.sha256(input_password + salt + user_key).digest()
        round_number = 0
        while True:
            round_number += 1
            k1 = input_password + k + user_key
            # Step (a + b)
            cipher = Cipher(AES128(k[:16]), modes.CBC(k[16:32]))
            encryptor = cipher.encryptor()
            e = encryptor.update(k1 * 64) + encryptor.finalize()
            # Step (c)
            # remainder = int.from_bytes(e[:16], byteorder=&#34;big&#34;) % 3
            remainder = sum(e[:16]) % 3
            # Step (d)
            if remainder == 0:
                k = hashlib.sha256(e).digest()
            elif remainder == 1:
                k = hashlib.sha384(e).digest()
            else:
                k = hashlib.sha512(e).digest()
            # Step (e)
            if round_number &gt;= 64 and e[-1] &lt;= round_number - 32:
                break

        return k[:32]

    def generate_user_password_rev6(self) -&gt; None:
        &#34;&#34;&#34;
        Generating the U (user password) and UE (user encryption)
        for security handlers of revision 6
        Algorithm 8 - Section 7.6.4.4.7 of the ISO 32000-2:2020
        &#34;&#34;&#34;
        user_password = self.prepare_string(self.user_password)
        if not user_password:
            user_password = bytearray()
        user_validation_salt = self.get_random_bytes(8)
        user_key_salt = self.get_random_bytes(8)
        u = (
            self.compute_hash(input_password=user_password, salt=user_validation_salt)
            + user_validation_salt
            + user_key_salt
        )
        self.u = u.hex()

        key = self.compute_hash(input_password=user_password, salt=user_key_salt)
        cipher = Cipher(AES256(key), modes.CBC(b&#34;\x00&#34; * 16))
        encryptor = cipher.encryptor()
        ue = encryptor.update(self.k) + encryptor.finalize()
        self.ue = ue.hex()

    def generate_owner_password_rev6(self) -&gt; None:
        &#34;&#34;&#34;
        Generating the O (owner password) and OE (owner encryption)
        for security handlers of revision 6
        Algorithm 9 - Section 7.6.4.4.8 of the ISO 32000-2:2020
        &#34;&#34;&#34;
        owner_password = self.prepare_string(self.owner_password)
        if not owner_password:
            raise FPDFException(f&#34;Invalid owner password {self.owner_password}&#34;)
        owner_validation_salt = self.get_random_bytes(8)
        owner_key_salt = self.get_random_bytes(8)
        o = (
            self.compute_hash(
                input_password=owner_password,
                salt=owner_validation_salt,
                user_key=bytes.fromhex(self.u),
            )
            + owner_validation_salt
            + owner_key_salt
        )
        self.o = o.hex()

        key = self.compute_hash(
            input_password=owner_password,
            salt=owner_key_salt,
            user_key=bytes.fromhex(self.u),
        )

        cipher = Cipher(AES256(key), modes.CBC(b&#34;\x00&#34; * 16))
        encryptor = cipher.encryptor()
        oe = encryptor.update(self.k) + encryptor.finalize()
        self.oe = oe.hex()

    def generate_perms_rev6(self) -&gt; None:
        &#34;&#34;&#34;
        7.6.4.4.9 Algorithm 10: Computing the encryption dictionary’s Perms (permissions) value
        (Security handlers of revision 6) of the ISO 32000-2:2020
        &#34;&#34;&#34;
        perms64b = 0xFFFFFFFF00000000 | self.access_permission
        encrypt_metadata = b&#34;T&#34; if self.encrypt_metadata else b&#34;F&#34;
        perms_input = (
            perms64b.to_bytes(8, byteorder=&#34;little&#34;, signed=False)
            + encrypt_metadata
            + b&#34;adb&#34;
            + self.get_random_bytes(4)
        )
        # nosemgrep: python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb
        cipher = Cipher(AES256(self.k), modes.ECB())
        encryptor = cipher.encryptor()
        perms = encryptor.update(perms_input) + encryptor.finalize()
        self.perms = perms.hex()

    def generate_encryption_key(self) -&gt; bytes:
        &#34;&#34;&#34;
        PDF32000 reference
        Algorithm 2: Computing an encryption key
        &#34;&#34;&#34;
        m = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
        m.update(self.padded_password(self.user_password))
        m.update(bytes.fromhex(self.o))
        m.update(
            (self.access_permission &amp; 0xFFFFFFFF).to_bytes(
                4, byteorder=&#34;little&#34;, signed=False
            )
        )
        m.update(bytes.fromhex(self.info_id))
        if self.encrypt_metadata is False and self.version == 4:
            m.update(bytes([0xFF, 0xFF, 0xFF, 0xFF]))
        result = m.digest()[: (math.ceil(self.key_length / 8))]
        for _ in range(50):
            result = md5(result)[: (math.ceil(self.key_length / 8))]
        return result


def md5(data: Union[bytes, bytearray]) -&gt; bytes:
    h = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
    h.update(data)
    return h.digest()


def int32(n: int) -&gt; int:
    &#34;&#34;&#34;convert long to signed 32 bit integer&#34;&#34;&#34;
    n = n &amp; 0xFFFFFFFF
    return (n ^ 0x80000000) - 0x80000000</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fpdf.encryption.int32"><code class="name flex">
<span>def <span class="ident">int32</span></span>(<span>n: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>convert long to signed 32 bit integer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L559-L562" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def int32(n: int) -&gt; int:
    &#34;&#34;&#34;convert long to signed 32 bit integer&#34;&#34;&#34;
    n = n &amp; 0xFFFFFFFF
    return (n ^ 0x80000000) - 0x80000000</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.md5"><code class="name flex">
<span>def <span class="ident">md5</span></span>(<span>data: Union[bytes, bytearray]) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L553-L556" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def md5(data: Union[bytes, bytearray]) -&gt; bytes:
    h = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
    h.update(data)
    return h.digest()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.encryption.ARC4"><code class="flex name class">
<span>class <span class="ident">ARC4</span></span>
</code></dt>
<dd>
<div class="desc"><p>This is a simplified version of the ARC4 (alleged RC4) algorithm,
created based on the following sources:
* Wikipedia article on RC4
* github.com/manojpandey/rc4 (MIT License)
* <a href="http://people.csail.mit.edu/rivest/pubs/RS14.pdf">http://people.csail.mit.edu/rivest/pubs/RS14.pdf</a></p>
<p>Having this ARC4 implementation makes it possible to have basic
encryption functions without additional dependencies</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L38-L76" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class ARC4:
    &#34;&#34;&#34;
    This is a simplified version of the ARC4 (alleged RC4) algorithm,
    created based on the following sources:
    * Wikipedia article on RC4
    * github.com/manojpandey/rc4 (MIT License)
    * http://people.csail.mit.edu/rivest/pubs/RS14.pdf

    Having this ARC4 implementation makes it possible to have basic
    encryption functions without additional dependencies
    &#34;&#34;&#34;

    MOD = 256

    def KSA(self, key: bytes) -&gt; list:
        key_length = len(key)
        S = list(range(self.MOD))
        j = 0
        for i in range(self.MOD):
            j = (j + S[i] + key[i % key_length]) % self.MOD
            S[i], S[j] = S[j], S[i]
        return S

    def PRGA(self, S: list) -&gt; Iterable[int]:
        i = 0
        j = 0
        while True:
            i = (i + 1) % self.MOD
            j = (j + S[i]) % self.MOD
            S[i], S[j] = S[j], S[i]
            K = S[(S[i] + S[j]) % self.MOD]
            yield K

    def encrypt(self, key: bytes, text: Union[bytes, bytearray]) -&gt; list:
        keystream = self.PRGA(self.KSA(key))
        res = []
        for c in text:
            res.append(c ^ next(keystream))
        return res</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.encryption.ARC4.MOD"><code class="name">var <span class="ident">MOD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.encryption.ARC4.KSA"><code class="name flex">
<span>def <span class="ident">KSA</span></span>(<span>self, key: bytes) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L52-L59" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def KSA(self, key: bytes) -&gt; list:
    key_length = len(key)
    S = list(range(self.MOD))
    j = 0
    for i in range(self.MOD):
        j = (j + S[i] + key[i % key_length]) % self.MOD
        S[i], S[j] = S[j], S[i]
    return S</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.ARC4.PRGA"><code class="name flex">
<span>def <span class="ident">PRGA</span></span>(<span>self, S: list) ‑> Iterable[int]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L61-L69" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def PRGA(self, S: list) -&gt; Iterable[int]:
    i = 0
    j = 0
    while True:
        i = (i + 1) % self.MOD
        j = (j + S[i]) % self.MOD
        S[i], S[j] = S[j], S[i]
        K = S[(S[i] + S[j]) % self.MOD]
        yield K</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.ARC4.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>self, key: bytes, text: Union[bytes, bytearray]) ‑> list</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L71-L76" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encrypt(self, key: bytes, text: Union[bytes, bytearray]) -&gt; list:
    keystream = self.PRGA(self.KSA(key))
    res = []
    for c in text:
        res.append(c ^ next(keystream))
    return res</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.encryption.CryptFilter"><code class="flex name class">
<span>class <span class="ident">CryptFilter</span></span>
<span>(</span><span>mode: str, length: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents one crypt filter, listed under CF inside the encryption dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L79-L90" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CryptFilter:
    &#34;&#34;&#34;Represents one crypt filter, listed under CF inside the encryption dictionary&#34;&#34;&#34;

    def __init__(self, mode: str, length: int) -&gt; None:
        super().__init__()
        self.type = Name(&#34;CryptFilter&#34;)
        self.c_f_m = Name(mode)
        self.length = int(length / 8)

    def serialize(self) -&gt; str:
        obj_dict = build_obj_dict({key: getattr(self, key) for key in dir(self)})
        return pdf_dict(obj_dict)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fpdf.encryption.CryptFilter.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L88-L90" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def serialize(self) -&gt; str:
    obj_dict = build_obj_dict({key: getattr(self, key) for key in dir(self)})
    return pdf_dict(obj_dict)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fpdf.encryption.EncryptionDictionary"><code class="flex name class">
<span>class <span class="ident">EncryptionDictionary</span></span>
<span>(</span><span>security_handler: <a title="fpdf.encryption.StandardSecurityHandler" href="#fpdf.encryption.StandardSecurityHandler">StandardSecurityHandler</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents an encryption dictionary
PDF 32000 reference - Table 20
The PDF trailer must reference this object (/Encrypt)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L93-L122" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EncryptionDictionary(PDFObject):
    &#34;&#34;&#34;
    This class represents an encryption dictionary
    PDF 32000 reference - Table 20
    The PDF trailer must reference this object (/Encrypt)
    &#34;&#34;&#34;

    def __init__(self, security_handler: &#34;StandardSecurityHandler&#34;) -&gt; None:
        super().__init__()
        self.filter = Name(&#34;Standard&#34;)
        self.length = security_handler.key_length
        self.r = security_handler.revision
        self.o = f&#34;&lt;{security_handler.o.upper()}&gt;&#34;
        self.u = f&#34;&lt;{security_handler.u.upper()}&gt;&#34;
        if security_handler.revision == 6:
            self.o_e = f&#34;&lt;{security_handler.oe.upper()}&gt;&#34;
            self.u_e = f&#34;&lt;{security_handler.ue.upper()}&gt;&#34;
            self.perms = f&#34;&lt;{security_handler.perms.upper()}&gt;&#34;
        self.v = security_handler.version
        self.p = int32(security_handler.access_permission)
        if not security_handler.encrypt_metadata:
            self.encrypt_metadata = &#34;false&#34;
        if security_handler.cf:
            self.c_f = pdf_dict({&#34;/StdCF&#34;: security_handler.cf.serialize()})
        if security_handler.encryption_method == EncryptionMethod.NO_ENCRYPTION:
            self.stm_f = Name(&#34;Identity&#34;)  # crypt filter for streams
            self.str_f = Name(&#34;Identity&#34;)  # crypt filter for strings
        else:
            self.stm_f = Name(&#34;StdCF&#34;)  # crypt filter for streams
            self.str_f = Name(&#34;StdCF&#34;)  # crypt filter for strings</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></b></code>:
<ul class="hlist">
<li><code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler"><code class="flex name class">
<span>class <span class="ident">StandardSecurityHandler</span></span>
<span>(</span><span>fpdf, owner_password: str, user_password: Optional[str] = None, permission: <a title="fpdf.enums.AccessPermission" href="enums.html#fpdf.enums.AccessPermission">AccessPermission</a> = 3900, encryption_method: <a title="fpdf.enums.EncryptionMethod" href="enums.html#fpdf.enums.EncryptionMethod">EncryptionMethod</a> = EncryptionMethod.RC4, encrypt_metadata: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is referenced in the main PDF class and is used to handle all encryption functions
* Calculate password and hashes
* Provide encrypt method to be called by stream and strings
* Set the access permissions on the document</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L125-L550" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StandardSecurityHandler:
    &#34;&#34;&#34;
    This class is referenced in the main PDF class and is used to handle all encryption functions
        * Calculate password and hashes
        * Provide encrypt method to be called by stream and strings
        * Set the access permissions on the document
    &#34;&#34;&#34;

    DEFAULT_PADDING = (
        b&#34;(\xbfN^Nu\x8aAd\x00NV\xff\xfa\x01\x08..\x00\xb6\xd0h&gt;\x80/\x0c\xa9\xfedSiz&#34;
    )

    def __init__(
        self,
        fpdf,
        owner_password: str,
        user_password: Union[str, None] = None,
        permission: AccessPermission = AccessPermission.all(),
        encryption_method: EncryptionMethod = EncryptionMethod.RC4,
        encrypt_metadata: bool = False,
    ):
        self.fpdf = fpdf
        self.access_permission = (
            0b11111111111111111111000011000000
            if permission is None
            else (0b11111111111111111111000011000000 | permission)
        )
        self.owner_password = owner_password
        self.user_password = user_password if user_password else &#34;&#34;
        self.encryption_method = encryption_method
        self.cf = None
        self.key_length = 128

        if import_error and self.encryption_method in (
            EncryptionMethod.AES_128,
            EncryptionMethod.AES_256,
        ):
            raise EnvironmentError(
                &#34;cryptography module not available&#34;
                &#34; - Try: &#39;pip install cryptography&#39; or use RC4 encryption method&#34;
                f&#34; - Import error was: {import_error}&#34;
            )
        if self.encryption_method == EncryptionMethod.AES_128:
            self.version = 4
            self.revision = 4
            fpdf._set_min_pdf_version(&#34;1.6&#34;)
            self.cf = CryptFilter(mode=&#34;AESV2&#34;, length=self.key_length)
        elif self.encryption_method == EncryptionMethod.AES_256:
            self.version = 5
            self.revision = 6
            fpdf._set_min_pdf_version(&#34;2.0&#34;)
            self.key_length = 256
            self.cf = CryptFilter(mode=&#34;AESV3&#34;, length=self.key_length)
        elif self.encryption_method == EncryptionMethod.NO_ENCRYPTION:
            self.version = 4
            self.revision = 4
            fpdf._set_min_pdf_version(&#34;1.6&#34;)
            self.cf = CryptFilter(mode=&#34;V2&#34;, length=self.key_length)
        else:
            self.version = 2
            self.revision = 3
            fpdf._set_min_pdf_version(&#34;1.5&#34;)
            # not including crypt filter because it&#39;s only required on V=4
            # if needed, it would be CryptFilter(mode=V2)

        self.encrypt_metadata = encrypt_metadata

    def generate_passwords(self, file_id: str) -&gt; None:
        &#34;&#34;&#34;File_id is the first hash of the PDF file id&#34;&#34;&#34;
        self.file_id = file_id
        self.info_id = file_id[1:33]
        if self.revision == 6:
            self.k = self.get_random_bytes(32)
            self.generate_user_password_rev6()
            self.generate_owner_password_rev6()
            self.generate_perms_rev6()
        else:
            self.o = self.generate_owner_password()
            self.k = self.generate_encryption_key()
            self.u = self.generate_user_password()

    def get_encryption_obj(self) -&gt; EncryptionDictionary:
        &#34;&#34;&#34;Return an encryption dictionary&#34;&#34;&#34;
        return EncryptionDictionary(self)

    def encrypt(
        self, text: Union[str, bytearray, bytes], obj_id: int
    ) -&gt; Union[str, bytes]:
        &#34;&#34;&#34;Method invoked by PDFObject and PDFContentStream to encrypt strings and streams&#34;&#34;&#34;
        LOGGER.debug(&#34;Encrypting %s&#34;, text)
        return (
            self.encrypt_stream(text, obj_id)
            if isinstance(text, (bytearray, bytes))
            else self.encrypt_string(text, obj_id)
        )

    def encrypt_string(self, string: str, obj_id: int) -&gt; str:
        if self.encryption_method == EncryptionMethod.NO_ENCRYPTION:
            return PDFString(string, encrypt=False).serialize()
        LOGGER.debug(&#34;Encrypting string: %s&#34;, string)
        try:
            string.encode(&#34;latin-1&#34;)
            return f&#34;&lt;{bytes(self.encrypt_bytes(string.encode(&#39;latin-1&#39;), obj_id)).hex().upper()}&gt;&#34;
        except UnicodeEncodeError:
            return f&#39;&lt;{hexlify(bytearray(self.encrypt_bytes(BOM_UTF16_BE + string.encode(&#34;utf-16-be&#34;), obj_id))).decode(&#34;latin-1&#34;)}&gt;&#39;

    def encrypt_stream(self, stream: bytes, obj_id: int) -&gt; bytes:
        if self.encryption_method == EncryptionMethod.NO_ENCRYPTION:
            return stream
        return bytes(self.encrypt_bytes(stream, obj_id))

    def is_aes_algorithm(self) -&gt; bool:
        return self.encryption_method in (
            EncryptionMethod.AES_128,
            EncryptionMethod.AES_256,
        )

    def encrypt_bytes(self, data: bytes, obj_id: int):
        &#34;&#34;&#34;
        PDF32000 reference - Algorithm 1: Encryption of data using the RC4 or AES algorithms
        Append object ID and generation ID to the key and encrypt the data
        Generation ID is fixed as 0. Will need to revisit if the application start changing generation ID
        &#34;&#34;&#34;
        h = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
        h.update(self.k)
        h.update(
            (obj_id &amp; 0xFFFFFF).to_bytes(3, byteorder=&#34;little&#34;, signed=False)
        )  # object id
        h.update(
            (0 &amp; 0xFFFF).to_bytes(2, byteorder=&#34;little&#34;, signed=False)
        )  # generation id
        if self.is_aes_algorithm():
            h.update(bytes([0x73, 0x41, 0x6C, 0x54]))  # add salt (sAlT) for AES
        key = h.digest()

        if self.is_aes_algorithm():
            return self.encrypt_AES_cryptography(key, data)
        return ARC4().encrypt(key, data)

    def encrypt_AES_cryptography(self, key: bytes, data: bytes) -&gt; bytes:
        &#34;&#34;&#34;Encrypts an array of bytes using AES algorithms (AES 128 or AES 256)&#34;&#34;&#34;
        iv = bytearray(self.get_random_bytes(16))
        padder = PKCS7(128).padder()
        padded_data = padder.update(data)
        padded_data += padder.finalize()
        cipher = (
            Cipher(AES128(key), modes.CBC(iv))
            if self.encryption_method == EncryptionMethod.AES_128
            else Cipher(AES256(self.k), modes.CBC(iv))
        )
        encryptor = cipher.encryptor()
        data = encryptor.update(padded_data) + encryptor.finalize()
        iv.extend(data)
        return iv

    @classmethod
    def get_random_bytes(cls: Type[&#34;StandardSecurityHandler&#34;], size: int) -&gt; bytes:
        &#34;&#34;&#34;
        https://docs.python.org/3/library/os.html#os.urandom
        os.urandom will use OS-specific sources to generate random bytes
        suitable for cryptographic use
        &#34;&#34;&#34;
        return urandom(size)

    @classmethod
    def prepare_string(cls: Type[&#34;StandardSecurityHandler&#34;], string: str) -&gt; bytes:
        &#34;&#34;&#34;
        PDF2.0 - ISO 32000-2:2020
        All passwords for revision 6 shall be based on Unicode. Preprocessing of a user-provided password
        consists first of normalizing its representation by applying the &#34;SASLPrep&#34; profile (Internet RFC 4013)
        of the &#34;stringprep&#34; algorithm (Internet RFC 3454) to the supplied password using the Normalize and BiDi
        options. Next, the password string shall be converted to UTF-8 encoding, and then truncated to the
        first 127 bytes if the string is longer than 127 bytes

        Python offers a stringprep module with the tables mapped in methods
        &#34;&#34;&#34;

        # Mapping
        def char_map(char: str) -&gt; str:
            if not char:
                return &#34;&#34;
            # Commonly mapped to nothing
            if stringprep.in_table_b1(char):
                return &#34;&#34;
            # Map non-ascii space characters to space
            if stringprep.in_table_c12(char):
                return &#34;\u0020&#34;
            return char

        if len(string) &lt; 1:
            return bytes()

        prepared_string = &#34;&#34;.join(char_map(c) for c in string)

        # Normalization - applies Unicode normalization form KC
        prepared_string = unicodedata.ucd_3_2_0.normalize(&#34;NFKC&#34;, prepared_string)

        # Prohibited output - RCF4013 2.3
        def is_prohibited(char: str) -&gt; bool:
            return (
                stringprep.in_table_c12(char)  # Non-ASCII space characters
                or stringprep.in_table_c21_c22(char)  # Control characters
                or stringprep.in_table_c3(char)  # Private use
                or stringprep.in_table_c4(char)  # Non-character code points
                or stringprep.in_table_c5(char)  # Surrogate codes
                or stringprep.in_table_c6(char)  # Inappropriate for plain text
                or stringprep.in_table_c7(
                    char
                )  # Inappropriate for canonical representation
                or stringprep.in_table_c8(
                    char
                )  # Change display properties or are deprecated
                or stringprep.in_table_c9(char)  # Tagging characters
            )

        for char in prepared_string:
            if is_prohibited(char):
                raise FPDFException(
                    f&#34;The password {string} contains prohibited characters&#34;
                )

        # Bidirectional characters
        def has_character(string: str, fun: Callable) -&gt; bool:
            return any(fun(char) for char in string)

        if has_character(prepared_string, stringprep.in_table_d1):
            # If a string contains any RandALCat character, the string MUST NOT contain any LCat character.
            if has_character(prepared_string, stringprep.in_table_d2):
                raise FPDFException(
                    f&#34;The password {string} contains invalid bidirectional characters.&#34;
                )
            # If a string contains any RandALCat character, a RandALCat character MUST be the first character
            # of the string, and a RandALCat character MUST be the last character of the string.
            if not (
                stringprep.in_table_d1(prepared_string[0])
                and stringprep.in_table_d1(prepared_string[-1])
            ):
                raise FPDFException(
                    f&#34;The password {string} contains invalid bidirectional characters.&#34;
                )

        if len(prepared_string) &gt; 127:
            prepared_string = prepared_string[:127]

        return prepared_string.encode(&#34;UTF-8&#34;)

    def padded_password(self, password: str) -&gt; bytearray:
        &#34;&#34;&#34;
        PDF32000 reference - Algorithm 2: Computing an encryption key
        Step (a) - Add the default padding at the end of provided password to make it 32 bit long
        &#34;&#34;&#34;
        if len(password) &gt; 32:
            password = password[:32]
        p = bytearray(password.encode(&#34;latin1&#34;))
        p.extend(self.DEFAULT_PADDING[: (32 - len(p))])
        return p

    def generate_owner_password(self) -&gt; str:
        &#34;&#34;&#34;
        PDF32000 reference - Algorithm 3: Computing the encryption dictionary&#39;s O (owner password) value
        The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here
        &#34;&#34;&#34;
        m = self.padded_password(self.owner_password)
        for _ in range(51):
            m = md5(m)
        rc4key = m[: (math.ceil(self.key_length / 8))]
        result = self.padded_password(self.user_password)
        for i in range(20):
            new_key = []
            for k in rc4key:
                new_key.append(k ^ i)
            result = ARC4().encrypt(bytes(new_key), result)
        return bytes(result).hex()

    def generate_user_password(self) -&gt; str:
        &#34;&#34;&#34;
        PDF32000 reference - Algorithm 5: Computing the encryption dictionary&#39;s U (user password) value
        The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here
        &#34;&#34;&#34;
        m = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
        m.update(bytearray(self.DEFAULT_PADDING))
        m.update(bytes.fromhex(self.info_id))
        result = bytearray(m.digest())
        key = self.k
        for i in range(20):
            new_key = []
            for k in key:
                new_key.append(k ^ i)
            result = ARC4().encrypt(bytes(new_key), result)
        result.extend(
            (result[x] ^ self.DEFAULT_PADDING[x]) for x in range(16)
        )  # add 16 bytes of random padding
        return bytes(result).hex()

    @classmethod
    def compute_hash(
        cls: Type[&#34;StandardSecurityHandler&#34;],
        input_password: bytes,
        salt: bytes,
        user_key: bytes = bytearray(),
    ) -&gt; bytes:
        &#34;&#34;&#34;
        Algorithm 2B - section 7.6.4.3.4 of the ISO 32000-2:2020
        Applied on Security handlers revision 6
        &#34;&#34;&#34;
        k = hashlib.sha256(input_password + salt + user_key).digest()
        round_number = 0
        while True:
            round_number += 1
            k1 = input_password + k + user_key
            # Step (a + b)
            cipher = Cipher(AES128(k[:16]), modes.CBC(k[16:32]))
            encryptor = cipher.encryptor()
            e = encryptor.update(k1 * 64) + encryptor.finalize()
            # Step (c)
            # remainder = int.from_bytes(e[:16], byteorder=&#34;big&#34;) % 3
            remainder = sum(e[:16]) % 3
            # Step (d)
            if remainder == 0:
                k = hashlib.sha256(e).digest()
            elif remainder == 1:
                k = hashlib.sha384(e).digest()
            else:
                k = hashlib.sha512(e).digest()
            # Step (e)
            if round_number &gt;= 64 and e[-1] &lt;= round_number - 32:
                break

        return k[:32]

    def generate_user_password_rev6(self) -&gt; None:
        &#34;&#34;&#34;
        Generating the U (user password) and UE (user encryption)
        for security handlers of revision 6
        Algorithm 8 - Section 7.6.4.4.7 of the ISO 32000-2:2020
        &#34;&#34;&#34;
        user_password = self.prepare_string(self.user_password)
        if not user_password:
            user_password = bytearray()
        user_validation_salt = self.get_random_bytes(8)
        user_key_salt = self.get_random_bytes(8)
        u = (
            self.compute_hash(input_password=user_password, salt=user_validation_salt)
            + user_validation_salt
            + user_key_salt
        )
        self.u = u.hex()

        key = self.compute_hash(input_password=user_password, salt=user_key_salt)
        cipher = Cipher(AES256(key), modes.CBC(b&#34;\x00&#34; * 16))
        encryptor = cipher.encryptor()
        ue = encryptor.update(self.k) + encryptor.finalize()
        self.ue = ue.hex()

    def generate_owner_password_rev6(self) -&gt; None:
        &#34;&#34;&#34;
        Generating the O (owner password) and OE (owner encryption)
        for security handlers of revision 6
        Algorithm 9 - Section 7.6.4.4.8 of the ISO 32000-2:2020
        &#34;&#34;&#34;
        owner_password = self.prepare_string(self.owner_password)
        if not owner_password:
            raise FPDFException(f&#34;Invalid owner password {self.owner_password}&#34;)
        owner_validation_salt = self.get_random_bytes(8)
        owner_key_salt = self.get_random_bytes(8)
        o = (
            self.compute_hash(
                input_password=owner_password,
                salt=owner_validation_salt,
                user_key=bytes.fromhex(self.u),
            )
            + owner_validation_salt
            + owner_key_salt
        )
        self.o = o.hex()

        key = self.compute_hash(
            input_password=owner_password,
            salt=owner_key_salt,
            user_key=bytes.fromhex(self.u),
        )

        cipher = Cipher(AES256(key), modes.CBC(b&#34;\x00&#34; * 16))
        encryptor = cipher.encryptor()
        oe = encryptor.update(self.k) + encryptor.finalize()
        self.oe = oe.hex()

    def generate_perms_rev6(self) -&gt; None:
        &#34;&#34;&#34;
        7.6.4.4.9 Algorithm 10: Computing the encryption dictionary’s Perms (permissions) value
        (Security handlers of revision 6) of the ISO 32000-2:2020
        &#34;&#34;&#34;
        perms64b = 0xFFFFFFFF00000000 | self.access_permission
        encrypt_metadata = b&#34;T&#34; if self.encrypt_metadata else b&#34;F&#34;
        perms_input = (
            perms64b.to_bytes(8, byteorder=&#34;little&#34;, signed=False)
            + encrypt_metadata
            + b&#34;adb&#34;
            + self.get_random_bytes(4)
        )
        # nosemgrep: python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb
        cipher = Cipher(AES256(self.k), modes.ECB())
        encryptor = cipher.encryptor()
        perms = encryptor.update(perms_input) + encryptor.finalize()
        self.perms = perms.hex()

    def generate_encryption_key(self) -&gt; bytes:
        &#34;&#34;&#34;
        PDF32000 reference
        Algorithm 2: Computing an encryption key
        &#34;&#34;&#34;
        m = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
        m.update(self.padded_password(self.user_password))
        m.update(bytes.fromhex(self.o))
        m.update(
            (self.access_permission &amp; 0xFFFFFFFF).to_bytes(
                4, byteorder=&#34;little&#34;, signed=False
            )
        )
        m.update(bytes.fromhex(self.info_id))
        if self.encrypt_metadata is False and self.version == 4:
            m.update(bytes([0xFF, 0xFF, 0xFF, 0xFF]))
        result = m.digest()[: (math.ceil(self.key_length / 8))]
        for _ in range(50):
            result = md5(result)[: (math.ceil(self.key_length / 8))]
        return result</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="fpdf.encryption.StandardSecurityHandler.DEFAULT_PADDING"><code class="name">var <span class="ident">DEFAULT_PADDING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.encryption.StandardSecurityHandler.compute_hash"><code class="name flex">
<span>def <span class="ident">compute_hash</span></span>(<span>input_password: bytes, salt: bytes, user_key: bytes = bytearray(b'')) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Algorithm 2B - section 7.6.4.3.4 of the ISO 32000-2:2020
Applied on Security handlers revision 6</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L419-L453" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def compute_hash(
    cls: Type[&#34;StandardSecurityHandler&#34;],
    input_password: bytes,
    salt: bytes,
    user_key: bytes = bytearray(),
) -&gt; bytes:
    &#34;&#34;&#34;
    Algorithm 2B - section 7.6.4.3.4 of the ISO 32000-2:2020
    Applied on Security handlers revision 6
    &#34;&#34;&#34;
    k = hashlib.sha256(input_password + salt + user_key).digest()
    round_number = 0
    while True:
        round_number += 1
        k1 = input_password + k + user_key
        # Step (a + b)
        cipher = Cipher(AES128(k[:16]), modes.CBC(k[16:32]))
        encryptor = cipher.encryptor()
        e = encryptor.update(k1 * 64) + encryptor.finalize()
        # Step (c)
        # remainder = int.from_bytes(e[:16], byteorder=&#34;big&#34;) % 3
        remainder = sum(e[:16]) % 3
        # Step (d)
        if remainder == 0:
            k = hashlib.sha256(e).digest()
        elif remainder == 1:
            k = hashlib.sha384(e).digest()
        else:
            k = hashlib.sha512(e).digest()
        # Step (e)
        if round_number &gt;= 64 and e[-1] &lt;= round_number - 32:
            break

    return k[:32]</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.get_random_bytes"><code class="name flex">
<span>def <span class="ident">get_random_bytes</span></span>(<span>size: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p><a href="https://docs.python.org/3/library/os.html#os.urandom">https://docs.python.org/3/library/os.html#os.urandom</a>
os.urandom will use OS-specific sources to generate random bytes
suitable for cryptographic use</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L280-L287" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def get_random_bytes(cls: Type[&#34;StandardSecurityHandler&#34;], size: int) -&gt; bytes:
    &#34;&#34;&#34;
    https://docs.python.org/3/library/os.html#os.urandom
    os.urandom will use OS-specific sources to generate random bytes
    suitable for cryptographic use
    &#34;&#34;&#34;
    return urandom(size)</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.prepare_string"><code class="name flex">
<span>def <span class="ident">prepare_string</span></span>(<span>string: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>PDF2.0 - ISO 32000-2:2020
All passwords for revision 6 shall be based on Unicode. Preprocessing of a user-provided password
consists first of normalizing its representation by applying the "SASLPrep" profile (Internet RFC 4013)
of the "stringprep" algorithm (Internet RFC 3454) to the supplied password using the Normalize and BiDi
options. Next, the password string shall be converted to UTF-8 encoding, and then truncated to the
first 127 bytes if the string is longer than 127 bytes</p>
<p>Python offers a stringprep module with the tables mapped in methods</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L289-L369" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def prepare_string(cls: Type[&#34;StandardSecurityHandler&#34;], string: str) -&gt; bytes:
    &#34;&#34;&#34;
    PDF2.0 - ISO 32000-2:2020
    All passwords for revision 6 shall be based on Unicode. Preprocessing of a user-provided password
    consists first of normalizing its representation by applying the &#34;SASLPrep&#34; profile (Internet RFC 4013)
    of the &#34;stringprep&#34; algorithm (Internet RFC 3454) to the supplied password using the Normalize and BiDi
    options. Next, the password string shall be converted to UTF-8 encoding, and then truncated to the
    first 127 bytes if the string is longer than 127 bytes

    Python offers a stringprep module with the tables mapped in methods
    &#34;&#34;&#34;

    # Mapping
    def char_map(char: str) -&gt; str:
        if not char:
            return &#34;&#34;
        # Commonly mapped to nothing
        if stringprep.in_table_b1(char):
            return &#34;&#34;
        # Map non-ascii space characters to space
        if stringprep.in_table_c12(char):
            return &#34;\u0020&#34;
        return char

    if len(string) &lt; 1:
        return bytes()

    prepared_string = &#34;&#34;.join(char_map(c) for c in string)

    # Normalization - applies Unicode normalization form KC
    prepared_string = unicodedata.ucd_3_2_0.normalize(&#34;NFKC&#34;, prepared_string)

    # Prohibited output - RCF4013 2.3
    def is_prohibited(char: str) -&gt; bool:
        return (
            stringprep.in_table_c12(char)  # Non-ASCII space characters
            or stringprep.in_table_c21_c22(char)  # Control characters
            or stringprep.in_table_c3(char)  # Private use
            or stringprep.in_table_c4(char)  # Non-character code points
            or stringprep.in_table_c5(char)  # Surrogate codes
            or stringprep.in_table_c6(char)  # Inappropriate for plain text
            or stringprep.in_table_c7(
                char
            )  # Inappropriate for canonical representation
            or stringprep.in_table_c8(
                char
            )  # Change display properties or are deprecated
            or stringprep.in_table_c9(char)  # Tagging characters
        )

    for char in prepared_string:
        if is_prohibited(char):
            raise FPDFException(
                f&#34;The password {string} contains prohibited characters&#34;
            )

    # Bidirectional characters
    def has_character(string: str, fun: Callable) -&gt; bool:
        return any(fun(char) for char in string)

    if has_character(prepared_string, stringprep.in_table_d1):
        # If a string contains any RandALCat character, the string MUST NOT contain any LCat character.
        if has_character(prepared_string, stringprep.in_table_d2):
            raise FPDFException(
                f&#34;The password {string} contains invalid bidirectional characters.&#34;
            )
        # If a string contains any RandALCat character, a RandALCat character MUST be the first character
        # of the string, and a RandALCat character MUST be the last character of the string.
        if not (
            stringprep.in_table_d1(prepared_string[0])
            and stringprep.in_table_d1(prepared_string[-1])
        ):
            raise FPDFException(
                f&#34;The password {string} contains invalid bidirectional characters.&#34;
            )

    if len(prepared_string) &gt; 127:
        prepared_string = prepared_string[:127]

    return prepared_string.encode(&#34;UTF-8&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.encryption.StandardSecurityHandler.encrypt"><code class="name flex">
<span>def <span class="ident">encrypt</span></span>(<span>self, text: Union[str, bytearray, bytes], obj_id: int) ‑> Union[str, bytes]</span>
</code></dt>
<dd>
<div class="desc"><p>Method invoked by PDFObject and PDFContentStream to encrypt strings and streams</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L210-L219" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encrypt(
    self, text: Union[str, bytearray, bytes], obj_id: int
) -&gt; Union[str, bytes]:
    &#34;&#34;&#34;Method invoked by PDFObject and PDFContentStream to encrypt strings and streams&#34;&#34;&#34;
    LOGGER.debug(&#34;Encrypting %s&#34;, text)
    return (
        self.encrypt_stream(text, obj_id)
        if isinstance(text, (bytearray, bytes))
        else self.encrypt_string(text, obj_id)
    )</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.encrypt_AES_cryptography"><code class="name flex">
<span>def <span class="ident">encrypt_AES_cryptography</span></span>(<span>self, key: bytes, data: bytes) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypts an array of bytes using AES algorithms (AES 128 or AES 256)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L264-L278" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encrypt_AES_cryptography(self, key: bytes, data: bytes) -&gt; bytes:
    &#34;&#34;&#34;Encrypts an array of bytes using AES algorithms (AES 128 or AES 256)&#34;&#34;&#34;
    iv = bytearray(self.get_random_bytes(16))
    padder = PKCS7(128).padder()
    padded_data = padder.update(data)
    padded_data += padder.finalize()
    cipher = (
        Cipher(AES128(key), modes.CBC(iv))
        if self.encryption_method == EncryptionMethod.AES_128
        else Cipher(AES256(self.k), modes.CBC(iv))
    )
    encryptor = cipher.encryptor()
    data = encryptor.update(padded_data) + encryptor.finalize()
    iv.extend(data)
    return iv</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.encrypt_bytes"><code class="name flex">
<span>def <span class="ident">encrypt_bytes</span></span>(<span>self, data: bytes, obj_id: int)</span>
</code></dt>
<dd>
<div class="desc"><p>PDF32000 reference - Algorithm 1: Encryption of data using the RC4 or AES algorithms
Append object ID and generation ID to the key and encrypt the data
Generation ID is fixed as 0. Will need to revisit if the application start changing generation ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L242-L262" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encrypt_bytes(self, data: bytes, obj_id: int):
    &#34;&#34;&#34;
    PDF32000 reference - Algorithm 1: Encryption of data using the RC4 or AES algorithms
    Append object ID and generation ID to the key and encrypt the data
    Generation ID is fixed as 0. Will need to revisit if the application start changing generation ID
    &#34;&#34;&#34;
    h = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
    h.update(self.k)
    h.update(
        (obj_id &amp; 0xFFFFFF).to_bytes(3, byteorder=&#34;little&#34;, signed=False)
    )  # object id
    h.update(
        (0 &amp; 0xFFFF).to_bytes(2, byteorder=&#34;little&#34;, signed=False)
    )  # generation id
    if self.is_aes_algorithm():
        h.update(bytes([0x73, 0x41, 0x6C, 0x54]))  # add salt (sAlT) for AES
    key = h.digest()

    if self.is_aes_algorithm():
        return self.encrypt_AES_cryptography(key, data)
    return ARC4().encrypt(key, data)</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.encrypt_stream"><code class="name flex">
<span>def <span class="ident">encrypt_stream</span></span>(<span>self, stream: bytes, obj_id: int) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L231-L234" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encrypt_stream(self, stream: bytes, obj_id: int) -&gt; bytes:
    if self.encryption_method == EncryptionMethod.NO_ENCRYPTION:
        return stream
    return bytes(self.encrypt_bytes(stream, obj_id))</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.encrypt_string"><code class="name flex">
<span>def <span class="ident">encrypt_string</span></span>(<span>self, string: str, obj_id: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L221-L229" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def encrypt_string(self, string: str, obj_id: int) -&gt; str:
    if self.encryption_method == EncryptionMethod.NO_ENCRYPTION:
        return PDFString(string, encrypt=False).serialize()
    LOGGER.debug(&#34;Encrypting string: %s&#34;, string)
    try:
        string.encode(&#34;latin-1&#34;)
        return f&#34;&lt;{bytes(self.encrypt_bytes(string.encode(&#39;latin-1&#39;), obj_id)).hex().upper()}&gt;&#34;
    except UnicodeEncodeError:
        return f&#39;&lt;{hexlify(bytearray(self.encrypt_bytes(BOM_UTF16_BE + string.encode(&#34;utf-16-be&#34;), obj_id))).decode(&#34;latin-1&#34;)}&gt;&#39;</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.generate_encryption_key"><code class="name flex">
<span>def <span class="ident">generate_encryption_key</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>PDF32000 reference
Algorithm 2: Computing an encryption key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L531-L550" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generate_encryption_key(self) -&gt; bytes:
    &#34;&#34;&#34;
    PDF32000 reference
    Algorithm 2: Computing an encryption key
    &#34;&#34;&#34;
    m = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
    m.update(self.padded_password(self.user_password))
    m.update(bytes.fromhex(self.o))
    m.update(
        (self.access_permission &amp; 0xFFFFFFFF).to_bytes(
            4, byteorder=&#34;little&#34;, signed=False
        )
    )
    m.update(bytes.fromhex(self.info_id))
    if self.encrypt_metadata is False and self.version == 4:
        m.update(bytes([0xFF, 0xFF, 0xFF, 0xFF]))
    result = m.digest()[: (math.ceil(self.key_length / 8))]
    for _ in range(50):
        result = md5(result)[: (math.ceil(self.key_length / 8))]
    return result</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.generate_owner_password"><code class="name flex">
<span>def <span class="ident">generate_owner_password</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>PDF32000 reference - Algorithm 3: Computing the encryption dictionary's O (owner password) value
The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L382-L397" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generate_owner_password(self) -&gt; str:
    &#34;&#34;&#34;
    PDF32000 reference - Algorithm 3: Computing the encryption dictionary&#39;s O (owner password) value
    The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here
    &#34;&#34;&#34;
    m = self.padded_password(self.owner_password)
    for _ in range(51):
        m = md5(m)
    rc4key = m[: (math.ceil(self.key_length / 8))]
    result = self.padded_password(self.user_password)
    for i in range(20):
        new_key = []
        for k in rc4key:
            new_key.append(k ^ i)
        result = ARC4().encrypt(bytes(new_key), result)
    return bytes(result).hex()</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.generate_owner_password_rev6"><code class="name flex">
<span>def <span class="ident">generate_owner_password_rev6</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Generating the O (owner password) and OE (owner encryption)
for security handlers of revision 6
Algorithm 9 - Section 7.6.4.4.8 of the ISO 32000-2:2020</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L479-L510" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generate_owner_password_rev6(self) -&gt; None:
    &#34;&#34;&#34;
    Generating the O (owner password) and OE (owner encryption)
    for security handlers of revision 6
    Algorithm 9 - Section 7.6.4.4.8 of the ISO 32000-2:2020
    &#34;&#34;&#34;
    owner_password = self.prepare_string(self.owner_password)
    if not owner_password:
        raise FPDFException(f&#34;Invalid owner password {self.owner_password}&#34;)
    owner_validation_salt = self.get_random_bytes(8)
    owner_key_salt = self.get_random_bytes(8)
    o = (
        self.compute_hash(
            input_password=owner_password,
            salt=owner_validation_salt,
            user_key=bytes.fromhex(self.u),
        )
        + owner_validation_salt
        + owner_key_salt
    )
    self.o = o.hex()

    key = self.compute_hash(
        input_password=owner_password,
        salt=owner_key_salt,
        user_key=bytes.fromhex(self.u),
    )

    cipher = Cipher(AES256(key), modes.CBC(b&#34;\x00&#34; * 16))
    encryptor = cipher.encryptor()
    oe = encryptor.update(self.k) + encryptor.finalize()
    self.oe = oe.hex()</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.generate_passwords"><code class="name flex">
<span>def <span class="ident">generate_passwords</span></span>(<span>self, file_id: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>File_id is the first hash of the PDF file id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L192-L204" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generate_passwords(self, file_id: str) -&gt; None:
    &#34;&#34;&#34;File_id is the first hash of the PDF file id&#34;&#34;&#34;
    self.file_id = file_id
    self.info_id = file_id[1:33]
    if self.revision == 6:
        self.k = self.get_random_bytes(32)
        self.generate_user_password_rev6()
        self.generate_owner_password_rev6()
        self.generate_perms_rev6()
    else:
        self.o = self.generate_owner_password()
        self.k = self.generate_encryption_key()
        self.u = self.generate_user_password()</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.generate_perms_rev6"><code class="name flex">
<span>def <span class="ident">generate_perms_rev6</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>7.6.4.4.9 Algorithm 10: Computing the encryption dictionary’s Perms (permissions) value
(Security handlers of revision 6) of the ISO 32000-2:2020</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L512-L529" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generate_perms_rev6(self) -&gt; None:
    &#34;&#34;&#34;
    7.6.4.4.9 Algorithm 10: Computing the encryption dictionary’s Perms (permissions) value
    (Security handlers of revision 6) of the ISO 32000-2:2020
    &#34;&#34;&#34;
    perms64b = 0xFFFFFFFF00000000 | self.access_permission
    encrypt_metadata = b&#34;T&#34; if self.encrypt_metadata else b&#34;F&#34;
    perms_input = (
        perms64b.to_bytes(8, byteorder=&#34;little&#34;, signed=False)
        + encrypt_metadata
        + b&#34;adb&#34;
        + self.get_random_bytes(4)
    )
    # nosemgrep: python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb
    cipher = Cipher(AES256(self.k), modes.ECB())
    encryptor = cipher.encryptor()
    perms = encryptor.update(perms_input) + encryptor.finalize()
    self.perms = perms.hex()</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.generate_user_password"><code class="name flex">
<span>def <span class="ident">generate_user_password</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>PDF32000 reference - Algorithm 5: Computing the encryption dictionary's U (user password) value
The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L399-L417" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generate_user_password(self) -&gt; str:
    &#34;&#34;&#34;
    PDF32000 reference - Algorithm 5: Computing the encryption dictionary&#39;s U (user password) value
    The security handler is only using revision 3 or 4, so the legacy r2 version is not implemented here
    &#34;&#34;&#34;
    m = hashlib.new(&#34;md5&#34;, usedforsecurity=False)
    m.update(bytearray(self.DEFAULT_PADDING))
    m.update(bytes.fromhex(self.info_id))
    result = bytearray(m.digest())
    key = self.k
    for i in range(20):
        new_key = []
        for k in key:
            new_key.append(k ^ i)
        result = ARC4().encrypt(bytes(new_key), result)
    result.extend(
        (result[x] ^ self.DEFAULT_PADDING[x]) for x in range(16)
    )  # add 16 bytes of random padding
    return bytes(result).hex()</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.generate_user_password_rev6"><code class="name flex">
<span>def <span class="ident">generate_user_password_rev6</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Generating the U (user password) and UE (user encryption)
for security handlers of revision 6
Algorithm 8 - Section 7.6.4.4.7 of the ISO 32000-2:2020</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L455-L477" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def generate_user_password_rev6(self) -&gt; None:
    &#34;&#34;&#34;
    Generating the U (user password) and UE (user encryption)
    for security handlers of revision 6
    Algorithm 8 - Section 7.6.4.4.7 of the ISO 32000-2:2020
    &#34;&#34;&#34;
    user_password = self.prepare_string(self.user_password)
    if not user_password:
        user_password = bytearray()
    user_validation_salt = self.get_random_bytes(8)
    user_key_salt = self.get_random_bytes(8)
    u = (
        self.compute_hash(input_password=user_password, salt=user_validation_salt)
        + user_validation_salt
        + user_key_salt
    )
    self.u = u.hex()

    key = self.compute_hash(input_password=user_password, salt=user_key_salt)
    cipher = Cipher(AES256(key), modes.CBC(b&#34;\x00&#34; * 16))
    encryptor = cipher.encryptor()
    ue = encryptor.update(self.k) + encryptor.finalize()
    self.ue = ue.hex()</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.get_encryption_obj"><code class="name flex">
<span>def <span class="ident">get_encryption_obj</span></span>(<span>self) ‑> <a title="fpdf.encryption.EncryptionDictionary" href="#fpdf.encryption.EncryptionDictionary">EncryptionDictionary</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return an encryption dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L206-L208" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_encryption_obj(self) -&gt; EncryptionDictionary:
    &#34;&#34;&#34;Return an encryption dictionary&#34;&#34;&#34;
    return EncryptionDictionary(self)</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.is_aes_algorithm"><code class="name flex">
<span>def <span class="ident">is_aes_algorithm</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L236-L240" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_aes_algorithm(self) -&gt; bool:
    return self.encryption_method in (
        EncryptionMethod.AES_128,
        EncryptionMethod.AES_256,
    )</code></pre>
</details>
</dd>
<dt id="fpdf.encryption.StandardSecurityHandler.padded_password"><code class="name flex">
<span>def <span class="ident">padded_password</span></span>(<span>self, password: str) ‑> bytearray</span>
</code></dt>
<dd>
<div class="desc"><p>PDF32000 reference - Algorithm 2: Computing an encryption key
Step (a) - Add the default padding at the end of provided password to make it 32 bit long</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/6a8678b3f33a479b3f918d0024d204cdec084204/fpdf/encryption.py#L371-L380" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def padded_password(self, password: str) -&gt; bytearray:
    &#34;&#34;&#34;
    PDF32000 reference - Algorithm 2: Computing an encryption key
    Step (a) - Add the default padding at the end of provided password to make it 32 bit long
    &#34;&#34;&#34;
    if len(password) &gt; 32:
        password = password[:32]
    p = bytearray(password.encode(&#34;latin1&#34;))
    p.extend(self.DEFAULT_PADDING[: (32 - len(p))])
    return p</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fpdf.encryption.int32" href="#fpdf.encryption.int32">int32</a></code></li>
<li><code><a title="fpdf.encryption.md5" href="#fpdf.encryption.md5">md5</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.encryption.ARC4" href="#fpdf.encryption.ARC4">ARC4</a></code></h4>
<ul class="">
<li><code><a title="fpdf.encryption.ARC4.KSA" href="#fpdf.encryption.ARC4.KSA">KSA</a></code></li>
<li><code><a title="fpdf.encryption.ARC4.MOD" href="#fpdf.encryption.ARC4.MOD">MOD</a></code></li>
<li><code><a title="fpdf.encryption.ARC4.PRGA" href="#fpdf.encryption.ARC4.PRGA">PRGA</a></code></li>
<li><code><a title="fpdf.encryption.ARC4.encrypt" href="#fpdf.encryption.ARC4.encrypt">encrypt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.encryption.CryptFilter" href="#fpdf.encryption.CryptFilter">CryptFilter</a></code></h4>
<ul class="">
<li><code><a title="fpdf.encryption.CryptFilter.serialize" href="#fpdf.encryption.CryptFilter.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.encryption.EncryptionDictionary" href="#fpdf.encryption.EncryptionDictionary">EncryptionDictionary</a></code></h4>
</li>
<li>
<h4><code><a title="fpdf.encryption.StandardSecurityHandler" href="#fpdf.encryption.StandardSecurityHandler">StandardSecurityHandler</a></code></h4>
<ul class="">
<li><code><a title="fpdf.encryption.StandardSecurityHandler.DEFAULT_PADDING" href="#fpdf.encryption.StandardSecurityHandler.DEFAULT_PADDING">DEFAULT_PADDING</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.compute_hash" href="#fpdf.encryption.StandardSecurityHandler.compute_hash">compute_hash</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.encrypt" href="#fpdf.encryption.StandardSecurityHandler.encrypt">encrypt</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.encrypt_AES_cryptography" href="#fpdf.encryption.StandardSecurityHandler.encrypt_AES_cryptography">encrypt_AES_cryptography</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.encrypt_bytes" href="#fpdf.encryption.StandardSecurityHandler.encrypt_bytes">encrypt_bytes</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.encrypt_stream" href="#fpdf.encryption.StandardSecurityHandler.encrypt_stream">encrypt_stream</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.encrypt_string" href="#fpdf.encryption.StandardSecurityHandler.encrypt_string">encrypt_string</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.generate_encryption_key" href="#fpdf.encryption.StandardSecurityHandler.generate_encryption_key">generate_encryption_key</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.generate_owner_password" href="#fpdf.encryption.StandardSecurityHandler.generate_owner_password">generate_owner_password</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.generate_owner_password_rev6" href="#fpdf.encryption.StandardSecurityHandler.generate_owner_password_rev6">generate_owner_password_rev6</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.generate_passwords" href="#fpdf.encryption.StandardSecurityHandler.generate_passwords">generate_passwords</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.generate_perms_rev6" href="#fpdf.encryption.StandardSecurityHandler.generate_perms_rev6">generate_perms_rev6</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.generate_user_password" href="#fpdf.encryption.StandardSecurityHandler.generate_user_password">generate_user_password</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.generate_user_password_rev6" href="#fpdf.encryption.StandardSecurityHandler.generate_user_password_rev6">generate_user_password_rev6</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.get_encryption_obj" href="#fpdf.encryption.StandardSecurityHandler.get_encryption_obj">get_encryption_obj</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.get_random_bytes" href="#fpdf.encryption.StandardSecurityHandler.get_random_bytes">get_random_bytes</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.is_aes_algorithm" href="#fpdf.encryption.StandardSecurityHandler.is_aes_algorithm">is_aes_algorithm</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.padded_password" href="#fpdf.encryption.StandardSecurityHandler.padded_password">padded_password</a></code></li>
<li><code><a title="fpdf.encryption.StandardSecurityHandler.prepare_string" href="#fpdf.encryption.StandardSecurityHandler.prepare_string">prepare_string</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>